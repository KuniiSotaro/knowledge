04 並列処理
==========

* `並列処理`:プログラムで複数の処理を同時に実行すること

  * 「マルチタスク」「マルチスレッド」などとも呼ばれる

* `ゴルーチン`:Go言語で並列処理を行う、Go言語の代表的な機能の1つ

  * 独立して動作する実行単位

  * OSが管理するスレッドに割り当てられて動作

  * `ゴルーチン`として並列実行させたい処理は、関数として実装

  * 関数は、`ゴルーチン`だからと言って特別な実装は必要ない

```go
// ゴルーチン呼び出しの書式
go 関数の呼び出し
```

* 上記の様に関数を呼び出すと、呼び出し元とは別の実行単位で動作を開始

  * 呼び出された関数が終了すると、その`ゴルーチン`も同時に終了する

* 呼び出し側では、`ゴルーチン`として呼び出した関数の終了は待たない

  * そのため、呼び出した関数が返す戻り値を受け取ることは不可

  * また、`main`から開始している親となる処理が終了すれば、いくら他に`ゴルーチン`が動いていても、すべて中断して終了

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("main start.")

	fmt.Println("普通に関数を呼び出す")
	serialno()

	fmt.Println("ゴルーチンとして呼び出す")
	go serialno()

	// ゴルーチン呼び出し後、sleepする
	time.Sleep(1 * time.Second)

	fmt.Println("main end.")
}

func serialno() {
	for i := 0; i < 5; i++ {
		fmt.Println(i)
		// 1秒間sleepする
		time.Sleep(1 * time.Second)
	}
}
```

```txt
main start.
普通に関数を呼び出す
0
1
2
3
4
ゴルーチンとして呼び出す
0
1
main end.
```

* `ゴルーチン`として呼び出した場合は、シリアルナンバーの表示が中断されている

* `ゴルーチン`と呼び出し元の間で、処理結果の連携などは、別途`チャネル`という機能を利用



## ゴルーチン間の通信

* `チャネル`:`ゴルーチン`(`main`含む)間で連携する方法

* `チャネル`を利用することで、`ゴルーチン`間で「通信」「同期処理」が可能になる



### チャネルの作成方法

* `チャネル`を使用するには、「チャネル型」の変数を作成する

  * 送信側・受信側ともに、その変数に対して何らかのデータを送受信する

* 他の型変数と違うのは、送信・受信ができることだけ

```go
// 宣言方法
chan 型 // 送受信可能なチャネル
chan <- 型 // 送信専用チャネル
<- 型 // 受信専用チャネル

// 作成方法
make(chan 型, キャパシティ)
make(chan 型)// キャパシティ0と同じ
```

* 送信専用・受信専用は、主に関数の引数として受け取る際に使用

* `チャネル`はスライスやマップと同じく参照型のため、作成するには`make`関数を使用

* `チャネル`に指定するキャパシティは、チャネルにバッファ可能な容量

  * このサイズが送信データの上限となる



### チャネルのクローズ

* 使用しなくなったチャネルは、`close`関数を使用してクローズする

* ただし受信専用チャネルはクローズできない

```go
// チャネルのクローズ方法
close(チャネル)
```

* クローズ済みの`チャネル`に対して、データを送信するとランタイムパニックになる

* クローズ済みの`チャネル`から受信しようとすると、クローズ前までに送信されたチャネルに残っているデータがなくなるまで受信できる

* 受信側で、チャネルがクローズされたかどうかを確認するには、受信操作時に受け取る2番目のbool値が「false」であれば、クローズ済みである



### チャネルの使用方法

```go
package main

import (
	"fmt"
)

func main() {
	// int型チャネルの作成
	c := make(chan int)

	// 送信専用チャネルを受け取り、1〜10までの数値を送信する
	go func(s chan<- int) {
		for i := 0; i < 10; i++ {
			s <- i
		}
		close(s)
	}(c)

	for {
		// チャネルからの受信を待機
		val, ok := <-c
		if !ok {
			// チャネルがクローズしたので、終了する
			break
		}
		// 受信したデータを表示
		fmt.Println(val)
	}
}
```

```txt
0
1
2
3
4
5
6
7
8
9
```



### チャネルのキャパシティと要素数

* `cap`関数:`チャネル`のキャパシティを取得する

* `len`関数:現在`チャネル`に保存されている要素数を取得する

```go
キャパシティ = cap(チャネル)
要素数 = len(チャネル)
```



### チャネルを利用した同期処理

* `チャネル`のキャパシティ容量いっぱいまで、データがバッファ内に残っている場合

  * 次の送信操作を行うとそこで処理がブロックされる

  * また、他のゴルーチンによってデータが受信されてバッファに空きが出るまで待機

  * バッファに空きが出ると、すぐに送信操作が終了

  * `チャネル`のキャパシティが0の場合は、常にこのような動きをする

* `チャネル`のバッファが空の時に受信操作を行うと、そこで処理がブロックされ、送信されるまで待機

  * バッファにデータが送信されると、受信操作がすぐに終了

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// キャパシティ0で、int型チャネルの作成
	c := make(chan int)

	// 負荷のかかる作業（5秒待機）を3回繰り返した後、通知する
	go func(s chan<- int) {
		for i := 0; i < 3; i++ {
			time.Sleep(5 * time.Second)
			fmt.Println(i+1, "回完了")
		}
		// 適当な数値を送信
		s <- 0
	}(c)

	// 受信を待機
	<-c

	fmt.Println("終了")
}
```

```txt
1 回完了
2 回完了
3 回完了
終了
```

* `main`関数側は、ゴルーチンが送信操作するまで、受信操作で待機している



### ゴルーチン間のデータ共有

* `ゴルーチン`間でデータを共有する場合、グローバル変数を使用することもできる

* `チャネル`を使用することによって、同時アクセスを防ぐことが簡単に実現できる

```go
package main

import (
	"fmt"
)

// 全ゴルーチン数
const goroutines = 5

func main() {
	// 共有データを保持するチャネル
	counter := make(chan int)
	// 全ゴルーチン終了通知用のチャネル
	end := make(chan bool)

	// 5個のゴルーチンを実行する
	for i := 0; i < goroutines; i++ {
		// 共有データ(counter)を受信し、インクリメントする
		go func(counter chan int) {
			// チャネルから共有データの受信
			val := <-counter
			// +1する
			val++
			fmt.Println("counter = ", val)

			if val == goroutines {
				// 最後のゴルーチンの場合は、終了通知用のチャネルへ送信
				end <- true
			}
			// +1したデータを、他のゴルーチンへ送信
			counter <- val
		}(counter)
	}
	// 初期値をチャネルに送信
	counter <- 0
	// 全ゴルーチンの終了を待機
	<-end
	fmt.Println("終了")
}
```

```txt
counter =  1
counter =  2
counter =  3
counter =  4
counter =  5
終了
```

* `main`関数から`counter`へデータ送信後、各ゴルーチンで順にデータを処理
