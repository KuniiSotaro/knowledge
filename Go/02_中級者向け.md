02 中級者向け
===========

## パッケージ

* パッケージ:名前空間を分けるための仕組み



### パッケージの宣言

> コードを具体的に記述するようになったら勉強する



## GOPATHについて

> コードを具体的に記述するようになったら勉強する



## 構造体

* 構造体:複数の要素を組とする型

```go
package main

import "fmt"

func main() {
    var vector struct {
        X int
        Y int
    }

    vector.X = 2
    vector.Y = 5
    fmt.Println(vector) // {2 5}
}
```

* typeキーワードを使用することで、2次元ベクトルを表す構造体型を表すことができる

```go
package main

import "fmt"

type Vector struct {
    X int
    Y int
}

func main() {
    var v Vector

    v.X = 2
    v.Y = 5
    fmt.Println(v) // {2 5}
}
```

* 一度に初期化することも可能

```go
package main

import "fmt"

type Vector struct {
    X int
    Y int
}

func main() {
    v := Vector{X: 2, Y: 5}
    fmt.Println(v) // {2 5}
}
```



### 構造体の可視性

* 構造体のメンバのうち、小文字から始まる名前を持つものはパッケージ外からアクセス不可能

```go
package main

import "test"

/* testパッケージ内に以下の構造体定義があったとする。
type Vector3 struct {
    X int
    Y int
    z int
}
*/

func main() {
    var v test.Vector3
    v.X = 2  // OK
    v.Y = 5  // OK
    v.z = 8  // エラー
}
```

* 構造体名が小文字から始まる場合、パッケージ外でその構造体は作成不可能

```go
package main

import "test"

/* testパッケージ内に以下の構造体定義があったとする。
type vector3 struct {
    X int
    Y int
    Z int
}
*/

func main() {
    var v test.vector3 // エラー
}
```

* 構造体と同パッケージの関数の戻り値としてならば、小文字から始まる構造体をパッケージ外から使用可能

```go
package main

import "test"

/* testパッケージ内に以下の構造体定義があったとする。
type vector3 struct {
    X int
    Y int
    Z int
}

func NewVector() vector3 {
    var v vector3
    return v
}
*/

func main() {
    v := test.NewVector()
    v.X = 2  // OK
    v.Y = 5  // OK
    v.Z = 8  // OK
}
```



## 関数の定義

* funcキーワード:関数の定義を行う

```go
package main

import "fmt"

func main() {
    DisplayHello()
}

func DisplayHello() {
    fmt.Println("Hello!") // Hello!
}
```



### 引数の指定

* 引数リスト:関数名の直後の丸括弧内に記述

* 引数:引数名・型名の順番に、スペース区切りで指定

* 複数の引数を指定:引数名・型名の組同士をカンマで区切る

```go
package main

import "fmt"

func main() {
    DisplaySum(2, 5) // 7が表示される
}

func DisplaySum(left int, right int) {
    fmt.Println(left + right)
}
```



### 可変長引数

* 可変長引数を持つ関数の定義:型名の前に`...`

> `range`:Goの場合は、インデックスが第一返り値、値が第二返り値で出力

```go
package main

import "fmt"

func main() {
    DisplaySumAll(2, 5, 8, 11) // 26が表示される
}

func DisplaySumAll(values ...int) {
    sum := 0
    for _, value := range values {
        sum += value
    }
    fmt.Println(sum)
}
```



## 戻り値の指定

* 引数リストの後ろに型を指定することで、関数から戻り値を返す

```go
package main

import "fmt"

func main() {
    fmt.Println(Sum(2, 5)) // 7が表示される
}

func Sum(left int, right int) int {
    return left + right
}
```

* 戻り値の型を複数指定することで、複数の値を返す関数を定義

```go
package main

import "fmt"

func main() {
    result, remainder := Div(19, 4)
    fmt.Printf("19を4で割ると%dあまり%dです。\n", result, remainder)
}

func Div(left int, right int) (int, int) { // 複数指定の場合は戻り値を丸括弧で囲む
    return left / right, left % right
}
```



### 関数のスコープ

関数の名前が小文字から始まる場合は、その関数は他のパッケージから使用不可



## レシーバ変数とメソッド

* 関数名の前にレシーバ変数を指定することが可能

> レシーバ変数を指定した関数のことを、その変数のメソッドと呼ぶ

* 構造体とそのメソッドを用いることである程度オブジェクト指向「らしく」プログラミング可能

```go
package main

import "fmt"

type LoopNum int

func main() {
    var three LoopNum = 3
    three.TimesDisplay("Hello") // 「Hello」と3回表示される
}

func (n LoopNum) TimesDisplay(s string) {
    for i := 0; i < int(n); i++ {
        fmt.Println(s)
    }
}
```

> `Income`メソッドや`Break`メソッドは構造体メンバの値を書き換える必要があるため、 レシーバはポインタ型

```go
package main

import "fmt"

type SavingBox struct {
    money int
}

func NewBox() *SavingBox {
    return new(SavingBox)
}

func (s *SavingBox) Income(amount int) {
    s.money += amount
}

func (s *SavingBox) Break() int {
    lastMoney := s.money
    s.money = 0
    return lastMoney
}

func main() {
    box := NewBox()
    box.Income(100)
    box.Income(200)
    box.Income(500)

    fmt.Printf("貯金箱を壊したら%d円出てきました。\n", box.Break())
}
```



## 遅延実行

* `defer`キーワード:特定の処理を関数の一番最後に実行

```go
package main

import "fmt"

func main() {
    defer fmt.Println("A")
    fmt.Println("B")
}
```

```txt
B
A
```

* `defer`を複数書くことが可能

* 最初に`defer`された行が一番最後に実行

```go
package main

import "fmt"

func main() {
    defer fmt.Println("A")
    defer fmt.Println("B")
    defer fmt.Println("C")
    fmt.Println("D")
}
```

```txt
D
C
B
A
```



### 遅延実行の使いどころ

* ex:ファイルの内容を標準出力するコードです

* problem:ファイルの`Read`でエラーが発生すると、ファイルが`Close`されない

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("hoge.txt")
    if err != nil {
        fmt.Println("File open error: ", err)
        return
    }

    buf := make([]byte, 1024)
    for {
        n, err := file.Read(buf)
        if n == 0 {
            break
        }
        if err != nil {
            fmt.Println("File read error: ", err)
            return
        }
        fmt.Print(buf[:n])
    }

    file.Close()
}
```

* `defer`が行われた以降の行のどこで`return`しても、必ず`file.Close`が実行

* `defer`はよくリソースの解放に使用される

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("hoge.txt")
    if err != nil {
        fmt.Println("File open error: ", err)
        return
    }
    defer file.Close()   // <- ここでCloseを遅延実行する

    buf := make([]byte, 1024)
    for {
        n, err := file.Read(buf)
        if n == 0 {
            break
        }
        if err != nil {
            fmt.Println("File read error: ", err)
            return
        }
        fmt.Print(buf[:n])
    }

}
```



### deferが実行されないケース

* `os.Exit`関数を使用した場合:`defer`が実行されない

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    defer fmt.Println("A")
    fmt.Println("B")
    os.Exit(0)
}
```

```txt
B
```



## インタフェース

### Go言語におけるポリモーフィズム

インタフェースを用いることでポリモーフィズムを実現可能

* ex:「鳴く」という動作は動物ならばみんなできる動作なので、これをインタフェースに括り出し

> Animalインタフェースを用いて鳴かせる関数を一つにまとめる

```go
package main

import "fmt"

type Animal interface {
    Cry()
}

type Dog struct {}
func (d *Dog) Cry() {
    fmt.Println("わんわん")
}

type Cat struct {}
func (c *Cat) Cry() {
    fmt.Println("にゃーにゃー");
}

func MakeAnimalCry(a Animal) {
    fmt.Println("鳴け！");
    a.Cry();
}

func main() {
    dog := new(Dog)
    cat := new(Cat)
    MakeAnimalCry(dog)
    MakeAnimalCry(cat)
}
```

```txt
鳴け！
わんわん
鳴け！
にゃーにゃー
```



### ダックタイピング

`ダックタイピング`:振る舞いから型を決める仕組み

> Rubyでも使用されている

* `Animal`インタフェースを作成した際、`Dog`構造体や`Cat`構造体には何も変更を加えていない

* 一方、`Dog`や`Cat`は`MakeAnimalCry`関数において「`Animal`インタフェースを実装した」とみなされる



### interface{}型

* `type`キーワードによる型定義

* 「`Animal`」は新しい型名

* `Animal`以降の部分:「`Cry`メソッドを実装したインタフェース」を表す型名

```go
type Animal interface {
    Cry()
}
```

* 「何のメソッドの実装も要求しないインタフェース」を表す型名

* 全てのオブジェクトは`interface{}`型を実装していることになる

  * 「どんな型も引数に取ることができる関数」

  * 「どんな型も返すことができる関数」

```go
interface{}
```

> ex:`fmt.Println`関数はどんな型も引数に取ることができる関数

```go
// Go言語ソースコードより抜粋
func Println(a ...interface{}) (n int, err error) {
	// 省略
}
```



### 型アサーション

* `interface{}`型は何の振る舞いも要求しないため、そのままではメンバメソッドの呼び出しやメンバ変数へのアクセスをすることが出来ない

* `interface{}`型を別の型とみなして扱う必要がある(型アサーション)

```go
package main

import "fmt"

type Animal interface {
    Cry()
}

type Dog struct {}
func (d *Dog) Cry() {
    fmt.Println("わんわん")
}

type Cat struct {}
func (c *Cat) Cry() {
    fmt.Println("にゃーにゃー");
}

func MakeSomeoneCry(someone interface{}) {
    fmt.Println("鳴け！");
    a, ok := someone.(Animal)
    if !ok {
        fmt.Println("動物では無いので鳴けません。")
        return
    }
    a.Cry()
}

func main() {
    dog := new(Dog)
    cat := new(Cat)
    MakeSomeoneCry(dog)
    MakeSomeoneCry(cat)
}
```



## 配列

* 角括弧の後に型を記述

* 長さは宣言時に角括弧内に記述

* 固定なので、後から変更できない

```go
// 配列の宣言方法
// [長さ] 型
[1]byte		// 1バイトのbyte型配列
[10]int		// 10バイトのint型配列
[12]struct {a, b rune}	// 構造体の配列
[2][8]rune	// 2次元配列
```

* `len`関数:配列の長さを取得する

```go
// len関数の書式
長さ = len(配列型変数)
```



### 配列の使用方法

* 配列の要素にアクセス:配列の変数に角括弧を付け、その中にアクセスしたいインデックス番号を指定

* 配列のインデックス:`0`から始まる

```go
package main

import (
	"fmt"
)

func main() {
	// 配列の宣言
	var month [12]string
	month[0] = "January"
	month[1] = "February"
	month[2] = "March"
	month[3] = "April"
	month[4] = "May"
	month[5] = "June"
	month[6] = "July"
	month[7] = "Autust"
	month[8] = "September"
	month[9] = "October"
	month[10] = "Nobember"
	month[11] = "December"

	// 配列の長さの回数、ループして値を表示します。
	for i := 0; i < len(month); i++ {
		fmt.Printf("%d月 = %s\n", i+1, month[i])
	}
}
```

```txt
1月 = January
2月 = February
3月 = March
4月 = April
5月 = May
6月 = June
7月 = July
8月 = Autust
9月 = September
10月 = October
11月 = Nobember
12月 = December
```
* 配列に直接アクセスする場合は、長さを超えたインデックスにアクセスすると、`ランタイムパニック`が発生

```go
var month [12]string
i := 12
month[i] = "Undecimber" // ランタイムエラー
```

```txt
panic: runtime error: index out of range

goroutine 1 [running]:
main.main()
    /home/samples/main.go:23 +0x350
exit status 2
```



### 配列の初期化方法

```go
// 長さ5のint型配列。各要素はすべて0。
arr1 := [5]int64{}
// arr1と同じだが、指定していない要素はすべて0。
arr2 := [5]int64{1, 2, 3}
// 長さに...を指定すると、指定した要素数が長さとして使用される。
arr3 := [...]string{"One", "Two", "Three"}
```



## スライスとは

`スライス`:配列と同様にインデックスを使って要素へアクセスする

* 配列と違うのは、スライスは要素データを参照型で保持

* スライスが持つデータは、配列の一部（または全部）と紐付け、間接的に参照

* 配列を直接扱うよりも、スライス経由の方が利便性が高いため、多くの場合でスライスを使用



### スライスの書式

* 配列と同様に角括弧を使用

* 長さは指定しない

```go
[]型
```



### スライスの使用方法

`スライス式`:角括弧の内にスライスに含める要素の範囲をコロン`:`で区切って記述

* 含められる要素:作成元の配列のインデックスの「下限値（0）」〜「上限値-1（配列の長さ）」まで

* 省略した際は、それぞれ括弧内の数値を指定したことになります。

```go
package main

import (
	"fmt"
)

func main() {
	// スライスの元となる配列を作成
	num := [5]int{1, 2, 3, 4, 5}
	// スライス型変数の宣言
	var slice1 []int

	// 配列全体
	slice1 = num[:]
	fmt.Println(slice1)

	// インデックス1〜4まで
	slice2 := num[1:4]
	fmt.Println(slice2)

	// インデックス4以降
	slice3 := num[4:]
	fmt.Println(slice3)

	// インデックス4以前
	slice4 := num[:4]
	fmt.Println(slice4)
}
```

```txt
[1 2 3 4 5]
[2 3 4]
[5]
[1 2 3 4]
```



### スライスを引数に渡す

* スライスはデータをすべて参照型で保持

* 大規模なデータをスライスに保持しても、メモリを圧迫しない

* 関数の引数として値を受け渡す場合は、常に参照渡し

```go
package main

import (
	"fmt"
)

func main() {
	// スライスの元となる配列を作成
	num := [...]int{1, 2, 3, 4, 5}
	// 配列をスライスとしてを関数に渡す
	plusOne(num[:])

	fmt.Println(num)
}

// 要素内の数字すべてを＋1
func plusOne(vals []int) {
	for i := 0; i < len(vals); i++ {
		vals[i] += 1
	}
}
```

```txt
[2 3 4 5 6]
```



### キャパシティ

* スライスが扱える要素数:長さとして「len」関数で取得可能

* `キャパシティ`:スライスから新たにスライスを作成するときに指定する要素数の最大値

  * キャパシティは、`cap`関数で取得可能

```go
package main

import (
	"fmt"
)

func main() {
	// スライスの元となる配列を作成
	num := [5]int{1, 2, 3, 4, 5}

	// 配列の一部をスライス
	slice1 := num[1:4]
	fmt.Println("slice1=", slice1)
	fmt.Println("len=", len(slice1))
	fmt.Println("cap=", cap(slice1))

	// スライスの一部をスライス
	slice2 := slice1[1:4] // 長さを超過した、キャパシティ最大値まで可能
	fmt.Println("slice2=", slice2)
	fmt.Println("len=", len(slice2))
	fmt.Println("cap=", cap(slice2))

}
```

```txt
slice1= [2 3 4]
len= 3
cap= 4
slice2= [3 4 5]
len= 3
cap= 3
```



### スライスへの追加

* `append`関数:スライスへ要素を追加する

* 追加元には、「スライス」または「要素」を指定

* `append`は戻り値として、追加後のスライスを返す

```go
// appenの書式1
追加後のスライス = append(追加先のスライス, 追加要素1, 追加要素2, ...)// ...は可変長パラメータを意味します。
// appenの書式2
追加後のスライス = append(追加先のスライス, 追加するスライス, ...)
```
