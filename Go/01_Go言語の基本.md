01 Go言語の基本
=============

## 基本的な文法

* Go言語：手続き型言語

* `main`パッケージ内の`main`関数をエントリポイントとして、上から下へ処理が進んでいく



### 文

* 他の多くの言語と同じく、Go言語でも文の終わりはセミコロンで終端

* ただし、殆どのセミコロンは自動補完が働くため、書く必要がない

```go
var a = 2;
```

* 1行に2つ以上の文を書く場合は、行末以外のセミコロンを明示的に書く必要がある

```go
var a = 2; var b = 1
```



### 変数宣言

* 型名を変数名の後ろに置く

```go
var num int
```

* 宣言と同時に初期化を行う場合は、型を省略可能

```go
// 方法1
var result = 1

// 方法2
i := 0
```



### カッコ

* 条件部に丸括弧は必要ない

```go
if a < 5 {}   // OK
if (a < 5) {} // NGではないが冗長
```

* ブロック内が単文の場合でも波括弧が必須

```go
if a < 5 { fmt.Println(a) } // OK
if a < 5 fmt.Println(a)     // ERROR
```



## キーワード

* 以下に挙げる単語はキーワードと呼ばれ、コード内で特別な意味を持つ

* キーワードは、変数・関数などの識別子に使用することは出来ない

|            |               |          |             |          |
| ---------- | ------------- | -------- | ----------- | -------- |
| `break`    | `default`     | `func`   | `interface` | `select` |
| `case`     | `defer`       | `go`     | `map`       | `struct` |
| `chan`     | `else`        | `goto`   | `package`   | `switch` |
| `const`    | `fallthrough` | `if`     | `range`     | `type`   |
| `continue` | `for`         | `import` | `return`    | `var`    |



## Go言語の基本的な型

10個の分類が存在する

* `真偽値型`

* `数値型`

* `文字列型`

* `配列型`

* `スライス型`

* `構造体型`

* `ポインタ型`

* `関数型`

* `マップ型`

* `チャネル型`



### 真偽値型

* 真偽値型に含まれるのは1種のみ

| 型名   | 説明                                        |
| ------ | ------------------------------------------- |
| `bool` | 真（`true`）または偽（`false`）を格納する型 |



### 数値型

#### 符号なし整数

| 型名      | 説明                                                 | 値の範囲                   |
| --------- | ---------------------------------------------------- | -------------------------- |
| `uint8`   | 8ビット符号なし整数型                                | `0`~`255`                  |
| `uint16`  | 16ビット符号なし整数型                               | `0`~`65535`                |
| `uint32`  | 32ビット符号なし整数型                               | `0`~`4294967295`           |
| `uint64`  | 64ビット符号なし整数型                               | `0`~`18446744073709551615` |
| `uint`    | 32ビットまたは64ビットの符号なし整数型               | （環境依存）               |
| `uintptr` | ポインタの値を表現するに十分なサイズの符号なし整数型 | （環境依存）               |



#### 符号付き整数

| 型名    | 説明                                                           | 値の範囲                                      |
| ------- | -------------------------------------------------------------- | --------------------------------------------- |
| `int8`  | 8ビット符号付き整数型                                          | `-128`~`127`                                  |
| `int16` | 16ビット符号付き整数型                                         | `-32768`~`32767`                              |
| `int32` | 32ビット符号付き整数型                                         | `-2147483648`~`2147483647`                    |
| `int64` | 64ビット符号付き整数型                                         | `-9223372036854775808` ~`9223372036854775807` |
| `int`   | 32ビットまたは64ビットの符号付き整数型（サイズはuint型と同じ） | （環境依存）                                  |



#### 浮動小数点数

| 型名      | 説明                               |
| --------- | ---------------------------------- |
| `float32` | IEEE-754形式の32ビット浮動小数点型 |
| `float64` | IEEE-754形式の64ビット浮動小数点型 |



#### 複素数

| 型名         | 説明                                        |
| ------------ | ------------------------------------------- |
| `complex64`  | 実数部・虚数部を`float32`で表現する複素数型 |
| `complex128` | 実数部・虚数部を`float64`で表現する複素数型 |



#### その他

* バイト単位、文字単位のデータを扱う場合の2種類がある

| 型名   | 説明                |
| ------ | ------------------- |
| `byte` | `uint8`のエイリアス |
| `rune` | `int32`のエイリアス |



### 文字列型

| 型名     | 説明               |
| -------- | ------------------ |
| `string` | 文字列を格納する型 |



## 型の宣言

* `type`：新たな型を宣言する

```go
package main

import "fmt"

type Score int

func main() {
    var myScore Score = 100 /* myScore:変数名, Score:変数型 */
    fmt.Printf("私の点数は%d点です。\n", myScore)
}
```

* 型宣言を使うことで、コードが読みやすくなることがある

  * `数値型`や`文字列型`は名前が短い

  * `構造体型`や`関数型`は型名が非常に長く複雑になる傾向

```go
// 型宣言無し
package main

import "fmt"

func main() {
    var readFunc func(struct{name string; meaning string}) string
    var dict struct{name string; meaning string}
    readFunc = readOut
    dict.name = "コーヒー"
    dict.meaning = "コーヒー豆から作られる黒色の飲み物"
    fmt.Println(readFunc(dict))
}

func readOut(s struct{name string; meaning string}) string {
    return fmt.Sprintf("「%s」 は 「%s」 という意味です", s.name, s.meaning)
}
```

```go
package main

import "fmt"

type Dictionary struct {
    name string
    meaning string
}

type ReadFunc func(Dictionary) string

func main() {
    var readFunc ReadFunc
    var dict Dictionary
    readFunc = readOut
    dict.name = "コーヒー"
    dict.meaning = "コーヒー豆から作られる黒色の飲み物"
    fmt.Println(readFunc(dict))
}

func readOut(d Dictionary) string {
    return fmt.Sprintf("「%s」 は 「%s」 という意味です", d.name, d.meaning)
}
```



### 関数のレシーバ型としての使用

* 型宣言によって新たに宣言した型に対して、関数を関連付けることが可能

> 例：自身の値を表示する関数`Show`を`Score`型に関連付ける

```go
type Score int
func (s Score) Show() { fmt.Printf("点数は%d点です\n", s) }
func main() {
    var myScore Score = 100
    myScore.Show()
}
```

>  `Score`型の変数`myScore`：関数`Show`のレシーバ

* 基本型(`int`型など)を関数のレシーバ型に指定することは不可能



## 型の変換

* 型変換を行うには変数を丸括弧で囲み、手前に型名を書きます

```go
package main

import "fmt"

type Score int

func main() {
    var myScore Score = 100
    // showInt(myScore) /* この記述方法は型が異なるので不可 */
    showInt(int(myScore))
}

func showInt(i int) {
    fmt.Printf("value: %d\n", i)
}
```

> `int`型の引数を取る`showInt`関数へ`Score`型の変数`myScore`を渡すため
>
> 関数呼び出しのタイミングで`myScore`を`int`型に変換



## 変数

* 変数の定義：`var 変数名 型名`

* 定義した変数には、`=`演算子を使用して自由に値を代入

```go
package main

import "fmt"

func main() {
  var name string
  name = "Mr. Go"
  fmt.Println("Hello,", name)  
}
```

* 宣言と初期化を同時に行う場合は、型名を省略することが可能

```go
package main

import "fmt"

func main() {
  var name = "Mr. Go"
  fmt.Println("Hello,", name)
}
```

* **関数内に限り**、`:=`演算子を使用して代入を行うことで、`var`キーワードも省略が可能

```go
package main

import "fmt"

func main() {
  name := "Mr. Go"
  fmt.Println("Hello,", name)
}
```



## 定数

* `const`キーワードを使用することで、定数を定義することが可能

* 定数は定義と同時に必ず初期化を行う

* 変数と違い、定数の定義後に値を代入することは不可能

* 定数の定義は関数内・関数外問わず行うことが可能

  * 関数内で定義した場合、その定数は定義した関数内でのみ有効

```go
package main

import "fmt"

func main() {
  const title = "Go言語入門"
  fmt.Println(title);
}
```



## リテラル

Go言語では5種類のリテラルを使用することが可能



### 整数リテラル

* 8進数:先頭に`0`を付ける

* 16進数:先頭に`0x`もしくは`0X`を付ける

```go
package main

import "fmt"

func main() {
  fmt.Println(1234);
  fmt.Println(053); // 8進数の43
  fmt.Println(0xA3); // 16進数のA3(163)
  fmt.Println(0XA3); // 16進数はこの記述方法でも可能
}
```



### 浮動小数点数リテラル

* 浮動小数点型は10進数のみ使用可能

* 小数部・整数部のいずれか一方のみ、0の場合は省略可能

* 指数表記を利用可能

```go
package main

import "fmt"

func main() {
  fmt.Println(3.1415);
  fmt.Println(.25); // 0.25
  fmt.Println(12.); // 12.0
  fmt.Println(1.25e-3); // 0.00125の指数表記
}
```



### 虚数リテラル

* 10進数の整数または浮動小数点数の後ろに、`i`を付けることで表現

* `1i`を表現するのに、`1`を省略して`i`とすることは不可能

```go
package main

import "fmt"

func main() {
  fmt.Println(2i); // (0+2i)
  fmt.Println(3.1415i); // (0+3.1415i)
  fmt.Println(1.25e-3i); // (0+0.00125i)
}
```



### ルーンリテラル

* `ルーン`(Rune):`Unicode`のコードポイントを表現する整数

* `ルーンリテラル`:ルーン1つを表現するリテラル

```go
package main

import "fmt"

func main() {
  fmt.Println('a'); // 97
  fmt.Println('あ'); // 12354
  fmt.Println('\n'); // 10
  fmt.Println('\u12AB'); // 4779
}
```



### 文字列リテラル

文字列リテラルには2種類の表現方法がある



### raw文字列リテラル

* raw文字列リテラル:バッククォートで囲まれた文字列

* エスケープシーケンス・コードポイントも評価されず、書かれたそのままを文字列として扱う

* 制御文字を含めることが可能で、改行もそのまま扱われる

* リテラル内でバッククォートを使用することは不可能

```go
package main

import "fmt"

func main() {
  fmt.Println(`abc`);
  fmt.Println(`\n`); // 改行ではなく\とnの二文字として扱われる。
  fmt.Println(`ab
cd`); // 前の行と合わせて、改行を含む1つの文字列として扱われる。
}
```



### interpreted文字列リテラル

* interpreted文字列リテラル:ダブルクォート`""`で囲まれた文字列

* エスケープシーケンスや、Unicodeコードポイントが評価される

```go

package main

import "fmt"

func main() {
  fmt.Println("abc");
  fmt.Println("ab\ncd"); // abとcdの間に改行が挿入される
  fmt.Println("\u3042\u3044\u3046"); // 「あいう」のコードポイント表記
}
```
