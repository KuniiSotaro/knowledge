07 ハッシュ
==========

## 目次

* [ハッシュとは](#ハッシュとは)

* [ハッシュリテラル](#3-7-1.ハッシュリテラル)

* [ハッシュ引数](#3-7-2.ハッシュ引数)



## ハッシュとは

* 複数の値から構成される`配列`に、各値に名前をつけて管理するもの



## 3-7-1.ハッシュリテラル

* 両側を波カッコ`{}`で囲む

* `キー`と`値`の組を、`キー => 値`として区切る

* 添字演算子で指定することで値を操作する

* 存在しないキーを指定すると、デフォルトで`nil`が返る

```ruby
>> a = { "foo1" => 1, "foo2" => 2, "foo3" => 3 }
=> {"foo1"=>1, "foo2"=>2, "foo3"=>3}
>> a["foo1"]
=> 1
>> a["foo2"]
=> 2
>> p a
{"foo1"=>1, "foo2"=>2, "foo3"=>3}
=> {"foo1"=>1, "foo2"=>2, "foo3"=>3}

# 存在しないキーの指定
>> a = {}
=> {}
>> a[:foo1]
=> nil
```



### ハッシュの`キー`について

* `キー`には任意のオブジェクトを指定することができる

* Rubyインタプリタは、添字演算子で指定された`キー`から、ハッシュが保持する`キー`について次の項目を確認

  * 両者の`hash`メソッドの結果が等しいか

  * `eql?`メソッドで比較した結果が真となるか

* 文字列を`キー`とする場合は、 **シンボル** を使用する方が処理が高速になる



### キーに`シンボル`を用いたハッシュ

* キーには`シンボル`を用いて記述することができる

* Ruby1.9以降では、ハッシュリテラルの記法が`:`で区切ることができる

  > ただし、文字列のキーを使用する際は`=>`を使用

```ruby
# シンボルを用いたハッシュ
>> a = {:foo1 => 1, :foo2 => 2, :foo3 => 3}
=> {:foo1=>1, :foo2=>2, :foo3=>3}
>> a[:foo1]
=> 1

# シンボルを用いたハッシュは`:`で区切ることも可能
>> a = {foo1: 1, foo2: 2, foo3: 3}
=> {:foo1=>1, :foo2=>2, :foo3=>3}
>> a[:foo1]
=> 1
```



### ハッシュを生成する方法

* 存在しないキーを指定した場合の返り値(`nil`)は、`Hash`のインスタンスを作成することで変更

  > デフォルト値を決める場合に便利

* `Hash`のクラスメソッド`[]`を使用することで生成

* `Array#to_h`を使用して生成(`Array`クラスからできたオブジェクトのうち、二次元配列のもののみ)

```ruby
# Hashのインスタンスを作成
>> a = Hash.new(5)
=> {}
>> a[:foo1]
=> 5

# Hashのクラスメソッドを使用
>> a = Hash[:foo1, 1, :foo2, 2, :foo3, 3]
=> {:foo1=>1, :foo2=>2, :foo3=>3}

# Array#to_hを使用
>> a = [[:foo1, 1], [:foo2, 2], [:foo3, 3]].to_h
=> {:foo1=>1, :foo2=>2, :foo3=>3}
```



## 3-7-2.ハッシュ引数

* 実引数の最後にハッシュを指定する場合は、その両側の波カッコ`{}`を省略可能

* 最後の引数のみ有効になる

```ruby
>> def foo a, b, c
>>   c
>> end
=> :foo
>> foo(1, 2, :foo=>1, :foo2=>2)      # 両側の波カッコ`{}を省略したもの`
=> {:foo=>1, :foo2=>2}
>> foo(1, 2, {:foo1=>1, :foo2=>2})   # 省略しない場合
=> {:foo1=>1, :foo2=>2}
```



| 版     | 年/月/日   |
| ------ | ---------- |
| 第二版 | 2019/05/11 |
