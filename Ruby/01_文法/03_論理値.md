03 論理値
========

## 目次

* [論理値とは](#論理値とは)

* [条件分岐](#3-3-1.条件分岐)

* [擬似変数](#3-3-2.擬似変数)

* [論理演算子](#3-3-3.論理演算子)



## 論理値とは

* 論理値には、`true`と`false`の２つがある

* それぞれのクラスは、以下のようになっている

  * `true`：`TrueClass`クラスのインスタンス

  * `false`：`FalseClass`クラスのインスタンス

> ただし、Rubyでは **`true`は真の代表値であり、`false`と`nil`以外のオブジェクトは全て`真`と見なされる**



## 3-3-1.条件分岐

### if文

```ruby
if <条件式> then
end
```

例)

```ruby
>> if true then
?>  p 1
>> end
1
=> 1
```



### if式を評価した値

* if文：`文`ではなく、`式`

  * 評価すると`値`が返る

  > `評価値`は、if式の中で **最後に評価された値**

* 応用例：何らかの条件が成立する場合に`値`を代入する

```ruby
>> a = if true
>> 1
>> end
=> 1
>> p 1
1
=> 1
```

* また、`if修飾子`(`真の時に実行する式 if 条件式`)のような構文も記述可能

```ruby
>> a = 1 if true
=> 1
>> p a
1
=> 1
>> a = 2 if false
=> nil
>> p a
1
=> 1
```



### 条件が成立しない場合の変数宣言

* 変数の宣言(初出の変数への値の代入)とif式を組み合わせた場合に、**判定結果に関わらず、変数自体は確保** される。

> ### 理由
>
> * Rubyインタプリタは、`初出の変数への代入`を検出済み
>
> * 条件が成立しない場合にスキップされるのは、`値の代入`
>
> `if文`の条件が不成立でも、後からその変数を参照できる。
>
> →`未宣言の変数`との違いが重要！

```ruby
>> b = 3 if false   # 変数b(値：nil)が確保
=> nil
>> p b
nil
=> nil
>> p c              # 変数cは未定義→例外発生
NameError: undefined local variable or method ｀c｀ for main:Object
```



### `then`節と`elsif`節

* `else節`：条件が成立しない場合の処理を記述する方法

* `elsif節`：さらに条件を指定する場合(Rubyのみの記法)

```ruby
>> a = if false then
?>   1
>> elsif false
>>   2
>> else
?>   3     # 値はtrueなので
>> end
=> 3
>> p a
3
=> 3
```



### `unless式`

* 条件が成立しない場合の処理を先に記述する際に使用

> * `if式`と同様に、修飾子として使用
>
> * `else節`などを指定する
>
> * 結果的に、コードの可読性が向上する
>
> * ただし、`elsif`は指定できない(Silverで間違えた！！)

```ruby
>> unless false
>> p 1
>> end
1
=> 1
```



### 条件演算子(三項演算子)

```ruby
条件式 ? 式1 : 式2
```

* 条件式を評価し、以下のように値を返す

  * 成立する場合は、`式1`

  * 成立しない場合は、`式2`

```ruby
>> a = true ? 1 : 2
=> 1
```



## 3-3-2.擬似変数

* `nil`と`true`と`false`の3種類は、 **擬似変数** と呼ばれるもの。

* 擬似変数は、代入することができない。

```ruby
>> true = 1
SyntaxError: (irb):13: Can t assign to true
```



### 擬似変数の種類

* `true`：`TrueClass`クラスのインスタンス

* `false`：`FalseClass`クラスのインスタンス

* `nil`：`NilClass`クラスのインスタンス

* `self`：現在のオブジェクト

* `__FILE__`：現在実行しているプログラムのファイル名

* `__LINE__`：現在実行しているプログラムの行番号

* `__ENCODING__`：現在のソースファイルのスクリプトエンコーディング



### 擬似変数の働き

* Rubyは、**`nil`と`false`のみが、`偽`を表す**

* それ以外の値は、**全て`真`を表す**

```ruby
>> a = 10
=> 10
>> if a then; a; end      # 変数`a`は10・・・`false`と`nil`以外なので、`真`
=> 10
>> @a                     # 変数`@a`はnil・・・未定義なので`偽`
=> nil
>> if @a then; 1; end     # 変数`@a`は不成立・・・変数`@a`は`偽`のため
=> nil
```

* インスタンス変数に値が入っているかどうかの判定は、`変数`を評価(参照)することで行うことが可能

  →`nil`と比較する必要がない

> `nil`：何もないことを表現する。他言語でいう、`null`



## 3-3-3.論理演算子

* `&&`：論理積(且つ)

* `||`：論理和(または)

* `!`：否定(ではない)

```ruby
>> if true && true; 1; end    # `true`且つ`true`なら、真
=> 1
>> if nil && 10; 1; end       # `nil`且つ`10`なら、真・・・存在しないので、`nil`
=> nil
>> if false || true; 1; end   # `false`または`true`なら、真
=> 1
>> if nil || false; 1; end    # `nil`または`false`なら、真・・・`nil`と`false`以外は`真`なので、`nil`
=> nil
>> if !true; 1; end           # `true`でなければ真・・・`nil`と`false`以外は`真`なので、`nil`
=> nil
```



### 論理演算子を適用した式の評価値

* 論理演算子では、左辺で式の結果が確定する場合は、**右辺を評価しない**

* 式の評価値は、最後に評価したオペランド

```ruby
>> a = nil && 1   # 右辺は`1`だが、評価されない
=> nil
>> a = 1 || 2     # 右辺は`2`だが、評価されない
=> 1
```

* 応用例

```ruby
>> b = b || 1    # bが初期化されていない場合(nil)に、`1`を格納
=> 1
>> c ||= 1       # cが初期化されていない場合(nil)に、`1`を格納・・・自己代入演算子
=> 1
```

論理演算子の評価方法について、

* `&&`演算子：左辺が真と評価されたときのみ右辺も評価されます。

  > 両方真である必要があるのに、左辺の時点で偽なら次の処理へ移動

* `||`演算子：右辺が評価されるのは、左辺が偽と評価された場合です。

  > 左辺が偽でも、右辺で真なら条件は真になる

```ruby
ary = []
ary << 1 && false
true || ary << 2
false && ary << 3
false || ary << 4
p ary

# 解答
>> ary = []
=> []
>> ary << 1 && false # ary << 1と、falseが両方真かどうかの条件なので、aryには値が保存される
=> false
>> true || ary << 2  # 左辺がtrueなので、右辺は処理しない
=> true
>> false && ary << 3 # 左辺がfalseなので、処理しない
=> false
>> false || ary << 4
=> [1, 4]
>> p ary
[1, 4]
=> [1, 4]
```



> ### オペランド
>
> 式を構成する要素のうち、演算子じゃない方の要素
>
> →式に登場する数値、変数

例) 1+2なら、

* 1、2：オペランド

* +：演算子



### 優先順位が低い`and`、`or`、`not`

* `and`：論理積`&&`

* `or`：論理和`||`

* `not`：否定`!`


> 一方で、自己代入することができず、代入演算子よりも演算子の優先度が低い

```ruby
>> p 1 && 2      # p (1 && 2)と同義・・・論理積の結果がpに渡される
2                # 2が出力
=> 2
>> p 1 and 2     # (p 1) and 2と同義・・・pの実行結果と2の論理積が渡される
1                # 1が出力
=> 2
>> p (1 and 2)   # &&と同じ結果を出力
2
=> 2
```



| 版     | 年/月/日   |
| ------ | ---------- |
| 第二版 | 2019/05/11 |
