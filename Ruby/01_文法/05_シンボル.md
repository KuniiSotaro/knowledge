05 シンボル
==========

## 目次

* [シンボルリテラル](#1シンボルリテラル)

* [オブジェクトの同値性と同一性](#2オブジェクトの同値性と同一性)

* [変数と値](#3変数と値)



## 1.シンボルリテラル

* 文字列の先頭に **コロン`:`** を付加する

* 文字列の囲み文字(ダブルクオートなど)を省略する

```ruby
>> foo1 = :"foo1"            # ダブルクオートを指定した場合
=> :foo1
>> foo2 = :"#{foo1}foo2"     # 式展開を利用した場合
=> :foo1foo2
>> foo3 = :'foo3'            # シングルクオートを使用した場合
=> :foo3
>> foo4 = :foo4              # 囲み文字を省略した場合
=> :foo4
```



### パーセント記法を用いたシンボルの指定

```ruby
>> %s?foo1?     # `%s`でシンボル
=> :foo1
>> %s[foo2]     # `%s`でシンボル
=> :foo2
```



### 文字列とシンボルの変換

* 文字列と違って、加算(+メソッド)が用意されていない

* 一度文字列に変換してから、シンボルに変換する

```ruby
>> v1 = "foo1"
=> "foo1"
>> v2 = v1.to_sym
=> :foo1
>> v3 = v2.to_s
=> "foo1"
```



## 2.オブジェクトの同値性と同一性

* 文字列リテラル：文字の並びが同一でも、指定するごとに新たなStringオブジェクトが生成

* シンボルリテラル：文字列の並びが同一なら、同一のオブジェクトを参照する



### `object-id`

* リテラル型に対応するクラスのインスタンス(オブジェクト)に割り振られるID

* Rubyの処理系では、シンボルは内部で整数として扱う

* 文字列よりもシンボルの方が効率よく処理

> 処理が早いため

```ruby
>> p "foo1".object_id   # 1回目のオブジェクト生成(文字列リテラル)
70247164007560
=> 70247164007560
>> p "foo1".object_id   # 2回目のオブジェクト生成(文字列リテラル)
70247163993640
=> 70247163993640
>> p :foo1.object_id    # 1回目のオブジェクト生成(シンボルリテラル)
1159388
=> 1159388
>> p :foo1.object_id    # 2回目のオブジェクト生成(シンボルリテラル)
1159388
=> 1159388
```



### オブジェクトの同値性と同一性の判定

* `equal?`メソッド：2つのオブジェクトが同一かどうかを論理値で返す。(サブクラスでオーバーライドしない)

* `==`：等価演算子。2つのオブジェクトが等しいかどうかを判定。(多くのクラスでオーバーライド)

* `eql?`メソッド：型の比較を行う。値が等しくても`false`を返すことがある。

```ruby
# 文字列
>> "foo1" == "foo1"
=> true
>> "foo1".equal? "foo1"
=> false

# シンボル
>> :foo1 == :foo1
=> true
>> :foo1.equal? :foo1
=> true

# eql?メソッド
>> "foo1".eql? "foo1"   # 文字型
=> true
>> 1.0 == 1             # 整数型と浮動小数点型だが、同じ数値
=> true
>> (1.0).eql? 1         # 整数型と浮動小数点型は型が異なるため、false
=> false
>> (1.0).eql? 1.0       # 型も値も同じため、true
=> true
```



## 3.変数と値

> 時間があるときにまとめる**



| 版     | 年/月/日   |
| ------ | ---------- |
| 第二版 | 2019/05/11 |
