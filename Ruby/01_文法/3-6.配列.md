3-6.配列
=======

## 3-6-1.配列リテラル

* `Arrayクラス`のインスタンス

* 要素を`[]`で囲み、要素の間をカンマ`,`で区切ることで生成

* 配列の各要素に異なった形の値を指定可能

```ruby
>> a = []
=> []
>> b = [10, true, "30"]
=> [10, true, "30"]
>> b[0]
=> 10
```

***

### 二次元配列の例

配列自体は１つの値なので、`配列`を配列の要素として指定可能

→行列のように表現できる

```ruby
>> a = [[1, 2], [3, 4]]
=> [[1, 2], [3, 4]]
>> a[0][0]
=> 1
>> a[1][1]
=> 4
```

***

### パーセント記法による配列の生成

* コード中にダブルクオートやカンマが少なくなり、プログラム自体がスッキリする

* `join`メソッド(配列の要素を連結して文字列を生成)で便利

* `%W`ではダブルクオート文字列、`%w`ではシングルクオート文字列。

* 要素間は空白で区切って記述する

```ruby
>> v1 = %w[hoge foo bar]      # 配列の生成
=> ["hoge", "foo", "bar"]
>> v1.join                    # 配列の要素を連結
=> "hogefoobar"
>> v1.join("_")               # 配列の要素をアンダースコア`_`で連結
=> "hoge_foo_bar"
```

### インスタンスの生成による配列の生成

* `Arrayクラス`のインスタンスを生成することで、配列を生成

* 初期値は、 **第2引数** や **ブロック** で指定可能

```ruby
>> a = Array.new(5)                     # コンストラクタに`5`を指定
=> [nil, nil, nil, nil, nil]
>> a.length                             # 生成した配列からサイズを参照
=> 5
>> Array.new(2){|index| index + 10}     # 初期値をブロックで指定
=> [10, 11]
```

ただし、 **第2引数** で指定した初期値オブジェクトは、全て同一のオブジェクト

```ruby
>> a = Array.new(2, "a")     # a[0]とa[1]は同一のオブジェクト
=> ["a", "a"]
>> a[0].replace("b")         # a[0]とa[1]の両方がreplaceされる
=> "b"
>> p a                       # ["b", "a"]とはならない
["b", "b"]
=> ["b", "b"]
```

これを避けるためには、 **ブロック** で初期値を指定する

```ruby
>> a = Array.new(2){"a"}     # 変数aを配列と定義して、引数に"a"を二個入れる
=> ["a", "a"]
>> a[0].replace("b")         # ブロックのスコープを抜けているので、ここの処理は別に行われる
=> "b"
>> p a
["b", "a"]
=> ["b", "a"]
```

***

### サイズを超えた要素への代入

配列のサイズは、要素への代入によって変わる。

上限を超えた際には、`nil`を返す

```ruby
>> v1 = [10]
=> [10]
>> v1.length
=> 1
>> v1[3] = "aa"
=> "aa"
>> v1.length
=> 4
>> v1[2]          # 配列で初期化されていない
=> nil
>> v1[100]        # 配列の上限は3なのでnil
=> nil
```

***

## 3-6-2.添字演算子

* 添字は、末尾の要素を`-1`として、先頭に向けて順に減っていく・・・Silverで間違えている！！

* 配列のサイズ+指定された負の整数=実際のインデックス

```ruby
>> v1 = [10, nil, nil, "aa"]
=> [10, nil, nil, "aa"]
>> p v1[-1]                   # 配列の長さ：4、4-1=3なので3番目を返す
"aa"
=> "aa"
>> p v1[4-1]                  # 4-1=3なので3番目を返す
"aa"
=> "aa"
>> p v1[-4]                   # 配列の長さ：4、4-4=0なので0番目を返す
10
=> 10
>> p v1[4-4]                  # 4-4=0なので0番目を返す
10
=> 10
```

***

### 要素数を指定された要素の参照

添字に2つの整数を指定すると、

* 最初の添字：操作対象のインデックス

* 次の添字：そこからの要素数

```ruby
>> a = [0, 1, 2, 3, 4, 5]
=> [0, 1, 2, 3, 4, 5]
>> a[2, 3]                 # 配列aの最初のインデックスは2、そこから3個の要素を返す
=> [2, 3, 4]
```

***

### 要素数を指定した代入

要素数を指定した上で代入することで、その部分が指定された値に置き換わる

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a"     # 配列aのインデックス1から2つの要素を"a"に置換
=> "a"
>> p a
[0, "a", 3]
=> [0, "a", 3]
```

***

### 要素数を指定して配列・複数の式を代入

要素数を指定して代入する場合は、複数の値を指定することができる

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = ["a", "b"]
=> ["a", "b"]
>> p a
[0, "a", "b", 3]
=> [0, "a", "b", 3]
```

代入する値のかっこは、省略することができる

→厳密には、複数の式の代入

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a", "b"
=> ["a", "b"]
>> p a
[0, "a", "b", 3]
=> [0, "a", "b", 3]
```

***

### 指定数以上の個数の値の代入

代入する値の個数の方が多いと、余った値が要素に挿入される

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a", "b", "c"   # a[2]から2つの要素なので、余った"c"は要素に追加
=> ["a", "b", "c"]
>> p a
[0, "a", "b", "c", 3]
=> [0, "a", "b", "c", 3]
```

***

## 3-6-3.多重代入と可変長引数

```ruby
>> a, b, c = 1, 2, 3
=> [1, 2, 3]          # メソッドの返り値で複数の値(配列)を返す
>> p a
1
=> 1
>> p b
2
=> 2
>> p c
3
=> 3
```

***

### 返り値に複数の値を指定

```ruby
>> def foo
>>   return 1, 2, 3     # 明示的に`return`を指定する必要がある
>> end
=> :foo
>> a, b, c = foo
=> [1, 2, 3]
>> p a
1
=> 1
>> p b
2
=> 2
>> p c
3
=> 3
```

***

### 配列による多重代入

* 変数を`カッコ`で囲むことで、対応する配列を指定

```ruby
>> a, b, c = [1, 2, 3]     # a, b, c = 1, 2, 3 と結果は同じ
=> [1, 2, 3]
>> (a, b), c = [1, 2], 3   # 配列の中に配列が入る
=> [[1, 2], 3]
```

***

### 多重代入の注意点

* 変数に対して代入する値の個数が足りない場合は、余った整数に`nil`が格納

* 変数よりも値の個数が多い場合は、値が左から順に代入され、余った値は無視される

* １つの変数に複数の値を代入した場合は、配列の代入になる

* 代入する値の個数が多く、余った値を無視したくない場合は、最後の変数名に`*`をつける

  結果として、指定した変数に余った値が配列としてまとめて代入される。

```ruby
# 多重代入で値の個数が足りない場合
>> a, b, c = 1, 2
=> [1, 2]
>> p a
1
=> 1
>> p b
2
=> 2
>> p c      # 余った値は無視される
nil
=> nil

# 多重代入で値の個数が多い場合
>> a, b = 1, 2, 3
=> [1, 2, 3]
>> p a
1
=> 1
>> p b
2
=> 2

# １つの変数に複数の値を代入
>> a = 1, 2     # 配列の代入になる
=> [1, 2]
>> p a
[1, 2]
=> [1, 2]

# 最後の変数に配列で代入
>> a, *b = 1, 2, 3
=> [1, 2, 3]
>> p a
1
=> 1
>> p b       # 2, 3は配列[2, 3]として代入
[2, 3]
=> [2, 3]
```

* 多重代入は変数の交換する際にもよく用いられる

```ruby
>> a = 'a'
=> "a"
>> b = 'b'
=> "b"

>> a, b = b, a
=> ["b", "a"]

>> a
=> "b"
>> b
=> "a"
```

***

### 可変長引数

* `*`の指定は、仮引数でも可能(**可変長引数**)

* 実引数に`*`を付けることで、配列を引数に展開することができる

  →可変長引数を他のメソッドに渡す場合などに使用

* 可変長引数は、1個のみしか指定できない(Silverで間違えている！！)

```ruby
# 可変長引数
>> def foo a, *b
>>   b
>> end
=> :foo
>> foo(1, 2, 3)    # 余った引数がまとめて`*b`に入る
=> [2, 3]

# 引数展開
>> def foo1 a, *b  # foo1の実行によって、仮引数bに配列[2, 3]が格納
>>   foo2(*b)
>> end
=> :foo1
>> def foo2 c, *d  # 配列[2, 3]を実引数としてfoo2に渡す
>>   d             # 仮引数dに3のみで構成される配列[3]が格納
>> end
=> :foo2
>> foo1(1, 2, 3)
=> [3]
```

例)
```ruby
>> def bar(n1, *n2, n3)
>>   puts "n1: #{n1}, n2: #{n2}, n3: #{n3}" # n1: 5, n2: [6, 7], n3: 8
>> end
=> :bar
>> bar 5, 6, 7, 8
n1: 5, n2: [6, 7], n3: 8
=> nil
```

***

## 3-6-4.配列の演算

### Arrayクラスの二項演算子

* `&`演算子：数値では、ビット演算子となり論理値を返す

  →配列では、両方に含まれる要素から構成される配列が返る

* `|`演算子：集合の和演算子になる

  →配列では、どちらかに含まれる要素から構成される配列が返る

* ただし、これらの結果は同値のものは排除される(`eql?`メソッドで同値判定)

```ruby
>> a = [1, 1, 2, 3]
=> [1, 1, 2, 3]
>> b = [2, 2, 3, 3]
=> [2, 2, 3, 3]
>> a & b             # aとbの配列では、2と3は両方が含まれる
=> [2, 3]
>> a | b             # aとbの配列では、1と2と3が和集合
=> [1, 2, 3]
```

***

* `+`演算子：要素を繋げた配列を返す

* `-`演算子：対象の要素を取り除いた配列を返す
  →右オペランドで指定された要素は、例え左オペランドにない要素でも取り除かれる(Slverで間違えた！！)

```ruby
>> a = [1, 1, 2, 2]
=> [1, 1, 2, 2]
>> b = [2, 2, 3, 4]
=> [2, 2, 3, 4]
>> a + b
=> [1, 1, 2, 2, 2, 2, 3, 4]
>> a - b                       # 右オペランドで指定された要素が全て取り除かれる
=> [1, 1]
```

***

* `*`演算子：

  * 数値：その数だけ連結した配列を返す

  * 文字列：その文字を区切りとして要素を連結(`join`メソッドと同じ)

```ruby
>> [1, 2] * 3            # 配列[1, 2]を三回繰り返す
=> [1, 2, 1, 2, 1, 2]
>> [1, 2, 3] * "-"       # 配列の区切りは"-"
=> "1-2-3"
>> [1, 2, 3].join("-")   # 同様
=> "1-2-3"
```

***

## 3-6-5.`for式`

* 指定された式の範囲を繰り返し実行

  →構文中の`do`は省略可能

* 識別子は、複数指定することができる

```ruby
# for式の構文
for <識別子> in <式> do
    <出力内容>
end

# 実際の例
>> a = [2, 3, 4]
=> [2, 3, 4]
>> for i in a do
?>   p i
>> end
2
3
4
=> [2, 3, 4]

>> for i,j in [[1, 2], [3, 4]]  # 複数指定した識別子
>>   p i + j
>> end
3
7
=> [[1, 2], [3, 4]]
```

***

### スコープを作るものと作らないもの

* `for式`：スコープが作成されない。内部で初期化した変数は、その後のコードから参照可能

* `eachメソッド`：スコープが作成される。内部で初期化された変数は、外部で参照できない。

```ruby
# for式
>> for i in [2, 3, 4]  # for式の内部で変数barに繰り返し1を代入。(グローバル変数化)
>>  bar = 1
>> end
=> [2, 3, 4]
>> p bar               # 外部から参照可能
1
=> 1

# eachメソッド
>> [2, 3, 4].each do   # eachメソッドのブロックで、スコープが作成
?>  bar = 1
>> end
=> [2, 3, 4]
>> p bar               # 外部から参照不可
NameError: undefined local variable or method ｀bar｀ for main:Object
```
