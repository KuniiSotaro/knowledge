03 文字列型を使いこなす
====================

## 文字列の置換と削除

* `replace()`：文字列オブジェクトが持つメソッド

  * 文字列の一部を別の文字に置き換え、置換することができる

```python
>>> orig_str = "いっぱい"
>>> orig_str.replace("い", "お")
'おっぱお'
```

* `replace()`メソッドを呼ぶと、文字列を置換した結果が新しい文字列となって返ってくる

* メソッド呼び出しに使った文字列オブジェクトは変更されない

  => 文字列は変更不可能なデータ型

* `replace()`メソッドは、文字の削除にも使える

  => 2番目の引数に、`空の文字列`を渡す

```python
>>> orig_str = "いっぱい"
>>> orig_str.replace("い", "")
'っぱ'
```

* 例)3桁ごとにカンマの入った整数相当の文字列を数値と扱う

  => 事前に`replace()`メソッドで不要な文字列を削除し、`int()`関数で数値に変換する

```python
>>> str_num = "1,000,000"
>>> num = int(str_num.replace(",", ""))
>>> num
1000000
```



## split()メソッドとjoin()メソッド

* `split()`：文字列を特定の文字を目安にして分割できる

  * タブやスペースのような空白文字列やカンマで分割された長い文字列を、細かい文字列に分割する時に便利

  * 分割に利用する`区切り文字列`を引数として渡して、結果を文字列のリストとして返す

```python
>>> str_speeds = "38 42 20 40 39"
>>> speeds = str_speeds.split(" ")
>>> speeds
['38', '42', '20', '40', '39']
```

* `join()`：文字列を要素として持つリストを引数にとって、リストの文字列を連結した文字列を得ることができる(`split()`の逆)

  => 連結文字列を対象にした操作(文字列のリテラルからメソッドを呼び出す)

```python
>>> str_speeds = "38 42 20 40 39"
>>> speeds = str_speeds.split()
>>> csep_speeds = ",".join(speeds)
>>> csep_speeds
'38,42,20,40,39'
```

* 空白をカンマに置き換えるだけならば、文字列型の`replace()`メソッドを使って

  ```python
  >>> str_speeds.replace(" ", "")
  '3842204039'
  ```

  のように書ける

* `split()`メソッドは、分割しようとする文字列の前後に不要な空白があったり、間のスペースが複数であっても、上手に要素を分割する

```python
# 余分な空白を削除する
>>> str_speeds2 = " 38  42 20 40 39 "
>>> str_speeds2.replace(" ", ",")
',38,,42,20,40,39,'

# 分割してから余分な空白を削除する
>>> str_speeds2 = " 38  42 20 40 39 "
>>> speeds2 = str_speeds2.split()
>>> csep_speeds2 = ",".join(speeds2)
>>> csep_speeds2
'38,42,20,40,39'
```



## エスケープシーケンス

* Pythonでは、引用符(「`"`」または「`'`」)を3つ重ねると、改行を含んだ文字列を定義できる

* しかし、インデントしたブロックの中で改行を含んだ文字列を変数として定義する場合など、インデントが見え辛くなる

```python
>>> def func():
...   words = """ゆく河の流れは絶えずして
... しかも元の水にあらず"""
...   print(words)
...

>>> func()
ゆく河の流れは絶えずして
しかも元の水にあらず
```

* 上記の場合、改行後の文字の先頭にインデントを入れてしまうと、その部分も文字列の一部として解釈される

  => エスケープシーケンスの`\n`を使えば、改行を含む文字を1行で記述でき、インデントの崩れを防ぐことができる

```python

>>> def func():
...   words = "ゆく河の流れは絶えずして\nしかも元の水にあらず"
...   print(words)
...

>>> func()
ゆく河の流れは絶えずして
しかも元の水にあらず
```

* エスケープシーケンスは、改行やタブなどのようなコントロールコードを埋め込むためのものだが、

  * ダブルクオーテーション("")で囲まれた文字列にダブルクオーテーションを埋め込みたい場合

  * ASCII文字やユニコード文字を埋め込む場合

  にも利用できる

* 以下、エスケープシーケンスの一覧

|エスケープシーケンス|                         説明                          |
|:---------------|:------------------------------------------------------|
|`\n`            |改行                                                   |
|`\r`            |改行(CR、キャリッジ・リターン)                             |
|`\t`            |水平タブ                                                |
|`\'`            |シングルクオーテーション                                   |
|`\"`            |ダブルクオーテーション                                     |
|`\\`            |バックスラッシュ                                          |
|`\x61`          |16進数に対応する8ビット文字                                |
|`\u3042`        |16ビット16進数に対応するUnicode文字、16進数部分には「0x」は不要|
|`\0`            |Null文字                                                |



## raw文字列

* `raw文字列`：バックスラッシュを含め、文字をそのままリテラルとして扱う文字列

  * 入力した文字そのままの文字列を定義できる

  * エスケープシーケンスはコントロールコードなどに変換されず、そのまま文字として扱われる

* raw文字列を定義するには、引用符の前に「`r`」を添える

```python
>>> raw = r"C:\path\to\file"
>>> raw
'C:\\path\\to\\file'
```



## 文字列で利用できるメソッド

* `find()`：文字列Sの先頭から、「検索したい文字列」を探し、最初に見つかった位置を0から始まるインデックスとして返す

  * 見つからなかった場合は、「`-1`」を返す

  * オプションの引数を与えて、検索をする範囲を指定することもできる

  * 文字列の先頭から検索を行うが、`rfind()`メソッドでは文字列の末尾(右)から検索する

```python
S.find(検索したい文字列[, 開始インデックス[, 終了インデックス]])
```

* `index()`：`find()`メソッドと同じように動作するが、「検索したい文字列」が見つからなかった場合には、「ValueError」という例外を発生する

  * `rfind()`に相当する`rindex()`というメソッドを使うと、文字列を末尾(右)から検索できる

```python
S.index(検索したい文字列[, 開始インデックス[, 終了インデックス]])
```

* `endswith()`：文字列Sが「検索したい文字列」で終わっている時にTrue(真)を返す

  * そうでない場合は、False(偽)を返す

  * オプションで与える引数によって、検索をする範囲を指定できる

```python
S.endswith(検索したい文字列[, 開始インデックス[, 終了インデックス]])
```

* `startswith()`：文字列Sが「検索したい文字列」で始まっている時にTrue(真)を返す

  * そうでない場合は、False(偽)を返す

  * オプションで与える引数によって、検索をする範囲を指定できる

```python
S.startswith(検索したい文字列[, 開始インデックス[, 終了インデックス]])
```

* `split()`：文字列Sを、「区切り文字列」で区切り、文字列のリストを作って返す

  * リストの文字列からは、区切り文字列を除去する

  * オプションの分割数を指定しないと、文字列の末尾まで分割を行う

    => 指定すると、分割を行う数を制限できる

  * `split()`の分割数は文字列の先頭から数えるが、`rsplit()`メソッドでは、末尾(右)からの分割数を指定する

```python
S.split([区切り文字列[, 分割数]])
```

* `join()`：シーケンス中の要素(文字列)を、文字列Sを使って連結する

  * 結果として、連結した文字列(コピー)を返す

```python
S.join(シーケンス)
```

* `strip()`：文字列の先頭および末尾から文字列を削除する

  * 結果として、削除を行った文字列(コピー)を返す

  * 引数を指定しないと、スペース、タブなどを含む空白文字列を削除する

  * 引数を指定すると、「削除する文字列」を対象に行う

  * 文字列の先頭(左)のみを対象に同様に処理を行う`lstrip()`メソッドや、

    末尾のみを対象とする`rstrip()`メソッドもある

```python
S.strip([削除する文字列])
```

* `upper()`：文字列Sの英字小文字を大文字に変換し、コピーを返す

```python
S.upper()
```

* `lower()`：文字列Sの英字大文字を小文字に変換し、コピーを返す

```python
S.lower()
```

* `ljust()`：文字列Sを、幅(数値)を考慮して「左寄せ」する

  * 文字列を表示する際、幅を合わせるために利用する

  * 文字列の長さが幅に満たない場合は、スペースで埋め、結果の文字列をコピーして返す

  * オプションの引数では、幅を合わせる時に利用する埋め草となる文字列を指定できる

  * 右寄せを行う`rjust()`や、中央寄せ(センタリング)を行う`center()`メソッドもある
