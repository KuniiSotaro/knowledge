02 クラスを作る
=============

* `クラス`を一言で説明すると、「プログラムで利用するオブジェクトの設計図」

* `オブジェクト`は、プログラムで利用するネジや歯車のような部品

* `オブジェクト`には、データと命令が一体になっている

* `オブジェクト`は、自分自身がどのようなデータを持っているだけでなく、

  * どのようなデータを持っているかを知っている

  * どのよな命令を実行すればいいかを知っている

  * 自分自身がどのように振る舞えがいいのかを知っている

* Pythonは多くのクラスを持っている

  * 特殊なこと、独自なことをするには、新しいクラスを作ったり、既存のクラスを拡張する必要がある

* クラスはインスタンスの設計図となるもの

  * インスタンスがどのような性質のデータを持っているか、インスタンスの持つデータに対してどのような処理を行う必要があるのかどうかで、設計図も変わってくる

* `クラス定義`：クラスの設計図を作ること

  * Pythonのオブジェクトは、データとメソッドを持っている

  * クラスの設計図には、オブジェクトにどのようなデータが保存されるか、どのようなメソッドを持つかを定義してゆく

  * データは`アトリビュート`と呼ばれる変数のようなものを使って、オブジェクトに保存する

  * メソッドは、Pythonの関数定義と同じ記法を使って定義する



## クラスを定義する

* `class文`；クラスを定義する

  * `class`の後に`クラス名`を続けて、クラスを定義する

```python
class クラス名:
  # クラスの内容
```

* クラスを定義するには、`クラス名`をつける

* 関数定義やif文と同じように、class文の右側にはコロン`:`をつける

* クラス定義の本体は、インデントしたブロックに記述する

* `pass`：何も処理を行わない

```python
>>> class MyClass:
...   pass
...
```

* クラス名には、**大文字で始まる英単語** を利用するようにする

  => クラス名を大文字で始める規則を作っておけば、関数とクラスを判別しやすくなる



## インスタンスのアトリビュート

* MyClassを用いて、インスタンスを作る

  * クラスからインスタンスを作るためには、クラスを関数のように呼び出す

```python
>>> i = MyClass()
```

* MyClassというクラスには何も定義されていない

* `アトリビュート`：インスタンスにデータを持たせる

  * 代入を行うことで定義する

  * 代入を行うには、インスタンスからドット`.`で区切ってアトリビュート名を記述する

```python
>>> i.value = 5
>>> i.value
5
```

* アトリビュートに代入を行うだけで、インスタンスにアトリビュートを幾つでも追加できる

* アトリビュートは変数と同じような働きをする

* 未定義のアトリビュートを参照するとエラーになる

```python
>>> i.undefined
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'MyClass' object has no attribute 'undefined'
```

* アトリビュートは、実際に代入を行なったインスタンスにしか追加されない

```python
>>> i2 = MyClass()
>>> i2.value
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'MyClass' object has no attribute 'value'
```

* アトリビュートは個々のインスタンスに別々に作られる

  * Pythonのクラス設計では、インスタンスにアトリビュートを持たせることで、データを登録していく

  * アトリビュートには、文字列型や数値、リストといった組み込み型のオブジェクトや、他のクラスのインスタンスを保存していく



## メソッドの定義と初期化メソッド「`__init__()`」

* インスタンスに自由にアトリビュートを追加できるのはとても便利

  => 実際に代入の操作を行なったインスタンスにしかアトリビュートが追加されないため、

    データを追加したい時には、毎回インスタンスのアトリビュートに代入を行う必要がある

* クラスはインスタンスの設計図なので、

  * インスタンスが持つべきデータは、インスタンスが作られた時にあらかじめ代入しておくように設計図を書く

  * インスタンスが作られた時に自動的に呼ばれるメソッド(初期化メソッド)を定義することができる

  * どのようなインスタンスに対しても共通して必要なアトリビュートは、このメソッドで代入をして定義するようにする

* Pythonのクラスにメソッドを定義するには、

  * クラス定義のブロック内にdef文を記述する

  * メソッドには、必ず引数として`self`を指定する

```python
class クラス名:
  def メソッド名(selfを含む引数):
    # メソッドのコード
```

* メソッドを呼び出した時、引数`self`にはインスタンス自体が渡される

  => `self`を使うとインスタンス自体を操作できる

  * `self`がインスタンス自体をさしているので、`self`を使ってアトリビュートに代入を行えば、インスタンスにアトリビュートを定義できる

* 初期化メソッドは、`__init__()`という名前である必要がある

  * この名前のメソッドは、インスタンスの生成時に自動的に実行される

  * メソッドの定義がクラスのブロックの中にあることに注意する

  * 初期化メソッドの中では、インスタンス(`self`)にアトリビュート(`value`)を追加し、数値(`0`)を代入する

```python
>>> class MyClass:
...   def __init__(self):
...     self.value = 0
...     print("This is __init__() method !")
...

# インスタンスを作る
>>> i = MyClass()
This is __init__() method !

# インスタンスのアトリビュートを表示する
>>> i.value
0
```

* クラスを設計するときは、インスタンスにどのようなデータを持たせるかを考える

* インスタンスには、アトリビュートを使ってデータを保存することができる

  * Pythonのクラスを定義する時には、初期化メソッドを使ってインスタンスに必要なアトリビュートを作っておくようにする

* 初期化メソッド`__init__()`には、`self`以外にも引数を設定することができる

  * 引数を設定すると、インスタンスを作る時に`SomeClass(1, 2, 'foo')`のように追加の引数を指定することができる

  * このように追加の引数を設定すると、インスタンスを初期化するときに引数を渡し、インスタンスのデータの内容をコントロールできる



## メソッドと第1引数「`self`」

* クラスのメソッドは、`__init__()`以外にも自由に定義できる

  * クラスを定義したら、**第1引数に必ず`self`を渡す** ようにする

    => `__init__()`と同じ

* 例)立体(角柱)を求める

  * インスタンスを作る時(初期化メソッドが呼び出される時)、幅・高さ・奥行きの3種類の数値を渡すようにする

    => アトリビュートとして保存する

```python
class Prism:
  def __init__(self, width, height, depth):
    self.width = width
    self.height = height
    self.depth = depth
```

* クラスは長さのデータを3種類持っているので、クラスに体積を求めるメソッドを定義する

  * 初期化メソッドと同じように、他のメソッドでも第1引数として`self`を指定するようにする

    => このメソッドを呼び出すと、引数`self`にインスタンスが代入される

```python
>>> class Prism:
...   def __init__(self, width, height, depth):
...     self.width = width
...     self.height = height
...     self.depth = depth
...
...   def  content(self):
...     return self.width*self.height*self.depth
...
>>> p1 = Prism(10, 20, 30)
>>> p1.content()
6000
```

* インスタンス`p1`を定義し、引数として長さのデータを渡している

* クラスのメソッドには、第1引数として`self`を指定したが、メソッドの呼び出しでは`self`に代入しているインスタンスは指定していない

  => インスタンスからメソッドを呼び出すとき、引数`self`には自動的にインスタンスが代入されて呼び出される

  * クラス定義の中でインスタンスに対して操作を行いたい時には、必ず`self`という引数に対して処理を行う

* インスタンスが入った変数から、高さや幅のような数値を取り出すには、アトリビュートを指定すれば値は取り出せる

```python
>>> p1.height
20
>>> p1.height = 50
>>> p1.height
50

# 体積は先ほどと異なる値となる
>>> p1.content()
15000
```

* Pythonのクラスのメソッド定義では、`self`という引数を活用して処理を進めていく

  * インスタンスが持つデータを`self`にアトリビュートとして登録していき、必要に応じて処理をする

  * メソッドの中で、アトリビュートを使って数値計算のような処理をしても良いし、アトリビュートを書き換えても良い

* `self`を使ってインスタンスにデータを登録し、メソッドを使ってメソッドの振る舞いを定義する



## アトリビュートの隠蔽

* Pythonのクラスで利用するアトリビュートは、とても強力で柔軟な機能

  * アトリビュートに対して変数のように代入を行うだけで、自由にアトリビュートを追加できる

  * インスタンスの中に1つの世界があって、その中で自由に変数を定義することができる

* Pythonの変数には色々な型のオブジェクトを代入できたが、アトリビュートも同様に色々な型のオブジェクトを代入できる

* 例)インスタンスを使って、クラスの外側からアトリビュートを使う

```python
>>> p = Prism(10, 20, 30)
>>> p.width
10
>>> p.depth = "30"
>>> p.content()
'303030303030303030303' # 省略
```

* アトリビュートの1つが文字列に書き換わったことで、メソッド内部で数字と文字列の掛け算が発生した

  => 文字列が数値の回数だけ繰り返された

* インスタンスを通じてアトリビュートを自由に操作できるデメリットとして、意図しない結果を招くことがある

  => クラス内部で利用するアトリビュートは、外部からは利用できないようにした方が良い

* `カプセル化`：クラスの内部だけで利用するアトリビュートやメソッドを隠して、外部から利用できなくすること



### アトリビュート名やメソッド名の先頭にアンダースコア`_`を1つ付ける

* Pythonでは、「名前の先頭にアンダースコア`_`が1つ付いたアトリビュートやメソッドは、クラスの内部だけで利用するためにある」

* クラスの機能を使う人は、`_size`などのように名前の先頭にアンダースコアが1つ付いたメソッドを見れば、

  このアトリビュートは外部から書き換えてはいけないということを知ることができる



### アトリビュート名やメソッド名の先頭にアンダースコア`_`を2つ付ける

* より厳しくアトリビュート名やメソッドへのアクセスを制限したい場合は、名前の前にアンダースコア`_`を2つ付ける

* クラスに`__size`という名前のアトリビュートを設定すると、クラスの外部からは`__size`という名前でこのアトリビュートにアクセスできなくなる

* アンダースコアが2つ付いていると、名前が内部的に他のものに置き換えられる。

  * クラス内部で、元の名前を使ってアトリビュートやメソッドを利用した時、内部で自動的に名前を変更する

  * クラスの外部では、自動的に名前を書き換えてくれない



| 版 |  年月日   |
|---|----------|
|初版|2019/01/30|
