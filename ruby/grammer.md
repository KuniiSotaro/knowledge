# 第3章 文法

## Silverの範囲

* リテラル(数値、真偽値、文字列、文字、配列、ハッシュ等）
* 条件分岐
* ループ
* 変数/定数とスコープ
* 演算子
* メソッド定義/メソッド呼び出し
* ブロック
* 例外処理

3章では、3-9、3-10-4はやらない

## 3-1.識別子
`識別子`とは・・・
`クラス名`や`変数名`などを構成する、全ての文法の基盤

### 3-1-1.命名規則

#### ローカル変数の識別子
`アンダースコア「_」`
`英数字`

※先頭に数字は使用できない
→数字と区別しにくいため

#### ローカル変数の識別子で使っていけない例

```ruby
obj-1          # アンダースコア以外の記号(例として、CSS)

initialized?   # アンダースコア以外の記号(`nil?`などのメソッドならいいが)

1_to_10        # 先頭に数字を指定

nil            # 予約語(他にも`true`など)
```

### 3-1-2.変数と定数のスコープ

#### 宣言可能な変数と定数

***

#### ローカル変数
**命名規則**
`先頭`：`英小文字`または、`_`
`構成文字`：`英数字`または、`_`

**スコープ(変数の有効な範囲)**
最初の代入式が使用された位置から、その代入を含む
`ブロック`または`メソッド`定義の終わりまで

**初期化していない時の参照時の動作**
`nil`：参照箇所より前に代入文が記述されているが、実行されなかった場合
`例外`：参照箇所より前に代入文が記述されていない場合

例)

```ruby
>> def foo
>>   a_A_05 = 1  # 先頭は「英小文字」、構成文字は「_」と「英数字」
>>   p a_A_05
>> end
=> :foo
>> foo
1
=> 1

>> foo = 1
=> 1
>> def bar
>>   foo     # メソッド呼び出しとみなされる
>> end
=> :bar
>> bar       # barメソッドのローカル変数fooは宣言されていないため
NameError: undefined local variable or method ｀foo｀ for main:Object
>> baz       # ローカル変数bazには対応する代入文がないため
NameError: undefined local variable or method ｀baz｀ for main:Object
```

***

#### グローバル変数
**命名規則**
`先頭`：`$`
`構成文字`：`英数字`または、`_`

**スコープ(変数の有効な範囲)**
どこからでも参照可能
→どこからでも更新できてしまうので、特に理由がなければローカル変数を使う

**初期化していない時の参照時の動作**
`nil`

例)

```ruby
>> $foo = 1
=> 1
>> def bar
>>   $foo    # ブロックの外側のグローバル変数$fooを参照
>> end
=> :bar
>> bar       # メソッドbarの$fooはメソッド外側の$fooを参照
=> 1
>> $baz      # 未初期化時のグローバル変数はnil
=> nil
```

***
#### クラス変数
**命名規則**
`先頭`：`@@`
`構成文字`：`英数字`または、`_`

**スコープ(変数の有効な範囲)**
そのクラスの全インスタンスから参照

**初期化していない時の参照時の動作**
`例外`発生

例)

```ruby
@@foo_1
```

***

#### インスタンス変数
**命名規則**
`先頭`：`@`
`構成文字`：`英数字`または、`_`

**スコープ(変数の有効な範囲)**
そのインスタンス内で参照可能

**初期化していない時の参照時の動作**
`nil`

例)

```ruby
@foo_1
```

***

#### 定数
**命名規則**
`先頭`：`英大文字`
`構成文字`：`英数字`または、`_`

**スコープ(変数の有効な範囲)**

* 定数が定義されたクラス・モジュール内
* そのクラス・モジュールの内部で定義されたクラス・モジュール内
* そのクラス・モジュールを継承、またはインクルードしているモジュール内

※クラス名やモジュール名で修飾すれば外部からアクセス可能

**初期化していない時の参照時の動作**
`例外`発生

例)

```ruby
RAILS_ENV
```

***

## 3-2.数値
**Rubyのリテラル**
`リテラル`とは・・・
変数と対になるもの。プログラムにそのまま記述する値(定数)。
→変更されないことを前提とする

* 数値
* 論理値
* 文字列
* シンボル
* 配列
* ハッシュ
* 範囲
* 正規表現
* コマンド出力

試験では、各リテラルについて

* どのように書くのか
* 何ができるのか

を即答できるようになる必要がある。

***

### 3-2-1.数値リテラル
Rubyでは、`整数`と`浮動小数点数`がリテラル構文でサポートされている

#### 数値リテラルの例

```ruby
>> +12      # 正負の判定(この場合は、正)
=> 12
>> -12      # 正負の判定(この場合は、負)
=> -12
>> 0.1      # 小数
=> 0.1
>> 3.0e2    # eを用いた指数表現(この場合は、3.0に10の2乗を乗算)
=> 300.0
>> 3.0e-2   # eを用いた指数表現(この場合は、3.0に10のマイナス2乗を乗算)
=> 0.03
```

***

#### 基数指定子
何進数で解釈させるかを指定

```ruby
>> 0b10     # 2進数(binary)：0b
=> 2
>> 0o10     # 8進数(octal)：0o
=> 8
>> 010      # 8進数(octal)：0 → 別の表記
=> 8
>> 0d10     # 10進数(decimal)：0d
=> 10
>> 0x10     # 16進数(hexadecimal)：0x
=> 16
```

表示できない数字を指定した例

```ruby
>> 0b2      # 2は2進数ではありえない
SyntaxError: (irb):6: numeric literal without digits
>> 0d1.1    # 小数は表せない
SyntaxError: (irb):7: unexpected fraction part after numeric literal
```

***

#### 数値リテラルでの特殊な例
数値リテラルの中で、アンダースコア`_`が指定できる(Rubyインタプリタは`_`を無視する)
→桁数を見やすく記述することなどに利用

```ruby
>> 100_000_000
=> 100000000
```

***

#### `?`に続く文字のリテラル
`?`に続いて文字を指定すると、指定した文字の`String表現`を返す
→入力されたキーを判定する時などに利用

```ruby
>> ?R         # 文字Rを表すString
=> "R"
>> ?\C-v      # コントロール(Ctrl)キー+vを表すString
=> "\u0016"
>> ?\M-a      # メタ(Alt)キー+aを表すString
=> "\xE1"
>> ?\n        # 改行を表すString
=> "\n"
```

***

#### 有理数、複素数のリテラル
**有理数(Rationalクラス)**
`r`を付加することで表現

**複素数(Complexクラス)**
`i`を付加することで、複素数の`虚数部`を表現

```ruby
>> (42/10r).class
=> Rational
>> 42/10r
=> (21/5)
>> 3.14r
=> (157/50)

>> 42i.class
=> Complex
>> 42i
=> (0+42i)
>> 3.14i
=> (0+3.14i)

>> 42ri              # 虚数部が有理数の複素数になる
=> (0+(42/1)*i)
>> 3.14ri            # 有理数にして、虚数部に変換
=> (0+(157/50)*i)
```

***

### 3-2-2.数値演算

#### 簡単な数値演算

```ruby
# 演算
>> 1 + 2     # 足し算
=> 3
>> 1 - 2     # 引き算
=> -1
>> 2 * 3     # 掛け算
=> 6
>> 4 / 2     # 割り算
=> 2
>> 4 % 3     #4を3で割った余り
=> 1

# 比較
>> 1 == 1    # 1と1は等しいか
=> true
>> 1 != 2    # 1と2は等しくないか
=> true
>> 1 < 2     # 1よりも2の方が大きいか
=> true
>> 2 >= 2    # 2は2以上であるか
=> true
```

***

#### UFO演算子
比較の結果を数値で返す、`比較演算子`
→ソート処理などで、順番の決定などに使用

```ruby
>> 100 <=> 10     # 左辺の値>右辺の値の時は、1
=> 1
>> 100 <=> 100    # 左辺の値=右辺の値の時は、0
=> 0
>> 10 <=> 100     # 左辺の値<右辺の値の時は、-1
=> -1
```

イメージとしては、天秤の両側に値を乗せて

* 左が沈んだら`1`
* 同じであれば`0`
* 右が沈んだら`-1`

***

#### 自己代入演算子

```ruby
>> a = 100
=> 100
>> a += 1    # a = a + 1
=> 101
>> a -= 1    # a = a - 1
=> 100
>> a *= 2    # a = a * 2
=> 200
>> a **=2    # a = a ** 2(aの2乗を返す)
=> 40000
```

***

### 3-2-3.数値クラスと演算子の再定義
Rubyでは、`全ての値が何らかのクラスのインスタンス`になっている
→生成元のクラスは、`classメソッド`で参照可能

```ruby
>> 1.class     # Integerクラス
=> Integer
>> 1.2.class
=> Float       # Floatクラス
```

***

#### 継承クラスの参照
どのような演算が可能か、対応するクラスのメソッドを調べる。

自身でメソッドを定義することで、

* 既存のものを再定義
* 独自のクラスに演算子を定義

することが可能

```ruby
>> 1.class.superclass                         # Numericクラス(数値を表現するクラス)
=> Numeric
>> 1.class.superclass.superclass              # Objectクラス(全てのクラスの親クラス)
=> Object
>> 1.class.superclass.superclass.superclass   # BasicObjectクラス(Objectクラスの親クラス。メソッドが白紙のクラス)
=> BasicObject
```

***

#### 再定義できない演算子

* スコープ演算子：`::`
* 代入演算子：`=`
* 条件演算子：`?:`
* 範囲演算子：`..`か`...`
* 論理演算子：`&&`か`and`か`||`か`or`か`not`

***

### 3-2-4.メソッド

#### メソッドの定義方法
`def`式の内部には、実行する処理を記述
一番最後に評価した式の結果が返り値

```ruby
def <メソッド> <引数リスト>
end
```

`引数リスト`：カッコを付けることも、省略することも可能(`仮引数`とも言う)

***

例)

```ruby
>> def foo a, b   # 引数で受けた2つの値を足して呼び出し元に返す
>>   a + b
>> end
=> :foo
```

***

#### メソッドの実行
呼び出しは、
`メソッド名(実引数)`

※実引数：メソッドを実行する際に記述する引数

```ruby
>> foo(1, 2)      # メソッド名を記述することで実行(引数がある場合には、メソッド名に続いて記述)
=> 3
>> foo 2, 3       # メソッド名は、カッコで囲んでも、省略してもOK
=> 5
```

***

#### 引数のデフォルト値
`仮引数`では、`デフォルト値`を指定できる

```ruby
>> def foo(a, b=100)
>> a + b
>> end
=> :foo
>> foo(2, 3)          # 指定された実引数の数が足りる場合
=> 5
>> foo(1)             # 実引数が足りない場合に、仮引数にデフォルトの値が格納されて実行
=> 101
>> foo                # デフォルトの値を合わせても引数の数が足りないため、例外
ArgumentError: wrong number of arguments (given 0, expected 1..2)
```

***

#### キーワード引数を用いたメソッドの定義
`キーワード引数`とは・・・
`仮引数名`と`デフォルト値`を、 **コロン`:`** で結びつけて定義可能

```ruby
>> def foo(a:, b: 100)        # コードをキーワード引数で定義
>>   a + b
>> end
=> :foo
>> foo(a: 2, b: 3)            # 呼び出しの際にハッシュオブジェクトを渡す
=> 5
>> foo(a: 1)                  # 仮引数にデフォルトの値が格納され、実行
=> 101
>> foo                        # デフォルトの値がないキーワードを省略すると、例外
ArgumentError: missing keyword: a
>> foo(a: 2, c: 100)          # キーワード引数に存在しない引数名を渡すと、例外
ArgumentError: unknown keyword: c
```

***

#### キーワード引数に任意の引数を使用する

定義した名前以外を引数として渡すと例外・・・
→任意の値をハッシュに格納することで対処

```ruby
>> def bar(a:, b: 100, **z)
>> p z
>> a + b
>> end
=> :bar
>> bar(a: 2, c: 100, d: 200)
{:c=>100, :d=>200}
=> 102
```

***

## 3-3.論理値
論理値には、`true`と`false`の２つがある。
それぞれのクラスは、

`true`：`TrueClass`クラスのインスタンス
`false`：`FalseClass`クラスのインスタンス

となっている。

ただし、Rubyでは **`true`は真の代表値であり、`false`と`nil`以外のオブジェクトは全て`真`と見なされる**

### 3-3-1.条件分岐
`if文`

```ruby
if <条件式> then
end
```

例)

```ruby
>> if true then
?>  p 1
>> end
1
=> 1
```

***

#### if式を評価した値
if文・・・`文`ではなく、`式`。評価すると`値`が返る
↓
`評価値`は、if式の中で **最後に評価された値**

応用例：何らかの条件が成立する場合に`値`を代入する

```ruby
>> a = if true
>> 1
>> end
=> 1
>> p 1
1
=> 1
```

また、`if修飾子`(`真の時に実行する式 if 条件式`)のような構文も記述可能

```ruby
>> a = 1 if true
=> 1
>> p a
1
=> 1
>> a = 2 if false
=> nil
>> p a
1
=> 1
```

***

#### 条件が成立しない場合の変数宣言
変数の宣言(初出の変数への値の代入)とif式を組み合わせた場合に、
**判定結果に関わらず、変数自体は確保** される。

理由・・・

* Rubyインタプリタは、`初出の変数への代入`を検出済み
* 条件が成立しない場合にスキップされるのは、`値の代入`
↓
`if文`の条件が不成立でも、後からその変数を参照できる。
→`未宣言の変数`との違いが重要！

```ruby
>> b = 3 if false   # 変数b(値：nil)が確保
=> nil
>> p b
nil
=> nil
>> p c              # 変数cは未定義→例外発生
NameError: undefined local variable or method ｀c｀ for main:Object
```

***

#### `then`節と`elsif`節

`else節`：条件が成立しない場合の処理を記述する方法
↓
`elsif節`：さらに条件を指定する場合(Rubyのみの記法)

```ruby
>> a = if false then
?>   1
>> elsif false
>>   2
>> else
?>   3     # 値はtrueなので
>> end
=> 3
>> p a
3
=> 3
```

***

#### `unless式`

条件が成立しない場合の処理を先に記述する際に使用

例)

* `if式`と同様に、修飾子として使用
* `else節`などを指定する
* 結果的に、コードの可読性が向上する

```ruby
>> unless false
>> p 1
>> end
1
=> 1
```

***

#### 条件演算子(三項演算子)

**構文**

```ruby
条件式 ? 式1 : 式2
```

条件式を評価し、

* 成立する場合は、`式1`
* 成立しない場合は、`式2`

を返す

```ruby
>> a = true ? 1 : 2
=> 1
```

***

### 3-3-2.擬似変数
`nil`と`true`と`false`の3種類は、 **擬似変数** と呼ばれるもの。

擬似変数は、代入することができない。

```ruby
>> true = 1
SyntaxError: (irb):13: Can't assign to true
true = 1
      ^
	from /Users/MacUser/.rbenv/versions/2.4.1/bin/irb:11:in `<main>'
```

#### 擬似変数の種類

* `true`：`TrueClass`クラスのインスタンス
* `false`：`FalseClass`クラスのインスタンス
* `nil`：`NilClass`クラスのインスタンス

それ以外にも4種類ほどある。

* `self`：現在のオブジェクト
* `__FILE__`：現在実行しているプログラムのファイル名
* `__LINE__`：現在実行しているプログラムの行番号
* `__ENCODING`：現在のソースファイルのスクリプトエンコーディング

#### 擬似変数の働き
Rubyは、**`nil`と`false`のみが、`偽`を表す**
それ以外の値は、**全て`真`を表す**

```ruby
>> a = 10
=> 10
>> if a then; a; end      # 変数`a`は10・・・`false`と`nil`以外なので、`真`
=> 10
>> @a                     # 変数`@a`はnil・・・未定義なので`偽`
=> nil
>> if @a then; 1; end     # 変数`@a`は不成立・・・変数`@a`は`偽`のため
=> nil
```

インスタンス変数に値が入っているかどうかの判定は、`変数`を評価(参照)することで行うことが可能
→`nil`と比較する必要がない

※ `nil`：何もないことを表現する。他言語でいう、`null`

***

### 3-3-3.論理演算子

* `&&`：論理積(且つ)
* `||`：論理和(または)
* `!`：否定(ではない)

```ruby
>> if true && true; 1; end    # `true`且つ`true`なら、真
=> 1
>> if nil && 10; 1; end       # `nil`且つ`10`なら、真・・・存在しないので、`nil`
=> nil
>> if false || true; 1; end   # `false`または`true`なら、真
=> 1
>> if nil || false; 1; end    # `nil`または`false`なら、真・・・`nil`と`false`以外は`真`なので、`nil`
=> nil
>> if !true; 1; end           # `true`でなければ真・・・`nil`と`false`以外は`真`なので、`nil`
=> nil
```

***

#### 論理演算子を適用した式の評価値
論理演算子では、

* 左辺で式の結果が確定する場合は、**右辺を評価しない**
* 式の評価値は、最後に評価したオペランド

```ruby
>> a = nil && 1   # 右辺は`1`だが、評価されない
=> nil
>> a = 1 || 2     # 右辺は`2`だが、評価されない
=> 1
```

応用例として・・・

```ruby
>> b = b || 1    # bが初期化されていない場合(nil)に、`1`を格納
=> 1
>> c ||= 1       # cが初期化されていない場合(nil)に、`1`を格納・・・自己代入演算子
=> 1
```

※ オペランド
式を構成する要素のうち、演算子じゃない方の要素
→式に登場する数値、変数

例)
1+2なら、

* 1、2：オペランド
* +：演算子

***

#### 優先順位が低い`and`、`or`、`not`

* `and`：論理積`&&`
* `or`：論理和`||`
* `not`：否定`!`

に対応する。
一方で、自己代入することができず、代入演算子よりも演算子の優先度が低い

```ruby
>> p 1 && 2      # p (1 && 2)と同義・・・論理積の結果がpに渡される
2                # 2が出力
=> 2
>> p 1 and 2     # (p 1) and 2と同義・・・pの実行結果と2の論理積が渡される
1                # 1が出力
=> 2
>> p (1 and 2)   # &&と同じ結果を出力
2
=> 2
```

***

## 3-4.文字列

文字列の特徴

* リテラル書式のバリエーションが豊富
* `ヒアドキュメント`と、`パーセント記法`が利用可能
* 各書式には、`式展開`が適用できるものとできないものがある


### 3-4-1.文字列リテラルと式展開

基本的には、 **ダブルクオート`""`** と **シングルクオート`''`** で囲む
↓
文字列の値として認識され、Stringクラスのインスタンスが生成

```ruby
>> a = "abcd"       # 文字列
=> "abcd"
>> p a
"abcd"
=> "abcd"
>> p a.class        # 変数aのクラス・・・Stringクラス
String
=> String
>> b = "ab" 'cd'    # 文字列リテラルを連続して記述することで、それらを連結した文字列を生成
=> "abcd"
>> p b
"abcd"
=> "abcd"
```

***

#### 式展開

式展開とは、

* ダブルクオートで囲まれた`#{}`で囲まれた部分が式として評価され、その結果を文字列中に展開されること
* シングルクオートで囲まれたものは、式展開が行われずに文字列として評価される

```ruby
>> a = 1
=> 1
>> p "a is #{a}"
"a is 1"
=> "a is 1"
>> p 'a is #{a}'
"a is \#{a}"
=> "a is \#{a}"
```

〜解説〜

* `#{}`内部では、任意の式を指定。評価結果となった値の`to_s`メソッドが呼び出される
* `to_s`メソッドは、オブジェクトの文字列表現を返す
* この場合、`#{a}`は`"1"`という文字列に変換され、指定箇所に挿入される

***

#### 文字列から数値に変換

* 数値から文字列：`to_s`メソッド
* 文字列から整数：`to_i`メソッド
* 文字列から浮動小数点数：`to_f`メソッド
* 文字列から有理数：`to_r`メソッド
* 文字列から複素数：`to_c`メソッド

```ruby
>> "100".to_i       # 文字列"100"が数値100に変換
=> 100
>> "1.9".to_f       # 文字列"1.9"が浮動小数点数1.9に変換
=> 1.9
>> "5/2".to_r       # 文字列"5/2"が有理数5/2に変換
=> (5/2)
>> "1+2i".to_c      # 文字"1+2i"が複素数(1+2i)に変換
=> (1+2i)
>> "12ab3".to_i     # 文字列"12ab3"のうち、abの前の12が数値12へ変換
=> 12
>> "12ab3".to_f     # 文字列"12ab3"のうち、abの前の12が浮動小数点数12.0へ変換
=> 12.0
>> "1.9".to_i       # 文字列"1.9"のうち、.の前の1が数値1へ変換
=> 1
>> "1.9.9".to_f     # 文字列"1.9.9"のうち、.9の前の1.9が浮動小数点数1.9へ変換
=> 1.9
```

※ 最初の文字が無効である場合は、`0`が返される

***

### 3-4-2.バックスラッシュ記法

バックスラッシュ記法とは・・・
`\`に続けて文字を指定する方法

* `\x`：xの文字そのもの
* `\n`：改行
* `\r`：キャリッジリターン・・・カーソルを文頭へ戻す
* `\f`：改ページ
* `\a`：ベル
* `\e`：エスケープ
* `\s`：空白
* `\b`：バックスペース
* `\t`：タブ
* `\v`：垂直タブ
* `\nnn`：8進数表記(nは0-7)
* `\xnn`：16進数表記(nは0-9、a-f)
* `\cx`、または`\C-x`：コントロール文字(xはASCII文字)
* `\M-x`：メタx
* `\M-\C-x`：メタ コントロールx
* `unnnn`：Unicode文字(nは0-9、a-f、A-F)
* `\u{nnnn}`：Unicode文字(nは0-9、a-f、A-F)。nnnnは16進数で1〜6桁まで指定可能。スペースorタブ区切りで複数のUnicode文字を指定可能

※ 時間があるときに、例を追加する
2018/08/13

***

#### 8進数表記と16進数表記

```ruby
>> p "\101"     # "A"の文字コートは8進数で101
"A"
=> "A"
>> p "\x41"     # "A"の文字コードは16進数で41
"A"
=> "A"
```

***

#### `p`と`print`と`puts`の違い

* `p`：出力する値と共に型情報（文字列や数値型など）を一緒に出力。引数ごとに改行。
* `print`：半角スペースを空けて出力する値を指定するだけで利用可能。改行しない。
* `puts`：末尾に改行が入る形で出力される。

```ruby
>> p "a\nb"       # バックスラッシュ記法が適用されずに出力
"a\nb"
=> "a\nb"
>> print "a\nb"   # バックスラッシュ記法を適用して出力(改行されない)
a
b=> nil
>> puts "a\nb"    # バックスラッシュ記法を適用して出力(改行される)
a
b
=> nil
```

|メソッド|     改行    |出力内容の構築メソッド|バックスラッシュ記法|
|-------|------------|-------------------|----------------|
|   p   |引数ごとに改行 |   inspectメソッド  |   そのまま出力   |
| print |  改行しない  |    to_sメソッド    | 適用した結果を出力 |
|  puts |引数ごとに改行 |    to_sメソッド    | 適用した結果を出力 |

***

#### `p`のバックスラッシュ記法

バックスラッシュ記法が解釈された結果の文字によって、  
バックスラッシュ記法で別途エスケープして出力

```ruby
>> p "\x61"
"a"
=> "a"
>> p "\x0a"
"\n"
=> "\n"
>> p '\x0a'     # シングルクオートで囲んだ場合は、シングルクオートとバックスラッシュのエスケープのみが適用
"\\x0a"
=> "\\x0a"
```

***

### 3-4-3.ヒアドキュメント

バックスラッシュ記法を簡単にしたもの

* より簡単に改行コードを含む文字列を指定
* `<<`に続けて文字列の終端を示す任意の識別子を指定

```ruby
>> query = <<SQL
  select *
  from my_table;
SQL
=> "  select *\n  from my_table;\n"
>> query
=> "  select *\n  from my_table;\n"
```

***

#### 階層が深い場合のヒアドキュメント
ヒアドキュメントでは、 **終端を示す識別子の前には、スペースなどの文字を記述してはいけない**
→開始の識別子の頭に、ハイフン`-`をつけることで回避

```ruby
>> def foo
>>     <<-RESULT
      Ru
      By
    RESULT
>> end
=> :foo
>> p foo
"      Ru\n      By\n"
=> "      Ru\n      By\n"
```

ハイフン`-`をつけると空白になるので、チルダ`~`をつけることで対処できる

```ruby
>> def foo
>>     <<~RESULT
      Ru
      By
    RESULT
>> end
=> :foo
>> p foo
"Ru\nBy\n"
=> "Ru\nBy\n"
```

***

#### ヒアドキュメントのシングルクオート、ダブルクオート

* ダブルクオート：`式展開`や`バックスラッシュ記法`の適用が可能
* シングルクオート：`式展開`や`バックスラッシュ記法`が無効

```ruby
>> a = 1
=> 1

>> s = <<'TEST'     # シングルクオート
#{a}
TEST
=> "\#{a}\n"
>> p s
"\#{a}\n"
=> "\#{a}\n"

>> s =<<"TEST"      # ダブルクオート
#{a}
TEST
=> "1\n"
>> p s
"1\n"
=> "1\n"
```

***

### 3-4-4.パーセント記法
パーセント記法とは・・・
文字列を囲む記号を、プログラマ自身が指定可能


```ruby
>> a = %*test*       # %を使用することで、ダブルクオート文字列にする
=> "test"
>> p a
"test"
=> "test"
>> a = %*"test"*     # エスケープなしでダブルクオートを文字列中に使用
=> "\"test\""
>> p a
"\"test\""
=> "\"test\""
>> a = %[test]       # 文字列を囲む記号は対になれば、何でも良い
=> "test"
>> p a
"test"
=> "test"
>> a = 1
=> 1
>> %q!#{a + 1}!      # %qを指定することで、シングルクオートになる
=> "\#{a + 1}"
>> %Q?#{a + 1}?      # %Qを指定することで、ダブルクオート文字列になる
=> "2"
```

***

#### パーセント記法の例

* `%`：ダブルクオート文字列
* `%Q`：ダブルクオート文字列(`%`のみと同等)
* `%q`：シングルクオート文字列・・・文字型としてよく使用
* `%s`：シンボル
* `%W`：要素がダブルクオート文字列となる配列(要素の区切り・空白文字)
* `%w`：要素がシングルクオート文字列となる配列(要素の区切り・空白文字)→enumでよく使用
* `%x`：コマンド出力
* `%r`：正規表現

***

### 3-4-5.文字列演算
文字列・・・`加算(+メソッド)`と`乗算(*メソッド)`の2つが適用可能

```ruby
>> a = "ru" + "by"    # 加算は、文字連結された値を返す
=> "ruby"
>> a * 3              # 乗算は、右辺の数値の回数だけ文字連結された値を返す
=> "rubyrubyruby"
>> 3 * a              # 左辺に数値は指定できない
TypeError: String can｀t be coerced into Integer
```

***

#### `<<`メソッドによる連結

```ruby
>> a = "ru"
=> "ru"
>> p a << "by"     # 破壊的メソッド
"ruby"
=> "ruby"
>> p a
"ruby"
=> "ruby"
```

***

#### 異なる文字コード間での文字列操作

`String`クラスのインスタンス内に、文字コードの情報を持つ。
→異なる文字コード間で文字列操作を行おうとすると例外発生

※ デフォルトは`UTF-8`

```ruby
>> a = "ルビー"
=> "ルビー"
>> a.encoding
=> #<Encoding:UTF-8>
>> b = a.encode("SJIS")        # "ルビー"をWindows-31Jに変換
=> "\x{838B}\x{8372}\x{815B}"
>> b.encoding
=> #<Encoding:Windows-31J>
>> a + b
Encoding::CompatibilityError: incompatible character encodings: UTF-8 and Windows-31J
```

***

#### 文字列の比較

文字列の場合は、文字コードの大小で不等号の結果が成立
↓
文字コードの大小は、`辞書順`

```ruby
>> "a" < "b"
=> true
>> "ab" < "ac"
=> true
>> "Ab" < "Ab"
=> false
>> "Ab" == "Ab"
=> true
>> "Ab" <=> "Ab"
=> 0
```

***

#### 文字列の参照

```ruby
>> "abcde".length    # 文字列の長さ
=> 5
>> "日本語".length    # 文字列の長さ
=> 3
```

***

### 3-4-6.`sprintf`によるフォーマット指定

* 第一引数：フォーマット
* 第二引数以降：フォーマットしたい値

```ruby
# 進数の指定
>> sprintf("result: %#b", 16)          # b：2進数
=> "result: 0b10000"
>> sprintf("result: %#o", 16)          # o：8進数
=> "result: 020"
>> sprintf("result: %#x", 16)          # x：16進数
=> "result: 0x10"
>> sprintf("result: %#X", 16)          # X：16進数
=> "result: 0X10"
>> sprintf("result: %02d", 1)          # 2桁指定
=> "result: 01"
>> sprintf("result: %03d", 1)          # 3桁指定
=> "result: 001"
>> sprintf("result: %05.2f", 1.1111)   # 符号と小数点を含んで5桁、小数点以下が2桁
=> "result: 01.11"
```

***

#### `sprintf`関数の文字列`%`演算

`String`クラスの`%`演算と同じ結果を得られる

```ruby
>> "result: %02d" % 1
=> "result: 01"
>> "result: %03d" % 1
=> "result: 001"
>> "result: %05.2f" % 1.1111
=> "result: 01.11"
```

***

## 3-5.シンボル

### 3-5-1.シンボルリテラル

* 文字列の先頭に **コロン`:`** を付加する
* 文字列の囲み文字(ダブルクオートなど)を省略する

```ruby
>> foo1 = :"foo1"            # ダブルクオートを指定した場合
=> :foo1
>> foo2 = :"#{foo1}foo2"     # 式展開を利用した場合
=> :foo1foo2
>> foo3 = :'foo3'            # シングルクオートを使用した場合
=> :foo3
>> foo4 = :foo4              # 囲み文字を省略した場合
=> :foo4
```

***

#### パーセント記法を用いたシンボルの指定

```ruby
>> %s?foo1?     # `%s`でシンボル
=> :foo1
>> %s[foo2]     # `%s`でシンボル
=> :foo2
```

***

#### 文字列とシンボルの変換

文字列と違って、加算(+メソッド)が用意されていない
→一度文字列に変換してから、シンボルに変換する

```ruby
>> v1 = "foo1"
=> "foo1"
>> v2 = v1.to_sym
=> :foo1
>> v3 = v2.to_s
=> "foo1"
```

***

### 3-5-2.オブジェクトの同値性と同一性

* 文字列リテラル：文字の並びが同一でも、指定するごとに新たなStringオブジェクトが生成
* シンボルリテラル：文字列の並びが同一なら、同一のオブジェクトを参照する

`object-id`とは、、
**リテラル型に対応するクラスのインスタンス(オブジェクト)に割り振られるID**

```ruby
>> p "foo1".object_id   # 1回目のオブジェクト生成(文字列リテラル)
70247164007560
=> 70247164007560
>> p "foo1".object_id   # 2回目のオブジェクト生成(文字列リテラル)
70247163993640
=> 70247163993640
>> p :foo1.object_id    # 1回目のオブジェクト生成(シンボルリテラル)
1159388
=> 1159388
>> p :foo1.object_id    # 2回目のオブジェクト生成(シンボルリテラル)
1159388
=> 1159388
```

* Rubyの処理系では、シンボルは内部で整数として扱う
* 文字列よりもシンボルの方が効率よく処理・・・処理が早いため

***

#### オブジェクトの同値性と同一性の判定

* `equal?`メソッド：2つのオブジェクトが同一かどうかを論理値で返す。(サブクラスでオーバーライドしない)
* `==`：等価演算子。2つのオブジェクトが等しいかどうかを判定。(多くのクラスでオーバーライド)
* `eql?`メソッド：型の比較を行う。値が等しくても`false`を返すことがある。

```ruby
# 文字列
>> "foo1" == "foo1"
=> true
>> "foo1".equal? "foo1"
=> false

# シンボル
>> :foo1 == :foo1
=> true
>> :foo1.equal? :foo1
=> true

# eql?メソッド
>> "foo1".eql? "foo1"   # 文字型
=> true
>> 1.0 == 1             # 整数型と浮動小数点型だが、同じ数値
=> true
>> (1.0).eql? 1         # 整数型と浮動小数点型は型が異なるため、false
=> false
>> (1.0).eql? 1.0       # 型も値も同じため、true
=> true
```

### 3-5-3.変数と値

**時間があるときにまとめる**
→割と当たり前なので

***

## 3-6.配列

### 3-6-1.配列リテラル

* `Arrayクラス`のインスタンス
* 要素を`[]`で囲み、要素の間をカンマ`,`で区切ることで生成
* 配列の各要素に異なった形の値を指定可能

```ruby
>> a = []
=> []
>> b = [10, true, "30"]
=> [10, true, "30"]
>> b[0]
=> 10
```

***

#### 二次元配列の例

配列自体は１つの値なので、`配列`を配列の要素として指定可能

```ruby
>> a = [[1, 2], [3, 4]]
=> [[1, 2], [3, 4]]
>> a[0][0]
=> 1
>> a[1][1]
=> 4
```

***

#### パーセント記法による配列の生成

* コード中にダブルクオートやカンマが少なくなり、プログラム自体がスッキリする
* `join`メソッド(配列の要素を連結して文字列を生成)で便利
* `%W`ではダブルクオート文字列、`%w`ではシングルクオート文字列。
* 要素間は空白で区切って記述する

```ruby
>> v1 = %w[hoge foo bar]      # 配列の生成
=> ["hoge", "foo", "bar"]
>> v1.join                    # 配列の要素を連結
=> "hogefoobar"
>> v1.join("_")               # 配列の要素をアンダースコア`_`で連結
=> "hoge_foo_bar"
```

#### インスタンスの生成による配列の生成

* `Arrayクラス`のインスタンスを生成することで、配列を生成
* 初期値は、 **第2引数** や **ブロック** で指定可能

```ruby
>> a = Array.new(5)                     # コンストラクタに`5`を指定
=> [nil, nil, nil, nil, nil]
>> a.length                             # 生成した配列からサイズを参照
=> 5
>> Array.new(2){|index| index + 10}     # 初期値をブロックで指定
=> [10, 11]
```

ただし、 **第2引数** で指定した初期値オブジェクトは、全て同一のオブジェクト

```ruby
>> a = Array.new(2, "a")     # a[0]とa[1]は同一のオブジェクト
=> ["a", "a"]
>> a[0].replace("b")         # a[0]とa[1]の両方がreplaceされる
=> "b"
>> p a                       # ["b", "a"]とはならない
["b", "b"]
=> ["b", "b"]
```

これを避けるためには、 **ブロック** で初期値を指定する

```ruby
>> a = Array.new(2){"a"}     # ブロックはよくわからないので、Goldを取得する際に勉強
=> ["a", "a"]
>> a[0].replace("b")
=> "b"
>> p a
["b", "a"]
=> ["b", "a"]
```

***

#### サイズを超えた要素への代入

配列のサイズは、要素への代入によって変わる。
上限を超えた際には、`nil`を返す

```ruby
>> v1 = [10]
=> [10]
>> v1.length
=> 1
>> v1[3] = "aa"
=> "aa"
>> v1.length
=> 4
>> v1[2]          # 配列で初期化されていない
=> nil
>> v1[100]        # 配列の上限は3なのでnil
=> nil
```

***

### 3-6-2.添字演算子

* 添字は、末尾の要素を`-1`として、先頭に向けて順に減っていく
* 配列のサイズ+指定された負の整数=実際のインデックス

```ruby
>> v1 = [10, nil, nil, "aa"]
=> [10, nil, nil, "aa"]
>> p v1[-1]                   # 配列の長さ：4、4-1=3なので3番目を返す
"aa"
=> "aa"
>> p v1[4-1]                  # 4-1=3なので3番目を返す
"aa"
=> "aa"
>> p v1[-4]                   # 配列の長さ：4、4-4=0なので0番目を返す
10
=> 10
>> p v1[4-4]                  # 4-4=0なので0番目を返す
10
=> 10
```

***

#### 要素数を指定された要素の参照

添字に2つの整数を指定すると、

* 最初の添字：操作対象のインデックス
* 次の添字：そこからの要素数

```ruby
>> a = [0, 1, 2, 3, 4, 5]
=> [0, 1, 2, 3, 4, 5]
>> a[2, 3]                 # 配列aの最初のインデックスは2、そこから3個の要素を返す
=> [2, 3, 4]
```

***

#### 要素数を指定した代入

要素数を指定した上で代入することで、その部分が指定された値に置き換わる

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a"     # 配列aのインデックス1から2つの要素を"a"に置換
=> "a"
>> p a
[0, "a", 3]
=> [0, "a", 3]
```

***

#### 要素数を指定して配列・複数の式を代入

要素数を指定して代入する場合は、複数の値を指定することができる

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = ["a", "b"]
=> ["a", "b"]
>> p a
[0, "a", "b", 3]
=> [0, "a", "b", 3]
```

代入する値のかっこは、省略することができる
→厳密には、複数の式の代入

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a", "b"
=> ["a", "b"]
>> p a
[0, "a", "b", 3]
=> [0, "a", "b", 3]
```

***

#### 指定数以上の個数の値の代入

代入する値の個数の方が多いと、余った値が要素に挿入される

```ruby
>> a = [0, 1, 2, 3]
=> [0, 1, 2, 3]
>> a[1, 2] = "a", "b", "c"   # a[2]から2つの要素なので、余った"c"は要素に追加
=> ["a", "b", "c"]
>> p a
[0, "a", "b", "c", 3]
=> [0, "a", "b", "c", 3]
```

***

### 3-6-3.多重代入と可変長引数

```ruby
>> a, b, c = 1, 2, 3
=> [1, 2, 3]          # メソッドの返り値で複数の値(配列)を返す
>> p a
1
=> 1
>> p b
2
=> 2
>> p c
3
=> 3
```

***

#### 返り値に複数の値を指定

```ruby
>> def foo
>>   return 1, 2, 3     # 明示的に`return`を指定する必要がある
>> end
=> :foo
>> a, b, c = foo
=> [1, 2, 3]
>> p a
1
=> 1
>> p b
2
=> 2
>> p c
3
=> 3
```

***

#### 配列による多重代入

* 変数を`カッコ`で囲むことで、対応する配列を指定

```ruby
>> a, b, c = [1, 2, 3]     # a, b, c = 1, 2, 3 と結果は同じ
=> [1, 2, 3]
>> (a, b), c = [1, 2], 3   # 配列の中に配列が入る
=> [[1, 2], 3]
```

***

#### 多重代入の注意点

* 変数に対して代入する値の個数が足りない場合は、余った整数に`nil`が格納
* 変数よりも値の個数が多い場合は、値が左から順に代入され、余った値は無視される
* １つの変数に複数の値を代入した場合は、配列の代入になる
* 代入する値の個数が多く、余った値を無視したくない場合は、最後の変数名に`*`をつける
  結果として、指定した変数に余った値が配列としてまとめて代入される。

```ruby
# 多重代入で値の個数が足りない場合
>> a, b, c = 1, 2
=> [1, 2]
>> p a
1
=> 1
>> p b
2
=> 2
>> p c      # 余った値は無視される
nil
=> nil

# 多重代入で値の個数が多い場合
>> a, b = 1, 2, 3
=> [1, 2, 3]
>> p a
1
=> 1
>> p b
2
=> 2

# １つの変数に複数の値を代入
>> a = 1, 2     # 配列の代入になる
=> [1, 2]
>> p a
[1, 2]
=> [1, 2]

# 最後の変数に配列で代入
>> a, *b = 1, 2, 3
=> [1, 2, 3]
>> p a
1
=> 1
>> p b       # 2, 3は配列[2, 3]として代入
[2, 3]
=> [2, 3]
```

***

#### 可変長引数

* `*`の指定は、仮引数でも可能(**可変長引数**)
* 実引数に`*`を付けることで、配列を引数に展開することができる
  →可変長引数を他のメソッドに渡す場合などに使用

```ruby
# 可変長引数
>> def foo a, *b
>>   b
>> end
=> :foo
>> foo(1, 2, 3)    # 余った引数がまとめて`*b`に入る
=> [2, 3]

# 引数展開
>> def foo1 a, *b  # foo1の実行によって、仮引数bに配列[2, 3]が格納
>>   foo2(*b)
>> end
=> :foo1
>> def foo2 c, *d  # 配列[2, 3]を実引数としてfoo2に渡す
>>   d             # 仮引数dに3のみで構成される配列[3]が格納
>> end
=> :foo2
>> foo1(1, 2, 3)
=> [3]
```

### 3-6-4.配列の演算

#### Arrayクラスの二項演算子

* `&`演算子：数値では、ビット演算子となり論理値を返す
            →配列では、両方に含まれる要素から構成される配列が返る

* `|`演算子：集合の和演算子になる
             →配列では、どちらかに含まれる要素から構成される配列が返る

* ただし、これらの結果は同値のものは排除される(`eql?`メソッドで同値判定)

```ruby
>> a = [1, 1, 2, 3]
=> [1, 1, 2, 3]
>> b = [2, 2, 3, 3]
=> [2, 2, 3, 3]
>> a & b             # aとbの配列では、2と3は両方が含まれる
=> [2, 3]
>> a | b             # aとbの配列では、1と2と3が和集合
=> [1, 2, 3]
```

***

* `+`演算子：要素を繋げた配列を返す
* `-`演算子：対象の要素を取り除いた配列を返す

```ruby
>> a = [1, 1, 2, 2]
=> [1, 1, 2, 2]
>> b = [2, 2, 3, 4]
=> [2, 2, 3, 4]
>> a + b
=> [1, 1, 2, 2, 2, 2, 3, 4]
>> a - b                       # 右オペランドで指定された要素が全て取り除かれる
=> [1, 1]
```

***

* `*`演算子：
  * 数値：その数だけ連結した配列を返す
  * 文字列：その文字を区切りとして要素を連結(`join`メソッドと同じ)

```ruby
>> [1, 2] * 3            # 配列[1, 2]を三回繰り返す
=> [1, 2, 1, 2, 1, 2]
>> [1, 2, 3] * "-"       # 配列の区切りは"-"
=> "1-2-3"
>> [1, 2, 3].join("-")   # 同様
=> "1-2-3"
```

***

### 3-6-5.`for式`

* 指定された式の範囲を繰り返し実行
  →構文中の`do`は省略可能

* 識別子は、複数指定することができる

```ruby
# for式の構文
for <識別子> in <式> do
    <出力内容>
end

# 実際の例
>> a = [2, 3, 4]
=> [2, 3, 4]
>> for i in a do
?>   p i
>> end
2
3
4
=> [2, 3, 4]

>> for i,j in [[1, 2], [3, 4]]  # 複数指定した識別子
>>   p i + j
>> end
3
7
=> [[1, 2], [3, 4]]
```

***

#### スコープを作るものと作らないもの

* `for式`：スコープが作成されない。内部で初期化した変数は、その後のコードから参照可能

* `eachメソッド`：スコープが作成される。内部で初期化された変数は、外部で参照できない。

```ruby
# for式
>> for i in [2, 3, 4]  # for式の内部で変数barに繰り返し1を代入。(グローバル変数化)
>>  bar = 1
>> end
=> [2, 3, 4]
>> p bar               # 外部から参照可能
1
=> 1

# eachメソッド
>> [2, 3, 4].each do   # eachメソッドのブロックで、スコープが作成
?>  bar = 1
>> end
=> [2, 3, 4]
>> p bar               # 外部から参照不可
NameError: undefined local variable or method ｀bar｀ for main:Object
```

***

## 3-7.ハッシュ

* 複数の値から構成される`配列`に、各値に名前をつけて管理するもの

### 3-7-1.ハッシュリテラル

* 両側を波カッコ`{}`で囲む
* `キー`と`値`の組を、`キー => 値`として区切る
* 添字演算子で指定することで値を操作する
* 存在しないキーを指定すると、デフォルトで`nil`が返る

```ruby
>> a = { "foo1" => 1, "foo2" => 2, "foo3" => 3 }
=> {"foo1"=>1, "foo2"=>2, "foo3"=>3}
>> a["foo1"]
=> 1
>> a["foo2"]
=> 2
>> p a
{"foo1"=>1, "foo2"=>2, "foo3"=>3}
=> {"foo1"=>1, "foo2"=>2, "foo3"=>3}

# 存在しないキーの指定
>> a = {}
=> {}
>> a[:foo1]
=> nil
```

***

#### ハッシュの`キー`について

* `キー`には任意のオブジェクトを指定することができる

* Rubyインタプリタは、添字演算子で指定された`キー`から、ハッシュが保持する`キー`について次の項目を確認
  * 両者の`hash`メソッドの結果が等しいか
  * `eql?`メソッドで比較した結果が真となるか

* 文字列を`キー`とする場合は、 **シンボル** を使用する方が処理が高速になる

***

#### キーに`シンボル`を用いたハッシュ

* キーには`シンボル`を用いて記述することができる
* Ruby1.9以降では、ハッシュリテラルの記法が`:`で区切ることができる
  →ただし、文字列のキーを使用する際は`=>`を使用

```ruby
# シンボルを用いたハッシュ
>> a = {:foo1 => 1, :foo2 => 2, :foo3 => 3}
=> {:foo1=>1, :foo2=>2, :foo3=>3}
>> a[:foo1]
=> 1

# シンボルを用いたハッシュは`:`で区切ることも可能
>> a = {foo1: 1, foo2: 2, foo3: 3}
=> {:foo1=>1, :foo2=>2, :foo3=>3}
>> a[:foo1]
=> 1
```

***

#### ハッシュを生成する方法

* 存在しないキーを指定した場合の返り値(`nil`)は、`Hash`のインスタンスを作成することで変更
  →デフォルト値を決める場合に便利

* `Hash`のクラスメソッド`[]`を使用することで生成

* `Array#to_h`を使用せいて生成

```ruby
# Hashのインスタンスを作成
>> a = Hash.new(5)
=> {}
>> a[:foo1]
=> 5

# Hashのクラスメソッドを使用
>> a = Hash[:foo1, 1, :foo2, 2, :foo3, 3]
=> {:foo1=>1, :foo2=>2, :foo3=>3}

# Array#to_hを使用
>> a = [[:foo1, 1], [:foo2, 2], [:foo3, 3]].to_h
=> {:foo1=>1, :foo2=>2, :foo3=>3}
```

***

### 3-7-2.ハッシュ引数

* 実引数の最後にハッシュを指定する場合は、その両側の波カッコ`{}`を省略可能
* 最後の引数のみ有効になる

```ruby
>> def foo a, b, c
>>   c
>> end
=> :foo
>> foo(1, 2, :foo=>1, :foo2=>2)      # 両側の波カッコ`{}を省略したもの`
=> {:foo=>1, :foo2=>2}
>> foo(1, 2, {:foo1=>1, :foo2=>2})   # 省略しない場合
=> {:foo1=>1, :foo2=>2}
```

***

## 3-8.範囲

### 3-8-1.範囲リテラル

* 式の間に`..`を記述することで生成
  * 点が2つ`..`： **以下**
  * 点が3つ`...`： **未満** 。ただし、右の値は含む

* 範囲リテラルで生成した値は、 **範囲オブジェクト** と呼ばれる。
  →`Range`クラスのインスタンス

  * `include?`メソッドを使用して、引数で指定した値が範囲に含まれているかどうかを判定可能
  * `==`：同値判定
  * `===`：包括判定

```ruby
>> (1..5).include?(5)   # 1以上5以下なので、5を含む
=> true
>> (1...5).include?(5)  # 1以上5未満なので、5を含まない
=> false
>> (1..5) == 3
=> false
>> (1..5) === 3
=> true
>> (1..5) === 9
=> false
```

***

#### for式に範囲オブジェクトを適用

```ruby
>> for i in "a".."e"
>> p i
>> end
"a"
"b"
"c"
"d"
"e"
=> "a".."e"
```

***

#### 配列の添字演算子に範囲オブジェクトを適用

```ruby
# 配列の添字演算子に範囲オブジェクトを適用
>> a = ["a", "b", "c", "d", "e"]
=> ["a", "b", "c", "d", "e"]
>> p a[2,3]                       # a[2]から3つの要素
["c", "d", "e"]
=> ["c", "d", "e"]
>> p a[2..3]                      # a[2]からa[3]
["c", "d"]
=> ["c", "d"]
>> p a[2...3]                     # a[2]からa[3]、ただし右端の値は含まない      
["c"]
=> ["c"]

# 文字列の添字演算子に範囲オブジェクトを使用
>> a = "abcdef"
=> "abcdef"
>> p a[1]
"b"
=> "b"
>> p a[1..2]   # "abcder"のa[1]からa[2]
"bc"
=> "bc"
>> p a[1...2]  # "abcdef"のa[1]からa[2]、ただし右端の値は含まない
"b"
=> "b"
```

***

### 3-8-2.`case式`

#### `case式`の特徴

* 範囲オブジェクトと関連が強い
* 他のプログラミング言語でいう、`switch文`(swiftなど)

```ruby
case <式>
  when <条件式1> [then]
  when <条件式2> [then]
  else
end
```

***

#### `case式`の例

```ruby
>> case 1
>>   when 1 then
?>    p 1
>> end
1
=> 1

>> case "abc"
>>   when "abc"
>>     p 1
>>   when "abc"
>>     p 2       # こちらは実行されない
>> end
1
=> 1

>> a = 10
=> 10
>> b = case a
>>       when 1 then
?>         1     # こちらは実行されない
>>       else
?>         2
>>     end
=> 2
```

***

#### 複数の条件式の指定

* カンマで区切って複数の条件を指定可能
* `or条件`となり、どれか１つにマッチする時に実行
  →各条件式で指定された値の`===`演算子が、`case`で指定された値を引数として実行

```ruby
>> case 3
>> when 1,2 then; p 1
>> when 3,4 then; p 2  # 実行される
>> else p 3
>> end
2
=> 2
```

***

#### `Range`クラスでの`case式`

```ruby
>> case 7
>> when 1...5 then; p 1
>> when 5..10 then; p 2   # 7を評価すると、trueになるのでこの処理を実行
>> end
2
=> 2
```

***

### 3-8-3.`while式`と`until式`

#### `while式`

* 条件を満たす間、処理を繰り返す
* 構文中の`do`は省略可能

```ruby
# while式
while <条件式> do
    <処理内容>
end

# while式の例
>> i = 0
=> 0
>> while (0..4) === i do  # iが0から4の間のとき
?>   p i
>>   i += 1
>> end                    # 0から4までが順に出力される
0
1
2
3
4
=> nil
```

***

#### `until式`

* 条件を満たすまでループを繰り返す

```ruby
>> i = 0
=> 0
>> until i==5 do   # i=5がtrueになるまで
?>   p i
>>   i += 1
>> end             # 0から4までが順に出力される
0
1
2
3
4
=> nil
```

***

#### 後置

* 最初の`begin節`は、条件に関わらず実行される
* 最初の一回は必ず実行することを強調する際に便利

```ruby
>> i = 0
=> 0
>> begin
?>   p i
>>   i += 1
>> end while(1..4) === i    # 0から4までが順に出力される
0
1
2
3
4
=> nil
```

***

#### while修飾子

* while式と同様に、条件を満たす間、対象の式が評価される

```ruby
>> i = 0
=> 0
>> p i += 1 while(0..4) === i
1
2
3
4
5
=> nil
```

***

## 3-9.正規表現とコマンド出力

### Goldの範囲なので省略

2018/08/19

***

## 3-10.`ブロック`と`Proc`

* 特定のリテラルに依存しない
* クロージャに相当

### 3-10-1.ブロックの基本

* 新たにスコープを作成する(for式、if式、while式はスコープが作成されない)
* メソッドを呼び出すときのみ記述できる
* メソッドの内部では、`yield`という式を使用することで、ブロックの内部で記述した処理を呼び出し可能

```ruby
>> def func x
>>   x + yield    # ブロックの実行結果を取得。(ここでは2)
>> end
=> :func
>> p func(1){ 2 } # ブロック付きメソッドfuncの呼び出し
3
=> 3
```

* `{}`で囲まれている部分が、ブロック
* このブロックは2を返す。メソッド`func`では **ブロックの実行結果** + **引数の合計** より、3が返される

***

#### スコープが作成されるブロック

* ブロックの実行中に、ブロック内での変数xに値を代入すると、ブロックの外とは別の場所に確保される
* ブロックで初期化された変数は、ブロックの処理が終了すると消滅
* 波カッコ`{}`の代わりに、`do 〜　end`で記述可能

```ruby
>> def func y
>>   y + yield
>> end
=> :func
>> func(1) do
?>   x = 2
>> end
=> 3
>> p x
NameError: undefined local variable or method ｀x｀ for main:Object
```

***

#### クロージャとしてのブロック

* スコープを生成することに加えて、ブロック生成時の変数をブロック内で参照可能
* ブロック生成時の変数を更新すると、結果が外部にも影響

```ruby
>> def func y
>>   y + yield
>> end
=> :func
>> x = 2                # ブロックの外で、変数xに値2を代入
=> 2
>> p func(1) {x += 2}   # 代入された値は、メソッド`func`にブロックを渡す
5                       # xの値を取得、更新する
=> 5
>> p x                  # ブロックの外にあるが、更新される
4
=> 4
```

* **値** ではなく、 **変数** そのものが共有される
* ブロック中でxを更新`(x+=2)`すると、xの値が更新
* このような対応付けは、`束縛`という。このような処理の生成時の環境を束縛するものを`クロージャ`という
  →メソッドの内部から外部の変数を参照できないRubyでは、重要

***

### 3-10-2.ブロックのフォーマットと判定

* ブロックは引数を受けることができ、波カッコ`{}`または`do`のあとで、引数リストを`|`で囲む
* これらの実引数は、`yield`で指定可能

```ruby
>> def func a, b
>>   a + yield(b, 3)
>> end
=> :func
>> p func(1, 2){|x,  y| x + y}
6
=> 6
```

1. `func`に1と2を渡す
2. `func`の内部では、第1引数の値1とブロックの実行結果を合計
3. `yield`はブロック引数(2と3)の値を合計して、5を返す
4. **第一引数** + **ブロックの実行結果** より、実行結果は6となる

***

#### ブロックの判定

* `block_given?`メソッド：メソッド内部でブロックが指定されたかどうか判定する
* ブロックが指定された時は、それを活用する処理が記述可能(応用例)

```ruby
>> def func
>>   return 1 if block_given?
>>   2
>> end
=> :func
>> p func(){}      # ブロックが指定された場合は1を返す
1
=> 1
>> p func          # ブロック指定されていない場合は2を返す
2
=> 2
```

***

### 3-10-3.`Proc`

* ブロックをオブジェクトとして扱う際に使用
* `Proc`クラスのコンストラクタに、ブロックを指定することで生成
* 実行するには、`Proc`のインスタンスに対して`call`メソッドを使用

```ruby
>> proc = Proc.new{|x| p x}
=> #<Proc:0x007f9edf0534a0@(irb):1>
>> proc.call(1)
1
=> 1
```

***

#### Procオブジェクトの生成

* 何らかの初期値がプログラムの冒頭で決定、後で操作する
* Procでは、処理自体を生成して遅延評価することができる
  →初期値や現在の値の管理から解放されている

```ruby
>> def get_counter start
>>   Proc.new{|up| start += up}      # Procオブジェクト生成。startには現在の値を管理
>> end
=> :get_counter
>> count_up = get_counter(1)         # 初期値として1を設定。count_upはProcオブジェクトを参照
=> #<Proc:0x007fad7b00ea08@(irb):2>

# ...たくさんの長い処理...

>> count_up.call(1)                  # count_upの参照するブロックを実行
=> 2

# ...たくさんの長い処理...

>> count_up.call(3)                  # count_upの参照するブロックを実行
=> 5
```

***

#### Proc⇄ブロック

* Procオブジェクトに、`&`を付けて最後の引数に指定することで、ブロックへ変換

```ruby
>> def func x
>>   x + yield
>> end
=> :func
>> proc = Proc.new {2}
=> #<Proc:0x007f924303fc78@(irb):4>
>> func(1, &proc)          # procを、&procとして最後の引数に指定
=> 3
```

* ブロックに、最後の引数を`&`を付けた名前を指定することで、引数としてProcオブジェクトを参照

```ruby
>> def func x, &proc
>>   x + proc.call
>> end
=> :func
>> func(1) do
?> 2
>> end
=> 3
```

***

### 3-10-4.`lambda`

Goldの範囲なので省略
2018/08/19

***

### 3-10-5.ブロックを受けるメソッド

* for式、while式はスコープが作成されない為、配列やハッシュの走査にはあまり使われない
* 代わりに、ブロックを受けるメソッドが使われる

***

#### 配列の`each`メソッド

* ブロックの引数には、要素の値が格納される

```ruby
>> [1,2,3].each do |value|
?>   p value
>> end
1
2
3
=> [1, 2, 3]
```

***

#### 配列のインデックスを指定する`each_with_index`メソッド

* ブロックで引数を2つ取ることで、第2引数にインデックスが指定される

```ruby
>> [3,4,5].each_with_index do |value, index|
?>   p value + index   # indexは0、1、2
>> end
3
5
7
=> [3, 4, 5]
```

***

#### ハッシュの`each`メソッド

* キーと値の２つの引数を受ける

```ruby
>> {a:1, b:2}.each do |key, value|
?>   p "#{key}:#{value}"
>> end
"a:1"
"b:2"
=> {:a=>1, :b=>2}
```

***

#### キーのみ、値のみを出力するeachメソッド

* `each_key`メソッド：キーのみ出力
* `each_value`メソッド：値のみ出力

```ruby
# each_keyメソッドの例
>> {a:1, b:2}.each_key do |key|
?> p "#{key}"
>> end
"a"
"b"
=> {:a=>1, :b=>2}

# each_valueメソッドの例
>> {a:1, b:2}.each_value do |value|
?>   p "#{value}"
>> end
"1"
"2"
=> {:a=>1, :b=>2}
```

***

#### 範囲オブジェクトの`each`メソッド

* `Range`クラスでも、`each`メソッドは使用可能

```ruby
>> ("a".."e").each do |value|
?>   p value
>> end
"a"
"b"
"c"
"d"
"e"
=> "a".."e"
```

***

#### 範囲を指定したループ・回数を指定したループ

* `upto`メソッド：範囲を指定した中で、値を増やしていく
* `downto`メソッド：範囲を指定した中で、値を減らしていく
* `times`メソッド：回数を指定してループを実行する

```ruby
# uptoメソッド
>> 2.upto(4) do |i|
?>   p i
>> end
2
3
4
=> 2

# downtoメソッド
>> 5.downto(1) do |i|
?>   p i
>> end
5
4
3
2
1
=> 5

# timesメソッド
>> 4.times do |i|
?>   p i
>> end
0
1
2
3
=> 4
```

***

### 3-10-6.スレッド
### 3-10-7.ファイバ

内容が難しく、理解に苦しむ為、5章が終わり次第
2018/08/19

***

## 3-11.脱出構文と例外処理、大域脱出

* `脱出構文`：ループを抜ける。指定した場合の実行順序が重要。
* `大域脱出`：メソッドを抜ける。構文が重要。

### 3-11-1.脱出構文
Goldの範囲の為、飛ばす
2018/08/19

***

### 3-11-2.例外処理

* 例外を発生させるためには、`raise`を使用
* 第1引数に`例外クラス`or`そのインスタンス`、第2引数に`メッセージ`を指定

```ruby
>> raise ArgumentError, "引数が不正です"
ArgumentError: 引数が不正です

>> raise ArgumentError.new, "引数が不正です"
ArgumentError: 引数が不正です
```

* 例外クラスのコンストラクタでは、メッセージを指定できる

```ruby
>> err = ArgumentError.new("引数が不正です")
=> #<ArgumentError: 引数が不正です>
>> raise err
ArgumentError: 引数が不正です
```

***

#### 引数を省略した場合の例外

* `例外クラス`のインスタンスのみ、あるいは **メッセージ** のみを記述可能
* `例外クラス`のインスタンスを省略した場合は、`RuntimeError`クラスの例外が発生する

```ruby
>> raise "実行中にエラーが発生しました"
RuntimeError: 実行中にエラーが発生しました
```

***

#### 例外処理

* 例外が発生した場合は、そこで処理が中断する
* 処理を中断せずに続行する際に、 **例外処理** を記述する必要がある。
  * 例外が発生する可能性がある箇所を、`begin`と`end`で囲む
  * その中の`rescue`という節で、 **例外処理** を記述する

```ruby
>> begin
?>   1/0
>>   p 1
>> rescue
>>   p 0    # 例外処理。0が出力される
>> end
0
=> 0
```

* `rescue`節に続いて`else`節を指定することで、例外が発生しなかった時の処理を記述できる
* `ensure`節を続けることで、例外の発生に関わらず、必ず実行する処理も記述できる

```ruby
>> begin    # begin節は実行される
?>   p 1
>> rescue   # 例外は発生しないので、実行されない
>>   p 0
>> else     # rescue節が実行されないので、else節は実行される
?>   p 2
>> ensure   # ensure節は必ず実行される
?>   p 3
>> end
1
2
3
=> 2
```

* `rescue`は、`begin`節を指定しなくても使用できる
* `rescue`節は、if式と同様に修飾子として書くこともできる
  →例外が発生すると、`rescue`で指定された式が実行される

```ruby
>> 1 / 0 rescue p 1
1
=> 1

# メソッドの中で指定
>> def foo
>>   -1 / 0
>> rescue    # メソッドの内部で例外が発生すると、rescue以降を実行
>>   p 1
>> end
=> :foo
>> foo
1
=> 1
```

***

### 3-11-3.例外クラスを指定した捕捉

#### 例外クラスの階層構造

* `Exception`
  * `ScriptError`
    * `SyntaxError`：文法エラーがあった場合
  * `SignalException`：捕捉していないシグナルを受けた場合
  * `StandardError`
    * `ArgumentError`：引数の数が合わない場合or値が正しくない場合
    * `RuntimeError`：特定した例外クラスには該当しないエラーが発生した場合or例外クラスを省略した`raise`の呼び出し
    * `NameError`：未定義のローカル変数や定数を参照した場合
      * `NoMethodError`：未定義のメソッドを呼び出した場合
  * `ZeroDivisionError`：整数に対し、整数の0で除算を行なった場合

***

#### 例外オブジェクトの取得

* 各例外クラスを`rescue`に続けて指定することで、それ自身orそのサブクラスを捕捉できる
* 例外クラスに続いて`=>`で識別子を指定すると、例外オブジェクトを参照できる
  * `message`メソッド：指定した例外メッセージを参照
  * `backtrace`メソッド：例外が発生した場所を参照

```ruby
>> begin
?> 1/0
>> rescue ZeroDivisionError => e
>> p e.backtrace
>> end
["(irb):2:in `/'", "(irb):2:in `irb_binding'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/workspace.rb:87:in `eval'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/workspace.rb:87:in `evaluate'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/context.rb:381:in `evaluate'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:493:in `block (2 levels) in eval_input'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:627:in `signal_status'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:490:in `block in eval_input'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/ruby-lex.rb:246:in `block (2 levels) in each_top_level_statement'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/ruby-lex.rb:232:in `loop'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/ruby-lex.rb:232:in `block in each_top_level_statement'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/ruby-lex.rb:231:in `catch'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb/ruby-lex.rb:231:in `each_top_level_statement'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:489:in `eval_input'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:430:in `block in run'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:429:in `catch'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:429:in `run'", "/Users/MacUser/.rbenv/versions/2.4.1/lib/ruby/2.4.0/irb.rb:385:in `start'", "/Users/MacUser/.rbenv/versions/2.4.1/bin/irb:11:in `<main>'"]
```

***

#### 例外の再発生

* 同じスレッドとブロックで発生した最後の例外は、組み込み変数`$!`で参照可能
* さらに、`raise`メソッドを引数なしで実行することで、最後に発生した例外を再度発生させることができる
  →責任範囲でやるべきことを行い、残りを呼び出し先に委ねる場合に便利

```ruby
>> begin
?> 1/0
>> rescue ZeroDivisionError
>> p $!.class
>> raise
>> end
ZeroDivisionError
ZeroDivisionError: divided by 0
```

* 例外処理を呼び出し元に委ねるのではなく、自分で解決する際に`retry`を使用
  * `retry`：再度`begin`節を実行。`ensure`節は1回のみ実行

```ruby
=> 0
>> begin
?>   b = 1/a
>> rescue ZeroDivisionError
>>   a += 1
>> retry
>> ensure    # 必ず行われる部分
?>   p b
>> end
1
=> 1
```

***

#### `ensure`節の実行順

* `rescue`節は１つの`begin`節の中でいくつでも指定可能
* ただし、最初にマッチしたものしか実行されない
* より範囲の狭い例外クラスを指定しても、役に立たないことが多いので、 **マッチする範囲が広くなる順に指定する**

```ruby
>> begin 1/0
>> rescue     # 最初にマッチしたもの、出力される
>>   p 1
>> rescue ZeroDivisionError
>>   p 2
>> end
1
=> 1
```

***

### 3-11-4.`catch/throw`による大域脱出

Goldの範囲なので、カット
2018/08/19

***

|初版|2018/08/19|
|---|---|---|
