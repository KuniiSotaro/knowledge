3-9.正規表現とコマンド出力
======================

## 正規表現

* 文字列のパターンを記述するための言語

* この言語で記述されたパターンも正規表現と呼ぶ

* Rubyで正規表現を扱うためのクラスは`Regexp`クラス（Regexp = Regular Expression)

***

### 正規表現の作り方

* `""`では文字列が生成されるのと同じように、`/`で囲むことで正規表現オブジェクトができる

* `%r()`を指定することで、生成可能

* `Regexp.new`でも生成できる

```ruby
>> /ruby/
=> /ruby/
>> %r(ruby)
=> /ruby/
>> Regexp.new "Ruby"
=> /Ruby/
>> /ruby/.class
=> Regexp
```

***

### 正規表現の見つけ方

* `===`オブジェクトでは、指定した文字列とマッチしているかどうかを論理値で返すように、
  条件式に正規表現オブジェクトを指定することで、評価式で指定された文字列がマッチした時の処理を記述可能

```ruby
>> /Ruby/ === "I love Ruby"
=> true
>> p case "I love Ruby"
>>     when /Ruby/ then; "Ruby!"
>>     when /Java/ then; "Java!"
>>   end
"Ruby!"
=> "Ruby!"
```

* `=~`演算子を用いることで、正規表現と文字列がマッチした場合に、マッチした文字列のインデックスを返す。マッチしなかった場合は、`nil`を返す
  `String`クラスでも定義されているので、両者を入れ替えても同じ結果となる

```ruby
>> /Ruby/ =~ "I love Ruby"
=> 7
>> "I love Ruby" =~ /Ruby/
=> 7
```

* マッチした文字列を取り出すには、`=~`演算子と同じスコープの組み込み変数`$&`を参照する

* マッチした文字列より **前の文字列** を参照するには、`$(バッククオート)`を使用

* マッチした文字列より **後の文字列** を参照するには`$(シングルクオート)`を使用

```ruby
>> /bb/ =~ "aabbcc"
=> 2
>> p $`
"aa"
=> "aa"
>> p $&
"bb"
=> "bb"
>> p $'
"cc"
=> "cc"
```

* `^`：行頭を表す

* `$`：行末を表す

* `|`：並列の条件を表す。優先度が低いので、選択のパターンを`()`で囲む必要がある

```ruby
>> reg = /^(aa|bb)c$/
=> /^(aa|bb)c$/
>> reg === "aac"
=> true
>> reg === "bbc"
=> true
>> reg === "abc"
=> false
```

* `[]`：文字の集合を指定できる。いずれか1文字を表す文字クラスを作る

```ruby
>> reg = /a[bcd]e[fg]h/
=> /a[bcd]e[fg]h/
>> reg === "abegh"
=> true
>> reg === "abcdefgh"
=> false
```

***

### 正規表現記号

* `-`：`[]`内で使われると、文字の範囲を表す

```ruby
>> /a[1-5]z/ === "a2z"
=> true
>> /a[b-d]z/ === "abz"
=> true
```

* `.`：任意の一文字(改行を除く)。mオプションがある場合は、改行もマッチ

```ruby
>> /./ =~ "\nRuby"    # 改行を無視して、一番目の"R"にマッチする
=> 1
>> /./ =~ "\n\n1234"  # 改行を無視して、一番目の"1"にマッチする
=> 2
>> /./m =~ "\nRuby"   # mオプションがあると、一番目の改行もマッチする
=> 0
```

* `\d`：0〜9までの数字1文字にマッチ

* `\D`：0〜9までの数字以外の文字にマッチ

```ruby
>> /\d/ =~ "\t\s\n\r\f_Ruby2.1"  # 10番目の"2"にマッチ
=> 10
>> /\D/ =~ "1234567890"          # 数字以外の文字がないので、nil
=> nil
>> /\D/ =~ "12345t67890"         # 5番目にtがあるので、マッチ
=> 5
```

* `\w`：英数字とアンダースコアにマッチ

* `\W`：英数字とアンダースコア以外の文字にマッチ

```ruby
>> /\w/ =~ "\t\s\n\r\f_RubyExamination"    # 5番目に、"_"にマッチ
=> 5
>> /\W/ =~ "RubyExamination_1234567890"    # 英数字とアンダースコア以外の文字が存在しない
=> nil
>> /\W/ =~ "RubyExamination_1234567890\n"  # 26番目に、"\n"にマッチ
=> 26
```

* `\s`：空白文字にマッチ(`\t`、`\n`、`\r`、`\f`)

* `\S`：空白文字以外の文字にマッチ(`\s`以外の一文字)

```ruby
>> /\s/ =~ "\nRuby"   # 0番目に空白文字("\n")とマッチ
=> 0
>> /\S/ =~ "\nRuby"   # 1番目に空白文字以外とマッチ
=> 1
```

* `\A`：文字列の先頭。改行の有無に影響されない。(`^`とは違い、改行の直後の文字ではない文字にマッチする)

* `\z`：文字列の末尾。改行の有無に影響されない

* `\Z`：文字列の末尾。改行で終わっていればその改行にマッチする

```ruby
>> /\Aa/ =~ "asdfg"
=> 0
>> /\Z/ =~ "asdf\n"
=> 4
>> /\z/ =~ "asdf\n"
=> 5
```

#### 繰り返しを表現する正規表現記号

* `*`：直前の文字やパターンが0回以上連続する

```ruby
>> /a(bc)*d/ === "abcbcd"   # (bc)*は、bcの0回以上の繰り返し
=> true
>> /a(bc)*d/ === "ad"
=> true
```

* `+`：直前の文字やパターンが1回以上連続する

```ruby
>> /a(bc)+d/ === "abcbcd"
=> true
>> /a(bc)+d/ === "ad"
=> false
```

* `?`：直前の文字やパターンが1回、もしくは0回現れる

```ruby
>> /a(bc)?d/ === "abcbcd"
=> false
>> /a(bc)?d/ === "abcd"
=> true
```

* `{m}`：直前の文字のm回繰り返し

```ruby
>> /a{2}b/ === "aab"
=> true
```

* `{m,}`：直前の文字の最低m回の繰り返し

```ruby
>> /a{2,}b/ === "aab"
=> true
>> /a{2,}b/ === "aaab"
=> true
>> /a{2,}b/ === "ab"
=> false
```

* `{m,n}`：直前の文字の最低m回、最高n回の繰り返し

```ruby
>> /a{2,3}b/ === "ab"
=> false
>> /a{2,3}b/ === "aaab"
=> true
```

***

### 正規表現の参照

`()`でグループ化した正規表現にマッチした結果は、特殊変数`$1`、`$2`、`$3`、・・・、`$n`といった`$数字`で取り出すことができる

→ **正規表現の後方参照**

* `$1`：1番目の正規表現グループにマッチした文字列を保持する。

* `$2`：2番目の正規表現グループにマッチした文字列を保持する。以降同様

* 対応する正規表現グループがない場合には、`nil`を保持する

```ruby
>> %r|(http://www(\.)(.*)/)| =~ "http://www.xyz.org/"
=> 0
>> p $1                   # http://wwwで始まる
"http://www.xyz.org/"
=> "http://www.xyz.org/"
>> p $2                   # wwwの次のピリオド
"."
=> "."
>> p $3                   # www.の次の任意の文字の0個以上の繰り返し
"xyz.org"
=> "xyz.org"
>> p $4                   # 対応する正規表現グループなし
nil
=> nil
>> $0        # スクリプト名を保持する(正規表現とは関係ない)
=> "irb"
```

***

### 正規表現のオプション

* `i`：大文字と小文字の区別をしない

```ruby
>> /ruby/i === "RUBY"
=> true
```

* `o`：一度だけ式展開を行う

* `x`：パターン中の空白と改行を無視する。また、`#`以降をコメントとして無視する

* `m`：正規表現記号`.`が改行にもマッチする

```ruby
>> /a.*b/ === "a\nb"
=> false
>> /a.*b/m === "a\nb"
=> true
```

***

## コマンド出力

* バッククオート「｀」で囲まれた文字列は、コマンドとして解釈されてOSに渡され、実行される

* 結果(標準出力)は、文字列で返る

* 標準出力ではなく、終了ステータスを確認するときは`$?`を参照する

* 式展開とバックスラッシュ記法が適用できる

* パーセント記法も使用でき、`%x`を記述する

```ruby
>> puts `date +%Y/%m/%d`
2018/10/21
=> nil
pid 13615 exit 1  # 先ほどサーバーを落としたので
=> nil
```
