3章 制御構造 メソッド 組み込み関数
=============================

## 3-2.基本的な制御構造

## 3-2-5.プログラムの終端を明示する

* `__END__`：ファイルの途中でプログラムの終端を明示する

  これ以降はRubyプログラムとして実行されることはない

* `__END__`の次の行以降のデータは、`DATA`という定数にFileオブジェクトとして保持されており、実行時に参照可能

* `__END__`キーワードがなければ、定数`DATA`は定義されない

```ruby
DATA.each_line do |line|
  puts line
end

__END__
いろはにほへと
ちりぬるを

# 実行結果
いろはにほへと
ちりぬるを
```



## 3-3.例外処理

## 3-3-1.例外の発生とクラス

![Excerptionを継承した例外クラス](./images/Excerptionを継承した例外クラス.png)



## 3-3-2.例外を制御する

### `Kernel.#raise`

* 例外を発生させる

* 第1引数に文字列を指定した場合は、それを例外のメッセージとして例外RuntimeErrorを発生させる

```ruby
>> raise 'error!'
RuntimeError: error!
```

* 第1引数には、例外クラスも指定できる。その場合は、例外メッセージは第2引数に指定する

```ruby
>> raise StandardError, 'error!'
StandardError: error!
```

* 例外を捕捉するには、例外の発生する可能性のある式を`begin`の中に記述する

* 発生した例外はrescue節で捕捉できる

* rescue節で`=> e`と変数を指定することで、捕捉した例外オブジェクトが変数`e`に代入される

```ruby
>> begin
>>   do_process    # 例外が発生する可能性のある何らかの処理
>> rescue => e
>>   puts "Error occurred #{e.class}"
>> end
Error occurred NameError
=> nil
```

* 例外オブジェクトには、

  * `Excerption#message`：例外についての人間が読める形式の詳細なメッセージを文字列で返す

    -> `raise`に渡された例外メッセージは、このメソッドで取り出せる

  * `Excerption#backtrace`：例外が発生した時点のコールスタック(プログラムで実行中のサブルーチンに関する情報を格納するスタック)を配列で返す

```ruby
>> e.class
=> NameError
>> e.message
=> "undefined local variable or method `do_process' for main:Object"
>> e.backtrace
=> ["(irb):2:in `irb_binding'",
```

* 配列の要素には、以下の形式の文字列が格納されている

```ruby
ファイル名:行番号:in 'メソッド名'
```
