goldで間違えた問題
================


# 可長変引数

## 以下のコードを実行すると何が表示されますか

> 正解したけど、念のため
>
> 2018/11/07

```ruby
>> x, *y = *[0, 1, 2]
=> [0, 1, 2]
>> p x, y
0
[1, 2]
=> [0, [1, 2]]
```



### 解説

多重代入の問題

右辺の「`*`」は無視して良い

左辺の`x`には、配列の最初の要素が格納される

`y`には「`*`」がついているので、残りの要素が配列として代入される



## 次のコードを実行するとどうなりますか

キーワード引数へHashオブジェクトを渡すことができます。

Hashの中身を渡す必要があるので、変数の前に`**`を付加します。

> `*`は、Arrayオブジェクトとして渡される

```ruby
>> def foo(arg1:100, arg2:200)
>>   puts arg1
>>   puts arg2
>> end
=> :foo
>>
>> option = {arg2: 900}
=> {:arg2=>900}
>>
>> foo arg1: 200, *option
SyntaxError: (irb):8: syntax error, unexpected *
```



## 次のコードを実行するとどうなりますか

```ruby
>> def foo(arg1:100, arg2:200)
>>   puts arg1
>>   puts arg2
>> end
=> :foo

>> option = {arg2: 900}
=> {:arg2=>900}

>> foo arg1: 200, *option
SyntaxError: (irb):8: syntax error, unexpected *
```

キーワード引数へHashオブジェクトを渡すことができます。

Hashの中身を渡す必要があるので、変数の前に`**`を付加します。

```ruby
>> def foo(arg1:100, arg2:200)
>>   puts arg1
>>   puts arg2
>> end
=> :foo

>> option = {arg2: 900}
=> {:arg2=>900}

>> foo arg1: 200, **option    # 変数の前のオペランドを`**`に変更
200
900
=> nil
```



## 次のコードを実行するとどうなりますか

```ruby
>> def foo(arg1:100, arg2:200)
>>   puts arg1
>>   puts arg2
>> end
=> :foo

>> option = {arg2: 900}
=> {:arg2=>900}

>> foo arg1: 200, *option
SyntaxError: (irb):8: syntax error, unexpected *
```

キーワード引数へHashオブジェクトを渡すことができます。

Hashの中身を渡す必要があるので、変数の前に`**`を付加します。

```ruby
>> def foo(arg1:100, arg2:200)
>>   puts arg1
>>   puts arg2
>> end
=> :foo

>> option = {arg2: 900}
=> {:arg2=>900}

>> foo arg1: 200, **option    # 変数の前のオペランドを`**`に変更
200
900
=> nil
```



## 以下のコードを実行するとどうなりますか

```ruby
>> def hoge(*args, &block)
>>   block.call(*args)
>> end
=> :hoge

>> hoge(1,2,3,4) do |*args|
>>   p args.length > 0 ? "hello" : args
>> end
"hello"
=> "hello"
```



### 解説

問題のソースコード

```ruby
1: def hoge(*args, &block)
2:   block.call(*args)
3: end
4:
5: hoge(1,2,3,4) do |*args|
6:   p args.length > 0 ? "hello" : args
7: end
```

1行目で引数の値を配列として受け取り、ブロックに配列を渡しています。

2行目で`*`を付けて引数を渡しているので、配列が展開されます`(1, 2, 3, 4)`。

5行目でブロック変数を渡していますが、`*args`と宣言されているので、`[1, 2, 3, 4]`が渡されます。

6行目で`args.length > 0`の結果は真となり、`hello`が出力されます。



## 以下の実行結果になるように、`__X__`に記述する適切なコードを選びなさい

```ruby
def hoge(*args)
  p __X__
end
hoge [1, 2, 3]

# 実行結果
[1, 2, 3]
```

1. `args`

1. `*args`

1. `&args`

1. `$args`



### 解説

「`*`」の付いたメソッド引数は、可長変引数となる

`hoge`の引数`args`は配列として扱われる

`hoge`に配列`[1, 2, 3]`を渡すと、`args[0]`に渡される

したがって、実行結果を`[1, 2, 3]`にするには、

* `args[0]`

* `*args`

にする

```ruby
>> def hoge(*args)
>>   p *args
>> end
=> :hoge
>> hoge [1, 2, 3]
[1, 2, 3]
=> [1, 2, 3]
```



## 以下の実行結果になるように、`__X__`に記述する適切なコードを選びなさい

> 正解しているが、念のため
>
> 2018/11/07

```ruby
def hoge __X__
  puts "#{x}, #{y}, #{params[:z]}"
end

hoge x: 1, z: 3

# 実行結果
1, 2, 3
```

1. `(x:, y: 2, params: *)`

1. `(x:, y: 2, *params)`

1. `(x:, y: 2, **params)`

1. `(x:, y: 2, params: **)`



### 解説

キーワード引数の中で任意の値を受け取れるようにしたい場合は、`**params`のように引数の前に`**`を繋げることで、

明示的に定義したキーワード以外の引数をHashオブジェクトで受け取ることができる

```ruby
>> def hoge (x:, y: 2, **params)
>>   puts "#{x}, #{y}, #{params[:z]}"
>> end
=> :hoge

>> hoge x: 1, z: 3
1, 2, 3
=> nil
```



### 参考

```ruby
# 配列展開なし
>> hoge(1,2,3,4) do |*args|
?> p args
>> end
[1, 2, 3, 4]
=> [1, 2, 3, 4]

# 配列展開あり
>> hoge(1,2,3,4) do |*args|
?> p *args
>> end
1
2
3
4
=> [1, 2, 3, 4]
```









# 例外処理

## 次のコードを実行するとどうなりますか

`String#+`は`String`クラスのオブジェクトを期待します。

引数に`Symbol`クラスを渡しているため`TypeError`が発生します。

> `else`ブロックは例外が発生しない場合に評価されます。
>
> 優先順位は、「エラー名指定のrescue」>「エラー名指定なしのrescue」

```ruby
>> begin
>>   print "liberty" + :fish
>> rescue TypeError
>>   print "TypeError."
>> rescue
>>   print "Error."
>> else
>>   print "Else."
>> end
TypeError.=> nil

# 検証
>> begin
>>   print "liberty" + :fish
>> rescue
>>   print "Error."
>> else
>>   print "Else."
>> end
Error.=> nil
```



## 次のコードを実行するとどうなりますか

```ruby
>> begin
>>   print "liberty" + :fish.to_s
>> rescue TypeError
>>   print "TypeError."
>> rescue
>>   print "Error."
>> else
>>   print "Else."
>> ensure
>>   print "Ensure."
>> end
libertyfishElse.Ensure.=> nil
```



### 解説

* `:fish`はSymbolクラスのオブジェクトです。

  `Symbol#to_s`でStringオブジェクトが返されます。

* `String#+`の引数はStringクラスを期待します。

  Stringクラス以外のオブジェクトが渡された場合は、`TypeError`を発生させます。

* エラーを受け取るためには`rescue`で、例外を受け取った際の処理を記述します。

* エラーが発生しなかった場合の処理を行うには`else`を用います。

* エラー発生有無に関わらず、必ず実行される、後処理を行うには`ensure`を用います。

> `print`は、改行をせずに出力する！！



## 次のコードを実行するとどうなりますか

引数なしで`raise`を呼び出すと、`RuntimeError`例外が発生します。

```ruby
>> begin
>>   raise
>> rescue => e
>>   puts e.class
>> end
RuntimeError
=> nil
```



## 次のコードを実行するとどうなりますか

`raise`の例外クラスを省略した場合は、`RuntimeError`を発生させます。

`rescue`の例外クラスを省略した場合は、`StandardError`を捕捉します。

`RuntimeError`は`StanderdError`のサブクラスです。

```ruby
>> begin
>>   raise "Err!"
>> rescue => e
>>   puts e.class
>> end
RuntimeError
=> nil
```



## 以下のコードを実行するとどうなりますか

> 正解したけど、念のため
>
> 2018/11/07

```ruby
>> class Err1 < StandardError; end
=> nil
>> class Err2 < Err1; end
=> nil

>> begin
>>   raise Err2
>> rescue => e
>>   puts "StandardError"
>> rescue Err2 => ex
>>   puts ex.class
>> end
StandardError
=> nil
```



### 解説

begin節の`raise`で発生する例外オブジェクトのクラスはErr2

2個目のrescue節ではErr2、もしくはErr2を継承した例外オブジェクトを対象とするように書かれているが、

1個目のrescue節でStandardErrorから派生する全ての例外を対象とするため、

2個目のrescue節では処理されず、1個目のrescue節で処理される























# 型が異なるもの同士の計算

## 次のコードを実行するとどうなりますか

`1i`は複素数(Complex)のオブジェクトを表します。

Complex同士の演算はComplexを返します。

```ruby
>> val = 1i * 1i
=> (-1+0i)
>> puts val.class
Complex
=> nil
```



## 次のコードを実行するとどうなりますか

> 正解したが、念のため
>
> 2018/11/03

```ruby
>> val = 1 + 1/2r
=> (3/2)
>> puts val.class
Rational
=> nil
```



### 解説

`1/2r`はRationalのインスタンスが作成されます。

FixnumとRationalの演算はRationalになります。

(Ruby 2.4からFixnumとBignumが統合されIntegerになりました)

その他のクラス演算を以下にまとめます。

|         演算         |戻り値クラス|
|---------------------|-----------|
|FixnumとRationalの演算 | Rational |
| FloatとRationalの演算 |   Float  |
| FixnumとComplexの演算 |  Complex |
|  FloatとComplexの演算 |  Complex |
|     Date同士の減算    |  Rational |
|     Time同士の減算    |   Float   |
|   DateTime同士の減算  |  Rational |



## `__X__`に記述すると、以下の実行結果にならないコードを全て選びなさい

> 正解したけど、念のため
>
> 2018/11/07

```ruby
puts __X__

#
# 実行結果
#
0.8
```

1. `4 / 5`

1. `4.0 / 5`

1. `4/5r`

1. `4 / 5.0`



### 解説

整数(Integer)同士の演算は整数となり、小数点以下は丸められる

選択肢1の結果は`0`

選択肢3の`4/5r`はRationalクラスのオブジェクトを生成し、`(4/5r).to_f`とすれば`0.8`となるが、

そのままでは`(4/5)`と出力される




## 次のコードを実行するとどうなりますか。

```ruby
>> v1 = 1 / 2 == 0
=> true
>> v2 = !!v1 or raise RuntimeError
=> true
>> puts v2 and false
true
=> nil
```



### 解説

```ruby
1: v1 = 1 / 2 == 0
2: v2 = !!v1 or raise RuntimeError
3: puts v2 and false
```

#### 1行目

Fixnumクラス同士の除算はFixnumクラスになります。

よって、`0 == 0`が評価され、`v1`はtrueになります。

```ruby
>> 1 / 2      # Fixnumクラス(trueになる)
=> 0
>> 1.0 / 2.0  # Floatクラス(falseになる)
=> 0.5
```

#### 2行目

`or`は左辺が真であればその結果を返します。この時、右辺は評価されません。

左辺が偽であれば、右辺を評価しその結果を返します。

また、`or`は評価する優先順位が低い演算子です。

よって、優先順位が低いので`v2`には`!!v1`の結果のtrueが入ります。

次に、`!!v1 or raise RuntimeError`が評価され、左辺が真であるため、左辺のみ評価されます。

```ruby
>> v1 = 1 / 2 == 0
=> true
>> !v1
=> false
>> !!v1
=> true
```


#### 3行目

`and`は左辺が真であれば、右辺の結果を返します。左辺が偽であれば、左辺の結果を返します。

また、`and`は評価する優先順位が低い演算子です。

よって、優先順位が低いので`puts v2`が評価されます。


演算子の優先順位を適切にするためには、括弧で式を区切ります。



## 次のコードを実行するとどうなりますか

```ruby
>> class Integer
>>   def +(other)
>>     self.-(other)
>>   end
>> end
=> :+

>> p 1 + 1
0
=> 0
```

数値はFixnumクラスのオブジェクトです。FixnumクラスはIntegerクラスのサブクラスです。

問題では、Integerクラスへ`+`メソッドをオープンクラスし、オーバーロードているように取れます。

しかし、`+`メソッドはFixnumクラスで定義されています。

よって、元の`Fixnum#+`が呼ばれます。

```ruby
>> p 1.class.ancestors
[Integer, Numeric, Comparable, Object, Kernel, BasicObject]
=> [Integer, Numeric, Comparable, Object, Kernel, BasicObject]
>> p Numeric.method_defined?(:+)
false
=> false
>> p Integer.method_defined?(:+)
true
=> true
>> p Fixnum.method_defined?(:+)
(irb):-7: warning: constant ::Fixnum is deprecated
true
=> true
```




## 次のコードを実行するとどうなりますか

```ruby
require 'date'

d = Date.today - Date.new(2015,10,1)
p d.class
=> Rational
```

Dateクラス同士の減算はRationalになります。

その他、似たクラスの演算を以下にまとめます。

|        演算       | 戻り値クラス |
|------------------|------------|
|  `Date`同士の減算  | `Rational` |
|  `Time`同士の減算  |   `Float`  |
|`DateTime`同士の減算| `Rational` |













# オプション

## Rubyで使用可能なオプションではないものを選択しなさい(複数)。

> かなり覚える量が多いので、一回ストップ
>
> 2018/11/02

1. `-t`：存在しない

2. `-l`：行末の自動処理を行います。各行の最後に`String#chop!`を実行。

3. `-p`：`-n`と同じだが`$_`を出力

4. `-f`：存在しない



## Rubyの`-l`オプションの説明として正しいものを全て選びなさい

1. 引数で指定したディレクトリを`$LOAD_PATH`変数に追加する

1. 引数で指定したファイルを読み込む

1. 引数で指定したディレクトリを環境変数`LUBYLIB`に追加する

1. 引数で指定したディレクトリは`require`や`load`メソッドが呼ばれた時に検索される



### 解説

`-l`は、ファイルをロードするパスを指定するオプション

指定したディレクトリは`$LOAD_PATH`変数(`$:`)に追加される

環境変数の`RUBYLIB`に指定したパスも同様に`$LOAD_PATH`変数にパスを追加するが、`-l`オプションで指定したパスが

直接`LUBYLIB`に追加されることはない

2の引数で指定したファイルを読み込むのは、`-r`オプション











































# 正規表現

## 次のコードを実行するとどうなりますか

```ruby
>> p "Matz is my tEacher".scan(/[is|my]/).length
4
=> 4
```

問題で使用されている正規表現の説明は下記の通りです。

  * `String#scan`はマッチした部分文字列を配列で返します。

  * 正規表現の`[]`は囲まれた`*`文字`*`1つ1つにマッチします。

  * `|`は正規表現ではORのメタ文字です。

  * 今回は、`|`が`[]`に囲まれているため、これもマッチ対象になります。

問題のコードで`scan(/[is|my]/)`が返す配列は`["i", "s", "m", "y"]`になります。

```ruby
>> p "Matz is my tEacher".scan(/[is|my]/)
["i", "s", "m", "y"]
=> ["i", "s", "m", "y"]
```



## 次のコードを実行するとどうなりますか

```ruby
>> p "Matz is my tEacher"[/[a-z][A-Z].*/]
"tEacher"
=> "tEacher"
```

スラッシュ(/)で囲まれた文字列は正規表現と扱われます。

問題では、文字列からString#[]で正規表現を用いて部分文字列を抜き取ります。

問題の正規表現`/[a-z][A-Z].*/`を分解すると以下の意味になります。

  * `[a-z]`：1文字目が小文字英字

  * `[A-Z]`：2文字目が大文字英字

  * `.*`：任意の1文字が0回以上繰り返す

以上に該当する部分文字列が表示されます。



## 以下のコードについて適切な記述はどれですか

```ruby
%r|(http://www(\.)(.*)/)| =~ "http://www.abc.com/"
```

1. `$0`の値は、nilである

1. `$1`の値は、`http://www`である

1. `$2`の値は、`.abc`である

1. `$3`の値は、`abc.com`である



### 解説

`$0`はスクリプトのファイル名

`$1`、`$2`...はそれぞれグループ化された正規表現にマッチした文字列になる

```ruby
>> %r|(http://www(\.)(.*)/)| =~ "http://www.abc.com/"
=> 0

#
# 選択肢1
#
>> $0
=> "irb"

#
# 選択肢2
#
>> $1
=> "http://www.abc.com/"

#
# 選択肢3
#
>> $2
=> "."

#
# 選択肢4
#
>> $3
=> "abc.com"
```










# 分類分けしにくいやつ

## 次のコードを実行するとどうなりますか

問題の`self`は`Object`クラスのインスタンスになります。

`Object`クラスには`*`メソッドが定義されていないためエラーになります。

```ruby
>> p [1,2,3,4].map(&self.method(:*))
NameError: undefined method `*' for class `#<Class:#<Object:0x007fc6a60da4c0>>'

# 検証
>> Object.instance_methods.grep(/ * /)
=> []
```


## 次のコードを実行するとどうなりますか

```ruby
while not DATA.eof?
  print DATA.read 1
end

__END__
1
2
3
4

# 実行結果
1
2
3
4
```



### 解説

`__END__`以降をファイルとして扱います。

このファイルにアクセスするためには、FileクラスのオブジェクトのDATAを用います。

`File#read(length = nil, outbuf = "")`は`length`を指定すると、そのバイト数分文字列を読み込みます。

省略した場合は、ファイルの終端まで全て読み込みます。



## 次のコードを実行するとどうなりますか。

```ruby
>> 10.times{|d| print d < 2...d > 5 ? "O" : "X" }
OOOOOOOXXX=> 10
```



### 解説

`Integer#times`は`0`から`self -1`までの数値を順番にブロックに渡すメソッドです。

`d < 2...d > 5`の部分は条件式に範囲式を記述しています。

この式は、フリップフロップ回路のように一時的に真偽を保持するような挙動をとります。

> わからないので、パス
>
> 2018/11/10



## 以下の実行結果になるように、`__X__`と`__Y__`に記述する適切なコードを選びなさい

```ruby
a, b = __X__ do
  for x in 1..10
    for y in 1..10
      __Y__ if x + y == 10
    end
  end
end

puts a, b

# 実行結果
1
9
```

* 選択肢1

  ```ruby
  __X__: loop
  __Y__: break
  ```

* 選択肢2

  ```ruby
  __X__: catch
  __Y__: throw [x, y]
  ```

* 選択肢3

  ```ruby
  __X__: catch
  __Y__: break [x, y]
  ```

* 選択肢4

  ```ruby
  __X__: catch :exit
  __Y__: throw :exit, [x, y]
  ```



### 解説

`throw`メソッドを呼ぶと、第1引数で指定した`tag`のあるcatchブロックの終わりまでジャンプします。

この時、`throw`メソッドの第2引数に渡した値が`catch`メソッドの戻り値になる

```ruby
>> a, b = catch :exit do
>>   for x in 1..10
>>     for y in 1..10
>>       throw :exit, [x, y]if x + y == 10
>>     end
>>   end
>> end
=> [1, 9]

>> puts a, b
1
9
=> nil
```





| 版 | 年/月/日  |
|---|----------|
|初版|2018/11/10|
