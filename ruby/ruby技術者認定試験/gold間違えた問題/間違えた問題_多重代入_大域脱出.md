間違えた問題 多重代入 大域脱出
=========================

## 次のコードを実行するとどうなりますか

問題の`self`は`Object`クラスのインスタンスになります。

`Object`クラスには`*`メソッドが定義されていないためエラーになります。

```ruby
>> p [1,2,3,4].map(&self.method(:*))
NameError: undefined method `*' for class `#<Class:#<Object:0x007fc6a60da4c0>>'

# 検証
>> Object.instance_methods.grep(/ * /)
=> []
```


## 次のコードを実行するとどうなりますか

```ruby
while not DATA.eof?
  print DATA.read 1
end

__END__
1
2
3
4

# 実行結果
1
2
3
4
```



### 解説

`__END__`以降をファイルとして扱います。

このファイルにアクセスするためには、FileクラスのオブジェクトのDATAを用います。

`File#read(length = nil, outbuf = "")`は`length`を指定すると、そのバイト数分文字列を読み込みます。

省略した場合は、ファイルの終端まで全て読み込みます。



## 次のコードを実行するとどうなりますか。

```ruby
>> 10.times{|d| print d < 2...d > 5 ? "O" : "X" }
OOOOOOOXXX=> 10
```



### 解説

`Integer#times`は`0`から`self -1`までの数値を順番にブロックに渡すメソッドです。

`d < 2...d > 5`の部分は条件式に範囲式を記述しています。

この式は、フリップフロップ回路のように一時的に真偽を保持するような挙動をとります。

> わからないので、パス
>
> 2018/11/10



## 以下の実行結果になるように、`__X__`と`__Y__`に記述する適切なコードを選びなさい

```ruby
a, b = __X__ do
  for x in 1..10
    for y in 1..10
      __Y__ if x + y == 10
    end
  end
end

puts a, b

# 実行結果
1
9
```

* 選択肢1

  ```ruby
  __X__: loop
  __Y__: break
  ```

* 選択肢2

  ```ruby
  __X__: catch
  __Y__: throw [x, y]
  ```

* 選択肢3

  ```ruby
  __X__: catch
  __Y__: break [x, y]
  ```

* 選択肢4

  ```ruby
  __X__: catch :exit
  __Y__: throw :exit, [x, y]
  ```



### 解説

`throw`メソッドを呼ぶと、第1引数で指定した`tag`のあるcatchブロックの終わりまでジャンプします。

この時、`throw`メソッドの第2引数に渡した値が`catch`メソッドの戻り値になる

```ruby
>> a, b = catch :exit do
>>   for x in 1..10
>>     for y in 1..10
>>       throw :exit, [x, y]if x + y == 10
>>     end
>>   end
>> end
=> [1, 9]

>> puts a, b
1
9
=> nil
```



## 以下のコードを実行するとどうなりますか

> 正解しているけど、念のため
>
> 2018/11/11

```ruby
>> ary = Array.new(3, "a")
=> ["a", "a", "a"]
>> ary[0].next!
=> "b"
>> p ary
["b", "b", "b"]
=> ["b", "b", "b"]
```



### 解説

`Array.new(3, "a")`は、サイズ3の配列を生成し、文字列オブジェクト"a"を全ての要素に設定する

文字列オブジェクト"a"はコピーされるのではなく、全て同一のオブジェクト

-> 配列の要素は、全て同一の文字列オブジェクト"a"を参照する

従って、１つの要素を変更すると、全ての要素が変更される



## 以下のコードで、case文の比較に使用されている演算子はどれですか

> 正解だったが、念のため
>
> 2018/11/11

```ruby
a = [1, "Hello", false]
a.each do |x|
  puts case x
       when String then "string"
       when Numeric then "number"
       when TrueClass, FalseClass then "boolean"
       end
end
```

1. `=`

1. `==`

1. `===`

1. `class`



### 解説

case文の比較には、`===`を使用する



## 以下のコードと同じ実行結果になるコードはどれですか

```ruby
>> a, b = [1, 2]
=> [1, 2]

# 解説
>> a
=> 1
>> b
=> 2
```

1. 選択肢1

  ```ruby
  a=[1,2]
  b=[]
  ```

1. 選択肢2

  ```ruby
  a=1
  b=2
  ```

1. 選択肢3

  ```ruby
  a=[1,2]
  b=nil
  ```

1. 選択肢4

  ```ruby
  a=nil
  b=[1,2]
  ```



### 解説

配列の多重代入の問題

左辺には、右辺の同じ位置にある値が代入される



## 以下の実行結果になるように、`__X__`に記述する適切なコードを全て選びなさい。(複数選択)

```ruby
x = ["abc","defgk","lopq"]
p x.sort{ |a, b| __X__ }

# 実行結果
["abc","lopq","defgk"]
```

1. `a<=>b`

1. `b<=>a`

1. `a.size <=> b.size`

1. `b.size <=> a.size`

1. `a.size - b.size`

1. `b.size - a.size`



### 解説

`sort`は、ブロック引数内に比較のアルゴリズムを記述する

演算子`<=>`は、両オペランドの大小を比較する

* 左オペランドが右オペランドよりも小さい場合は、負の値

* 等しい場合は、`0`

* 左オペランドが右オペランドよりも大きい場合は、正の値

を返す



## 以下のコードを実行した結果はどうなりますか。

```ruby
a, b, c = [1, 2]
p a
p b
p c

# 実行結果
1
2
nil
```



### 解説

多重代入において、左辺の要素数が右辺よりも多い場合、余った左辺の要素にはnilが代入される
