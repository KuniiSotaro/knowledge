間違えた問題 オブジェクト指向
========================

# レキシカルスコープ


## 次のプログラムは"Hello, world"と表示します。同じ結果になる選択肢はどれですか（複数選択）

```ruby
>> module M
>>  CONST = "Hello, world"
>>
>>  class C
>>    def awesome_method
>>      CONST
>>    end
>>  end
>> end
=> :awesome_method
>>
>> p M::C.new.awesome_method
"Hello, world"
=> "Hello, world"
```

![問題1](./images/gold/問題1.png)



### 選択肢1

定数の参照はレキシカルに行われます。

`M::C#awesome_method`のコンテキスト(`self`)に`CONST`がないため例外が発生します。

→`M::CONST`と、`M::C`のコンテキストが一致していれば可能

→ **クラス継承** と **継承関係** は関係ない!!!

→自分自身に一番近い定数を参照する

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> class M::C
>>   def awesome_method
>>     CONST
>>   end
>> end
=> :awesome_method
>>
>> p M::C.new.awesome_method
NameError: uninitialized constant M::C::CONST

# クラス継承と、継承関係の調査
>> a = M::C.new
=> #<M::C:0x007fefa586fdc0>
>> a.class
=> M::C
>> a.class.class       # Mが親クラスと思うが、継承関係はない
=> Class
```

![問題1_選択肢1](./images/gold/問題1_選択肢1.png)



### 選択肢2

`class_eval`にブロックを渡した場合は、ブロック内のネストはモジュール`M`になります。

そのコンテキストから定数を探しますので`"Hello, world"`が表示されます。

```ruby
>> class C
>> end
=> nil
>>
?> module M
>>   CONST = "Hello, world"
>>
?>   C.class_eval do
?>     def awesome_method
>>       CONST
>>     end
>>   end
>> end
=> :awesome_method
>>
>> p C.new.awesome_method
"Hello, world"
=> "Hello, world"
```

![問題1_選択肢2](./images/gold/問題1_選択肢2.png)



### 選択肢3

`class_eval`に文字列を渡した場合のネストの状態はクラス`C`です。

`CONST`はクラス`C`にありますので`"Hello, world"`が表示されます。

> `class_eval`メソッドの引数に文字列`code`を渡すと、その文字列をクラス定義やモジュール定義の中のコードであるように実行します。
>
> 戻り値は、文字列のコードの戻り値です。

```ruby
>> class C
>>   CONST = "Hello, world"
>> end
=> "Hello, world"
>>
?> module M
>>   C.class_eval(<<-CODE)
    def awesome_method
      CONST
    end
  CODE
>> end
=> :awesome_method
>>
>> p C.new.awesome_method
"Hello, world"
=> "Hello, world"
```

![問題1_選択肢3](./images/gold/問題1_選択肢3.png)



### 選択肢4

`class_eval`にブロックを渡した場合は、ブロック内のネストはモジュール`M`になります。

そのコンテキストから定数を探しますがないため例外が発生します。

> `Module#class_eval`
>
> 文字列が与えられた場合には、定数とクラス変数のスコープは自身のモジュール定義式内と同じスコープになります。
>
> ブロックが与えられた場合には、定数とクラス変数のスコープはブロックの外側のスコープになります。

```ruby
>> class C
>>   CONST = "Hello, world"
>> end
=> "Hello, world"
>>
>> module M
>>   C.class_eval do
>>     def awesome_method
>>       CONST
>>     end
>>   end
>> end
=> :awesome_method
>>
>> p C.new.awesome_method
NameError: uninitialized constant M::CONST
```

![問題1_選択肢4](./images/gold/問題1_選択肢4.png)



## 以下のコードを実行するとどうなりますか

`C#initialize`が`S#initialize`をオーバーライドされているため、`@@val += 1`は実行されません。

> initializeメソッドは重複して定義するたびに、最後に定義されたinitializeメソッドが使用されます。

`class << C ~ end`の処理はクラスを定義した時点で、実行されます。

→返り値？？

> 後日、もう一度検索してみる
> 2018/10/27

```ruby
>> class S
>>   @@val = 0
>>   def initialize
>>     @@val += 1
>>   end
>> end
=> :initialize
>>
>> class C < S
>>   class << C
>>     @@val += 1
>>   end
>>
>>   def initialize           # 最後のinitializeが使用される
>>   end
>> end
=> :initialize
>>
>> C.new                   # initializeで実行されていない(オーバーライドされている)
=> #<C:0x007f826e078d00>
>> C.new                   # initializeで実行されていない(オーバーライドされている)
=> #<C:0x007f826e073328>
>> S.new
=> #<S:0x007f826e0719b0>
>> S.new
=> #<S:0x007f826e070038>
>>
>> p C.class_variable_get(:@@val)
3
=> 3
```



## 以下のコードを実行するとどうなりますか

```ruby
>> class S
>>   @@val = 0
>>   def initialize
>>     @@val += 1
>>   end
>> end
=> :initialize

>> class C < S
>>   class << C
>>     @@val += 1
>>   end
>> end
=> 1

>> C.new
=> #<C:0x007fac7d09bfb0>
>> C.new
=> #<C:0x007fac7d09a610>
>> S.new
=> #<S:0x007fac7d098cc0>
>> S.new
=> #<S:0x007fac7c1472d0>

>> p C.class_variable_get(:@@val)
5
=> 5
```

`@@val`に`1`加算しているタイミングは以下です。

* Cクラスの特異クラスを定義

* C.newの呼び出し

* S.newの呼び出し



## 次のコードを実行するとどうなりますか

`include`はモジュールのメソッドをインスタンスメソッドとして追加します。

メソッド探索順は`self`(クラス)の後に追加されます。

複数回`include`された場合は、後に宣言された方からメソッド探索されます。

![多重インクルード(1)](./images/gold/多重インクルード(1).png)

```ruby
>> module M1
>> end
=> nil
>>
>> module M2
>> end
=> nil
>>
>> class C
>>   include M1
>>   include M2
>> end
=> C
>>
>> p C.ancestors
[C, M2, M1, Object, Kernel, BasicObject]
=> [C, M2, M1, Object, Kernel, BasicObject]
```



## 以下のコードを実行するとどうなりますか

```ruby
>> module Mod
>>   def foo
>>     puts "Mod"
>>   end
>> end
=> :foo
>> class Cls1
>>   include Mod
>>   def foo
>>     puts "Cls1"
>>     super
>>   end
>> end
=> :foo
>> class Cls2 < Cls1
>>   def foo
>>     puts "Cls2"
>>     super
>>   end
>> end
=> :foo

>> Cls2.new.foo
Cls2
Cls1
Mod
=> nil
```



### 解説

メソッドは、

* 自分のクラス->includeしているモジュール->スーパークラス->スーパークラスのincludeしているモジュール

の順に検索される

Cls2クラスのオブジェクトで`foo`を呼び出すと、Cl2クラスの`foo`が実行され、Cls2を画面に出力したあと、

`super`でCls1クラスの`foo`を呼び出します。

Cls1クラスの`foo`の中でCls1を画面に出力した後、`super`でModモジュールの`foo`を呼び出し、Modを画面に出力します

したがって、Cls2、Cls1、Modの順番で出力されます



## 次のコードを実行するとどうなりますか

```ruby
>> module M
>>   def foo
>>     super
>>     puts "M#foo"
>>   end
>> end
=> :foo

>> class C2
>>   def foo
>>     puts "C2#foo"
>>   end
>> end
=> :foo

>> class C < C2
>>   def foo
>>     super
>>     puts "C#foo"
>>   end
>>   include M
>> end
=> C

>> C.new.foo
C2#foo
M#foo
C#foo
=> nil
```

`include`はモジュールのメソッドをインスタンスメソッドとして追加します。

メソッド探索順は`self`の後に追加されます。



`include`はモジュールのメソッドをインスタンスメソッドとして追加します。

メソッド探索順は`self`の後に追加されます。

→`C2` -> `M` -> `C` の順番


> 後に`include`した方が、先に`include`したものを覆う感覚
>
> `include`は、覆う感覚


![問題28_2回目](./images/gold/問題28_2回目.png)



## 次のプログラムを実行するとどうなりますか

```ruby
>> module M1
>>   class C1
>>     CONST = "001"
>>   end
>>
>>   class C2 < C1
>>     CONST = "010"
>>
>>     module M2
>>       CONST = "011"
>>
>>       class Ca
>>         CONST = "100"
>>       end
>>
>>       class Cb < Ca
>>         p CONST
>>       end
>>     end
>>   end
>> end
"011"
=> "011"
```

![問題9](./images/gold/問題9.jpg)



### 解説

Rubyは定数の参照はレキシカルに決定されます。

名前空間ではなく、プログラム上の定義された場所と使われている場所の静的な位置づけが重要です。

例えば、次のプログラムでは期待した結果が得られません。`CONST`がモジュールMのスコープにあるためです。

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"
>>
>> class M::C
>>   def awesome_method
>>     CONST
>>   end
>> end
=> :awesome_method
>>
>> p M::C.new.awesome_method
NameError: uninitialized constant M::C::CONST
```

一方で同じレキシカルスコープにある場合は例外は発生しません。

```ruby
>> module M
>>   CONST = "Hello, world"
>>
>>   class C
>>     def awesome_method
>>       CONST
>>     end
>>   end
>> end
=> :awesome_method
>>
>> p M::C.new.awesome_method
"Hello, world"
=> "Hello, world"
```

また、使われている定数の場所がネストされている場合は内側から順に定数の探索が始まります。

レキシカルスコープに定数がない場合は、スーパークラスの探索を行います。

クラス`Cb`から最も物理的に近いのは`M2::CONST`であるため答えは`"011"`になります。

スーパークラスの探索はこの場合には行われません。



## 以下のコードを実行するとどうなりますか

`initialize`の可視性は`private`に設定されています。

`initialize`の可視性を`public`に設定したとしても、必ずprivateになります。

> newメソッドの処理の内部でインスタンスの初期化のために使うメソッド
>
> インスタンスの外部からは呼び出すことができない

```ruby
>> class C
>> private
>>   def initialize
>>   end
>> end
=> :initialize
>>
>> p C.new.public_methods.include? :initialize
false
=> false
```



## 次のコードを実行するとどうなりますか。

`Class#name`はクラス名を文字列で返します。

`Human#name`クラスは`Class#name`をオーバーライドしているので、`const_get`が呼ばれます。

`const_get`は、`self`に定義された定数を探索します。自クラスに定義がない場合は、メソッドと同様に探索を行います。

問題コードの5行目時点のインスタンスは`Fukuzawa`クラスです。

よって、`Human#name`は`Fukuzawa`クラスの`Yukichi`を返します。

```ruby
>> class Human
>>   NAME = "Unknown"
>>
>>   def self.name
>>     const_get(:NAME)
>>   end
>> end
=> :name
>>
>> class Fukuzawa < Human
>>   NAME = "Yukichi"
>> end
=> "Yukichi"
>>
>> puts Fukuzawa.name
Yukichi
=> nil
```



## 次のコードを実行するとどうなりますか

`method_missing`は、継承チェーンを辿った末にメソッドが見つからなかった場合に、呼び出されます。

`method_missing`も継承チェーンを辿ります。

よって、`B#method_missing`が出力されます。

> 現在のクラス・モジュールで`method_missing`があれば実行
>
> そうしないと、動的にメソッドを定義するときに不都合になる

```Ruby
>> module M
>>   def method_missing(id, *args)
>>     puts "M#method_missing"
>>   end
>> end
=> :method_missing
>> class A
>>   include M
>>   def method_missing(id, *args)
>>     puts "A#method_missing"
>>   end
>> end
=> :method_missing
>> class B < A
>>   def method_missing(id, *args)
>>     puts "B#method_missing"
>>   end
>> end
=> :method_missing
>>
>> obj = B.new
=> #<B:0x007f876f01e188>
>> obj.dummy_method
B#method_missing
=> nil
```



## 次のプログラムを実行するとどうなりますか

```ruby
>> module A
>>   B = 42
>>
?>   def f
>>     21
>>   end
>> end
=> :f
>> # module_evalは、class_evalと同様
>> A.module_eval(<<-CODE)
  def self.f
    p B
  end
CODE
=> :f
>>
>> B = 15
=> 15
>>
>> A.f
42
=> 42
```

![問題18](./images/gold/問題18.png)



### 解説

`module_eval`に文字列を引数とした場合は、レシーバーのスコープで評価されます。

問題のプログラムを次のようにするとネストの状態を調べることができます。

```ruby
>> A.module_eval(<<-CODE)
  p Module.nesting
CODE
[A]
=> [A]
```

定数は静的に探索が行われますので、`A::B`の`42`が答えになります。




## 次のプログラムを実行するとどうなりますか

`::`演算子が先頭にあるとトップレベルから定数の探索を行います。

モジュール`M`にあるクラス`C`はトップレベルにあるものを指します。

`greet`メソッドにある`CONST`はクラス`C`にはありませんが、スーパークラスにあるか探索を行います。

クラス`Base`を継承していますので、`"Hello, world"`が表示されます。

```ruby
>> class Base
>>   CONST = "Hello, world"
>> end
=> "Hello, world"
>>
>> class C < Base
>> end
=> nil
>>
>> module P
>>   CONST = "Good, night"
>> end
=> "Good, night"
>>
>> class Base
>>   prepend P
>> end
=> Base
>>
>> module M
>>   class C
>>     CONST = "Good, evening"
>>   end
>> end
=> "Good, evening"
>>
>> module M
>>   class ::C       # モジュールMでネストされているが、トップレベルのクラスCを指している
>>     def greet
>>       CONST
>>     end
>>   end
>> end
=> :greet
>>
>> p C.new.greet
"Hello, world"
=> "Hello, world"
```



## 以下のコードを実行するとどうなりますか

`@@val`に`1`加算しているタイミングは以下です。

* `C`クラスの特異クラスを定義

* `C.new`の呼び出し

* `S.new`の呼び出し

```ruby
>> class S
>>   @@val = 0
>>   def initialize
>>     @@val += 1
>>   end
>> end
=> :initialize
>>
>> class C < S
>>   class << C
>>     @@val += 1
>>   end
>> end
=> 1
>>
>> C.new
=> #<C:0x007fc7c98e4b88>
>> C.new
=> #<C:0x007fc7c98def58>
>> S.new
=> #<S:0x007fc7c98dd5e0>
>> S.new
=> #<S:0x007fc7c98d7c08>
>>
>> p C.class_variable_get(:@@val)
5
=> 5
```



## 以下のコードを実行するとどうなりますか

```ruby
>> class S
>>   @@val = 0
>>   def initialize
>>     @@val += 1
>>   end
>> end
=> :initialize

>> class C < S
>>   class << C
>>     @@val += 1
>>   end
>> end
=> 1

>> C.new
=> #<C:0x007ffa358d4050>
>> C.new
=> #<C:0x007ffa358ce628>
>> S.new
=> #<S:0x007ffa358cccb0>
>> S.new
=> #<S:0x007ffa358c7300>

>> p C.class_variable_get(:@@val)
5
=> 5
```



### 解説

`@@val`に`1`加算しているタイミングは以下です。

* Cクラスの特異クラスを定義

* `C.new`の呼び出し

* `S.new`の呼び出し

```ruby
class S
  @@val = 0
  def initialize  # 初期化による加算
    @@val += 1
  end
end

class C < S
  class << C      # クラスCにおける、クラスメソッドの定義(`C.new`もクラスメソッドの呼び出し)
    @@val += 1    # クラスCのクラスメソッドを呼び出すと、加算される
  end
end

C.new
C.new
S.new
S.new

p C.class_variable_get(:@@val)
```




## 次のプログラムを実行するとどうなりますか

```ruby
>> class Object
>>   CONST = "1"                 # 最初の定義(CONST = "1")
>>   def const_succ
>>     CONST.succ!
>>   end
>> end
=> :const_succ

>> class Child1
>>   const_succ                  # 1回目(CONST = "2")
>>   class << self
>>     const_succ                # 2回目(CONST = "3")
>>   end
>> end
=> "3"

>> class Child2
>>   const_succ                  # 3回目(CONST = "4")
>>   def initialize
>>     const_succ                # 4回目(CONST = "5")
>>   end
>> end
=> :initialize

>> Child1.new
=> #<Child1:0x007fc59f06e570>
>> Child2.new
=> #<Child2:0x007fc59f06c4f0>

>> p Object::CONST
"5"
=> "5"
```



### 解説

クラスObjectにメソッドを定義すると特異クラスでもそのメソッドを利用することが出来ます。

問題のプログラムを順に実行すると、答えは"5"になります。


> 補足　`Object#const_succ`について

> 内部で`String#succ!`を実行しています。このメソッドはレシーバーの文字列を次の文字列へ進めます。

> この問題ですと、`"1"`→`"2"`・・・と`1`ずつ繰り上がります。

> また、定数に対して行っていますが破壊的メソッドの呼び出しですので再代入にはならず警告は表示されません。

```ruby
class Object
  CONST = "1"
  def const_succ
    CONST.succ!
  end
end

class Child1
  const_succ # "2"になる
  class << self
    const_succ # "3"になる
  end
end

class Child2
  const_succ # "4になる"
  def initialize
    const_succ
  end
end

Child1.new # "4"のまま・・・継承していないので、初期化はされない
Child2.new # "5"になる

p Object::CONST
"5"
=> "5"
```



## 次のコードを実行するとどうなりますか

`super`はスーパークラスと同名のメソッドが呼ばれます。

引数ありのメソッドで`super`を呼び出すと、引数ありのメソッドが呼ばれますが、そのメソッドが存在しない場合は、`ArgumentError`が発生します。

引数ありのメソッドで引数なしのスーパークラスを呼び出すには、`super()`と明示的に呼び出す必要があります。

> 正解しているけど、念のため
>
> 2018/10/28

```ruby
>> class S
>>   def initialize
>>     puts "S#initialize"
>>   end
>> end
=> :initialize
>>
?> class C < S
>>   def initialize(*args)
>>     super()
>>     puts "C#initialize"
>>   end
>> end
=> :initialize
>>
?> C.new(1,2,3,4,5)
S#initialize
C#initialize
=> #<C:0x007f92790acab8>
```



## 次のプログラムを実行するとどうなりますか

Rubyは定数の参照はレキシカルに決定されますが、この問題ではレキシカルスコープに定数はありません。

レキシカルスコープに定数がない場合は、スーパークラスの探索を行います。

この問題では、クラス`C2`のスコープで定数を参照しています。

クラス`C2`のスーパークラスはクラス`Cd`ですので`"100"`が正解になります。

> 正解しているけど念のため
>
> 2018/10/28

```ruby
>> class Ca
>>   CONST = "001"
>> end
=> "001"
>>
?> class Cb
>>   CONST = "010"
>> end
=> "010"
>>
?> class Cc
>>   CONST = "011"
>> end
=> "011"
>>
?> class Cd
>>   CONST = "100"
>> end
=> "100"
>>
?> module M1
>>   class C0 < Ca
>>     class C1 < Cc
>>       class C2 < Cd
>>         p CONST
>>
?>         class C2 < Cb
>>         end
>>       end
>>     end
>>   end
>> end
"100"
=> nil
```



## 次のプログラムを実行するとどうなりますか

`module_eval`にブロックを渡した場合のネストは次の通りです。

```ruby
A.module_eval do
  p Module.nesting # []と表示され、ネストされた状態になく、トップレベルにいることがわかる
end
```
トップレベルで定数を定義した場合は`Object`の定数になります。

```ruby
B = "Hello, world"
p Object.const_get(:B) # "Hello, world"と表示される
```
問題にあるメソッド`A.f`はトップレベルにある定数を探索するため答えは`15`になります。

> `Module#module_eval`
>
> 文字列が与えられた場合には、定数とクラス変数のスコープは自身のモジュール定義式内と同じスコープになります。
>
> ブロックが与えられた場合には、定数とクラス変数のスコープはブロックの外側のスコープになります。

```ruby
>> module A
>>   B = 42
>>
>>   def f
>>     21
>>   end
>> end
=> :f
>>
>> A.module_eval do
>>   def self.f
>>     p B
>>   end
>> end
=> :f
>>
>> B = 15
=> 15
>>
>> A.f
15
=> 15
```

![問題26](./images/gold/問題26.png)



## 次のコードを実行するとどうなりますか

`method_missing`は、継承チェーンを辿った末にメソッドが見つからなかった場合に、呼び出されます。

`method_missing`も継承チェーンを辿ります。

問題で、`B.dummy_method`と呼び出しています。

これは、Classクラスのインスタンスメソッドが呼ばれます。

よって、`Class#method_missing`が出力されます。

> ClassクラスのオブジェクトがBクラス
>
> `dummy_method`は、Bから見ればクラスメソッドだが、Classから見ればBのインスタンスメソッド
>
> Bのインスタンスメソッドが見つからない場合は、Classのインスタンスメソッドを呼び出す

```ruby
>> class Class
>>   def method_missing(id, *args)
>>     puts "Class#method_missing"
>>   end
>> end
=> :method_missing
>> class A
>>   def method_missing(id, *args)
>>     puts "A#method_missing"
>>   end
>> end
=> :method_missing
>> class B < A
>>   def method_missing(id, *args)
>>     puts "B#method_missing"
>>   end
>> end
=> :method_missing
>>
>> B.dummy_method
Class#method_missing
=> nil
```



## 次のコードを実行するとどうなりますか。

定数はインスタンスではなくクラスに存在します。

定数の探索順位は`クラス内 -> スーパークラス -> クラス探索`順に行われます。

よって、`Human#name`のクラス内定数である`NAME = "Unknown"`が返されます。

```ruby
>> class Human
>>   NAME = "Unknown"
>>
>>   def name
>>     NAME
>>   end
>> end
=> :name
>>
>> class Noguchi < Human
>>   NAME = "Hideyo"
>> end
=> "Hideyo"
>>
>> puts Noguchi.new.name
Unknown
=> nil
```

![問題34](./images/gold/問題34.png)



## 次のコードを実行するとどうなりますか

`Array#sort`は比較に`<=>`を使用しています。

自作クラスの場合はオブジェクトIDが比較対象となります。

`Fixnum#<=>(other)`は以下の結果を返します。

* `self`が`other`より大きい場合は、`1`を返します。

* `self`が`other`と等しい場合は、`0`を返します。

* `self`が`other`より小さい場合は、`-1`を返します。

問題のコードでは、`sort`は非破壊的メソッドです。

よって`puts`時点ではソートが行われずに配列へ挿入した順番に表示されます。

> `puts`
>
> 引数のオブジェクトを文字列に変換し、改行を加えて標準出力に出力。
>
> `to_s`メソッドで文字列に変換される。

※組み込みクラスのクラスメソッドのモンキーパッチをここでは行なっている

```ruby
>> class Company
>>   attr_reader :id
>>   attr_accessor :name
>>   def initialize id, name
>>     @id = id
>>     @name = name
>>   end
>>   def to_s
>>     "#{id}:#{name}"
>>   end
>>   def <=> other
>>     self.id <=> other.id
>>   end
>> end
=> :<=>
>>
>> companies = []
=> []
>> companies << Company.new(2, 'Liberyfish')
=> [#<Company:0x007fe8691249a0 @id=2, @name="Liberyfish">]
>> companies << Company.new(3, 'Freefish')
=> [#<Company:0x007fe8691249a0 @id=2, @name="Liberyfish">, #<Company:0x007fe8681834d8 @id=3, @name="Freefish">]
>> companies << Company.new(1, 'Freedomfish')
=> [#<Company:0x007fe8691249a0 @id=2, @name="Liberyfish">, #<Company:0x007fe8681834d8 @id=3, @name="Freefish">, #<Company:0x007fe86911d998 @id=1, @name="Freedomfish">]
>>
>> companies.sort
=> [#<Company:0x007fe86911d998 @id=1, @name="Freedomfish">, #<Company:0x007fe8691249a0 @id=2, @name="Liberyfish">, #<Company:0x007fe8681834d8 @id=3, @name="Freefish">]
>>
>> companies.each do |e|
>>   puts e
>> end
2:Liberyfish
3:Freefish
1:Freedomfish
=> [#<Company:0x007fe8691249a0 @id=2, @name="Liberyfish">, #<Company:0x007fe8681834d8 @id=3, @name="Freefish">, #<Company:0x007fe86911d998 @id=1, @name="Freedomfish">]
```



## 次のコードを実行するとどうなりますか

```ruby
>> class Company
>>   attr_reader :id
>>   attr_accessor :name
>>   def initialize id, name
>>     @id = id
>>     @name = name
>>   end
>>   def to_s
>>     "#{id}:#{name}"
>>   end
>>   def <=> other
>>     other.id <=> self.id
>>   end
>> end
=> :<=>

>> companies = []
=> []
>> companies << Company.new(2, 'Liberyfish')
=> [#<Company:0x007fc0c888c3a0 @id=2, @name="Liberyfish">]
>> companies << Company.new(3, 'Freefish')
=> [#<Company:0x007fc0c888c3a0 @id=2, @name="Liberyfish">, #<Company:0x007fc0c8136f10 @id=3, @name="Freefish">]
>> companies << Company.new(1, 'Freedomfish')
=> [#<Company:0x007fc0c888c3a0 @id=2, @name="Liberyfish">, #<Company:0x007fc0c8136f10 @id=3, @name="Freefish">, #<Company:0x007fc0c812d3e8 @id=1, @name="Freedomfish">]

>> companies.sort!
=> [#<Company:0x007fc0c8136f10 @id=3, @name="Freefish">, #<Company:0x007fc0c888c3a0 @id=2, @name="Liberyfish">, #<Company:0x007fc0c812d3e8 @id=1, @name="Freedomfish">]

>> companies.each do |e|
>>   puts e
>> end
3:Freefish
2:Liberyfish
1:Freedomfish
=> [#<Company:0x007fc0c8136f10 @id=3, @name="Freefish">, #<Company:0x007fc0c888c3a0 @id=2, @name="Liberyfish">, #<Company:0x007fc0c812d3e8 @id=1, @name="Freedomfish">]
```



### 解説

`Array#sort`は比較に`<=>`を使用しています。

自作クラスの場合はオブジェクトIDが比較対象となります。

別のソート条件を用いるには<=>をオーバーライドします。

`Fixnum#<=>(other)`は以下の結果を返します。

  * `self`が`other`より大きい場合は、`1`を返します。
  * `self`が`other`と等しい場合は、`0`を返します。
  * `self`が`other`より小さい場合は、`-1`を返します。

問題のコードでは、`sort!`は破壊的メソッドです。

よって`puts`時点ではソートが行われて表示されます。



## 次のコードの実行結果が`falsetrue`になるように`XXXX`,`YYYY`に適切なコードを選択せよ

```ruby
class Company
  XXXX
  attr_reader :id
  attr_accessor :name
  def initialize id, name
    @id = id
    @name = name
  end
  def to_s
    "#{id}:#{name}"
  end
  YYYY
end

c1 = Company.new(3, 'Liberyfish')
c2 = Company.new(2, 'Freefish')
c3 = Company.new(1, 'Freedomfish')

print c1.between?(c2, c3)
print c2.between?(c3, c1)
```

```ruby
# 解答
class Company
  include Comparable
  attr_reader :id
  attr_accessor :name
  def initialize id, name
    @id = id
    @name = name
  end
  def to_s
    "#{id}:#{name}"
  end
  def <=> other
    self.id <=> other.id
  end
end

c1 = Company.new(3, 'Liberyfish')
c2 = Company.new(2, 'Freefish')
c3 = Company.new(1, 'Freedomfish')

print c1.between?(c2, c3)
print c2.between?(c3, c1)
```



### 解説

`between?`で値を比較するためには、Comparableを`include`する必要があります。

Comparableは比較に`<=>`を使用しています。

自作クラスの場合はオブジェクトIDが比較対象となります。

通常は、`Comparable#<=>`をオーバーライドします。

`Fixnum#<=>(other)`は以下の結果を返します。

* `self`が`other`より大きい場合は、`1`を返します。

* `self`が`other`と等しい場合は、`0`を返します。

* `self`が`other`より小さい場合は、`-1`を返します。

`extend`はモジュールのインスタンスメソッドを特異メソッドとして追加します。

インスタンス変数からメソッドを参照することができなくなるので、エラーになります。

Sortableモジュールは存在しません。



## 次のプログラムを実行するとどうなりますか

```ruby
>> module K
>>   CONST = "Good, night"
>>   class P
>>   end
>> end
=> nil
>>
?> module K::P::M
>>   class C
>>     CONST = "Good, evening"
>>   end
>> end
=> "Good, evening"
>>
?> module M
>>   class C
>>     CONST = "Hello, world"
>>   end
>> end
=> "Hello, world"
>>
?> class K::P
>>   class M::C
>>     p CONST
>>   end
>> end
"Good, evening"
=> "Good, evening"
```

> 正解していたが、念のため
>
> 2018/10/28



### 解説

クラス`K::P`にあるクラス`M::C`はトップレベルにあるものとは異なります。

ネスト状態が同じものがあれば、そのレキシカルスコープから定数の探索を行います。

この問題では定数`CONST`が参照しているのは`K::P::M::C`で、そのレキシカルスコープにある定数を探索しますので`"Good, evening"`と表示されます。

```ruby
module K
  class P
    p Module.nesting # [K::P, K]と表示されます
  end
end

module K::P::M
  class C
    p Module.nesting # [K::P::M::C, K::P::M]と表示されます
  end
end

module M
  class C
    p Module.nesting # [M::C, M]と表示されます
  end
end

class K::P
  class M::C
    p Module.nesting # [K::P::M::C, K::P]と表示されます
  end
end
```



## 次のコードを実行するとどうなりますか

```ruby
>> class S
>>   def initialize
>>     puts "S#initialize"
>>   end
>> end
=> :initialize
>>
>> class C < S
>>   def initialize(*args)
>>     super
>>     puts "C#initialize"
>>   end
>> end
=> :initialize
>>
>> C.new(1,2,3,4,5)
ArgumentError: wrong number of arguments (given 5, expected 0)
```



### 解説

問題のコードは`ArgumentError: wrong number of arguments (5 for 0)`が発生します。

`super`と呼び出した場合は、現在のメソッドと同じ引数が引き継がれます。

引数を渡さずにオーバーライドしたメソッドを呼び出す際は`super()`とします。

問題のコードは次のように修正します。

### 修正後

```ruby
class S
  def initialize
    puts "S#initialize"
  end
end

class C < S
  def initialize(*args)
    super() # 引数なしを明示的に指定する
    puts "C#initialize"
  end
end
```



## 次のプログラムと同じく特異クラスを取得する選択肢を選んでください。

```ruby
>> class C
>>   def self._singleton
>>     class << C
>>       self
>>     end
>>   end
>> end
=> :_singleton
>>
>> p C._singleton
#<Class:C>
=> #<Class:C>
```

```ruby
# 選択肢1
>> class C
>>   def self._singleton
>>     class << C
>>       val = self
>>     end
>>     val
>>   end
>> end
=> :_singleton
>>
?> p C._singleton
NameError: undefined local variable or method 'val' for C:Class
```

```ruby
# 選択肢2
>> class C
>> end
=> nil
>>
>> def C._singleton
>>   self
>> end
=> :_singleton
>>
>> p C._singleton
C
=> C
```

```ruby
# 選択肢3
>> class C
>> end
=> nil
>>
>> class << C
>>   def _singleton
>>     self
>>   end
>> end
=> :_singleton
>>
>> p C._singleton
C
=> C
```

```ruby
# 選択肢4
>> class C
>> end
=> nil
>> p C.singleton_class
#<Class:C>
=> #<Class:C>
```



### 解説

`Object.singleton_class`を利用すると特異クラスを取得することが出来ます。

特異クラスで`self`を参照するとレシーバのオブジェクトがとれます。この選択肢では、クラス`C`が取得できます。

また、特異クラス定義では新しくスコープが作られますので次のプログラムでは例外が発生します。

```ruby
>> class C
>>   def self._singleton
>>     class << C
>>       val = self # 特異クラスのみ有効なローカル変数
>>     end
>>     val
>>   end
>> end
=> :_singleton
>>
>> p C._singleton
NameError: undefined local variable or method 'val' for C:Class
```



## 次のプログラムを実行するとどうなりますか

```ruby
>> class Base
>>   def name
>>     p 'Base#name'
>>   end
>> end
=> :name
>>
>> module Scope
>>   class Base
>>     def name
>>       p 'Scope::Base#name'
>>     end
>>   end
>>
>>   class Inherited < Base
>>     def name
>>       p 'Scope::Inherited#name'
>>       super
>>     end
>>   end
>> end
=> :name
>>
>> inherited = Scope::Inherited.new
=> #<Scope::Inherited:0x007fc6239b08c0>
>> inherited.name
"Scope::Inherited#name"
"Scope::Base#name"
=> "Scope::Base#name"
```

> 正解だが、一応載せる
>
> 2018/10/28



### 解説

クラス`Inherited`の親クラス`Base`がどのように決定されるかがこの問題のポイントです。

クラスはRubyでは定数です。定数の探索はレキシカルスコープを利用します。

親クラス`Base`の探索はモジュール`Scope`から始まります。

レキシカルスコープにクラス（定数）`Base`が見つかったので、

クラス`Inherited`の親クラス`Base`は`Scope::Base`となります。

```ruby
class Base
  def name
    p 'Base#name'
  end
end

module Scope
  class Base
    def name
      p 'Scope::Base#name'
    end
  end

  class Inherited < Base # クラスScope::Baseとして解釈される
    def name
      p 'Scope::Inherited#name'
      super
    end
  end
end
```

もし、クラス`Base`がクラス`Inherited`より前に定義されていないのであれば動作が変わります。

継承を定義した時点で`Scope::Base`をRubyは見つけることができないので、親クラス`Base`はトップレベルにあるクラスを参照します。

```ruby
class Base
  def name
    p 'Base#name'
  end
end

module Scope
  class Inherited < Base # トップレベルにあるクラスBaseとして解釈される
    def name
      p 'Scope::Inherited#name'
      super
    end
  end

  class Base
    def name
      p 'Scope::Base#name'
    end
  end
end

inherited = Scope::Inherited.new
inherited.name

# 結果は次の通り
# "Scope::Inherited#name"
# "Base#name"
```



## 次のコードを実行するとどうなりますか

> 一応正解したが、念のため
>
> 2018/11/02

```ruby
>> class C
>>   @val = 3
>>   attr_accessor :val
>>   class << self
>>     @val = 10
>>   end
>>   def initialize
>>     @val *= 2 if val
>>   end
>> end
=> :initialize

>> c = C.new
=> #<C:0x007fc2e593b1d8>
>> c.val += 10
NoMethodError: undefined method '+' for nil:NilClass
>> p c.val
nil
=> nil
```



### 解説

問題のコードは、13行目で`c.val`が`nil`になり、実行エラーになります。

2行目の`@val`はクラスインスタンス変数といい、特異メソッドからアクセスすることができます。

3行目の`@val`は特異クラスのクラスインスタンス変数です。

この値にアクセスするためには以下のようにアクセスします。

```ruby
class << C
  p @val
end
```

13行目の`c.val`は`attr_accessor`よりアクセスされます。

`initialize`メソッドで初期化が行われていないため、`nil`が返されます。

以下のコードは問題コードに行番号をつけています。

```ruby
1: class C
2:   @val = 3
3:   attr_accessor :val
4:   class << self
5:     @val = 10
6:   end
7:   def initialize
8:     @val *= 2 if val
9:   end
10: end
11:
12: c = C.new
13: c.val += 10
14:
15: p c.val
```



## 次のコードを実行するとどうなりますか

`include`は`Module`のインスタンスメソッドをMix-inするメソッドです。

`C.methods`は`C`の特異メソッドを表示します。

よって、`C#class_m`はインスタンスメソッドです、`C.methods`では表示されません。

```ruby
>> module M
>>   def class_m
>>     "class_m"
>>   end
>> end
=> :class_m
>>
>> class C
>>   include M
>> end
=> C

>> p C.methods.include? :class_m
false
=> false

# オブジェクトを生成した場合は、存在する
>> obj = C.new
=> #<C:0x007f91a7936cd8>
>> p obj.methods.include? :class_m
true
=> true
```



## 次のコードを実行するとどうなりますか

```ruby
>> module M
>>   def class_m
>>     "class_m"
>>   end
>> end
=> :class_m

>> class C
>>   extend M
>> end
=> C

>> p C.methods.include? :class_m
true
=> true
```

`extend`は引数に指定したモジュールのメソッドを特異メソッドとして追加します。

問題の`C.methods...`は特異メソッドの一覧を取得します。



## 次のコードを実行するとどうなりますか

```ruby
>> module M
>>   def self.class_m
>>     "M.class_m"
>>   end
>> end
=> :class_m

>> class C
>>   include M
>> end
=> C

>> p C.methods.include? :class_m
false
=> false
```



### 解説

問題コードの注意すべき点は以下の通りです。

* `include`はModuleの **インスタンスメソッド** をMix-inするメソッドです。

* `def self.class_m`と宣言すると、特異クラスのメソッドになります。

* `C.methods`はCの特異メソッドを表示します。

よって、Cには`class_m`が追加されません。

```ruby
#
# includeをextendに変更
#
>> module M
>>   def self.class_m
>>     "M.class_m"
>>   end
>> end
=> :class_m

>> class C
>>   extend M
>> end
=> C

>> p C.methods.include? :class_m
false
=> false

#
# `self`を削除
#
>> module M
>>   def class_m
>>     "M.class_m"
>>   end
>> end
=> :class_m

>> class C
>>   extend M
>> end
=> C

>> p C.methods.include? :class_m
true
=> true
```



## 以下のコードを実行するとどうなりますか

`initialize`は`private`などでアクセス修飾子をつけたとしても、`private`から変わることはありません。

```ruby
>> class C
>> public
>>   def initialize
>>   end
>> end
=> :initialize

>> p C.new.private_methods.include? :initialize
true
=> true
```



## 以下の実行結果になるように、`__X__`に記述する適切なコードを全て選びなさい(複数選択)

```ruby
class Example
  def hoge
    self.piyo
  end
  __X__
  def piyo
    puts "piyo"
  end
end

Example.new.hoge

# 実行結果
piyo
```

1. `private`

1. `protected`

1. `public`

1. 何も記述しない



### 解説

`self.piyo`と`piyo`メソッドに`self`のレシーバをつけているので、`piyo`メソッドが`private`メソッドだとエラーになる

それ以外の`protected`、`public`、何も記述しない場合は`self.piyo`で呼び出すことができる



## 次のコードを実行するとどうなりますか

```ruby
>> module M1
>> end
=> nil

>> module M2
>> end
=> nil

>> class C
>>   include M1, M2
>> end
=> C

>> p C.ancestors
[C, M1, M2, Object, Kernel, BasicObject]
=> [C, M1, M2, Object, Kernel, BasicObject]
```



### 解説

`include`はモジュールのメソッドをインスタンスメソッドとして追加します。

メソッド探索順は`self`の後に追加されます。

複数モジュールを指定した場合は、 **左側が先にメソッド探索** されます。

![問題16_2回目](./images/gold/問題16_2回目.png)



## 以下のコードを実行するとどうなりますか

```ruby
>> module M1
>> end
=> nil

>> module M2
>> end
=> nil

>> class Cls1
>>   include M1
>> end
=> Cls1

>> class Cls2 < Cls1
>>   p self.ancestors
>>   include M2
>> end
[Cls2, Cls1, M1, Object, Kernel, BasicObject]
=> Cls2
```



### 解説

`ancestors`は、クラス、モジュールの優先順で配列に格納して返す

Cls2クラスの`include M2`は`ancestors`実行後のため、`ancestors`の対象外です




## 次のプログラムを実行するとどうなりますか

`refer_const`はモジュールMにありますが、`CONST`はレキシカルに決定されるためモジュールMのスコープを探索します。

この問題では`CONST`が見つからないため例外が発生します。

```ruby
>> module M
>>   def refer_const
>>     CONST
>>   end
>> end
=> :refer_const

>> module E
>>   CONST = '010'
>> end
=> "010"

>> class D
>>   CONST = "001"
>> end
=> "001"

>> class C < D
>>   include E
>>   include M
>>   CONST = '100'
>> end
TypeError: superclass mismatch for class C

>> c = C.new
=> #<C:0x007ff8a10efaa0>
>> p c.refer_const
NoMethodError: undefined method 'refer_const' for #<C:0x007ff8a10efaa0>
```

> なぜTypeErrorになるのかが分からない
>
> 2018/11/03



## 次のプログラムを実行するとどうなりますか

```ruby
>> module M
>>   def refer_const
>>     CONST
>>   end
>> end
=> :refer_const

>> module E
>>   CONST = '010'
>> end
=> "010"

>> class D
>>   CONST = "001"
>> end
=> "001"

>> class C < D
>>   include E
>>   include M
>>   CONST = '100'
>> end
=> "100"

>> c = C.new
=> #<C:0x007f9c1704f7f8>
>> p c.refer_const
NameError: uninitialized constant M::CONST
```



### 解説

`refer_const`はモジュールMにありますが、`CONST`はレキシカルに決定されるためモジュールMのスコープを探索します。

この問題では`CONST`が見つからないため例外が発生します。




## 次のプログラムは"Hello, world"と表示します。同じ結果になる選択肢はどれですか（複数選択）

```ruby
>> module M
>>   CONST = "Hello, world"
>>   def self.say
>>     CONST
>>   end
>> end
=> :say

>> p M::say
"Hello, world"
=> "Hello, world"
```

1. 選択肢1

定数の定義はメモリ上にあるテーブルに管理されます。

モジュールMを別々に書いたとしてもテーブルを参照して値を取得できます。

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> module M
>>   def self.say
>>     CONST
>>   end
>> end
=> :say

>> p M::say
"Hello, world"
=> "Hello, world"
```

2. 選択肢2

`instance_eval`の引数に文字列を指定するとネストの状態はモジュールMの特異クラスになります。

`CONST`はモジュールMにのみありますので、例外が発生します。

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> M.instance_eval(<<-CODE)
  def say
    CONST
  end
CODE
=> :say

>> p M::say
NameError: uninitialized constant #<Class:M>::CONST
```

3. 選択肢3

特異クラス定義のコンテキストでは、ネストの状態はモジュールMの特異クラスになります。

`CONST`はモジュールMにのみありますので、例外が発生します。

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> class << M
>>   def say
>>     CONST
>>   end
>> end
=> :say

>> p M::say
NameError: uninitialized constant #<Class:M>::CONST
```

4. 選択肢4

`module_eval`の引数に文字列を指定するとネストの状態はモジュールMになります。

`CONST`はモジュールMにありますので値を取得できます。

```ruby
>> module M
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> M.module_eval(<<-CODE)
  def self.say
    CONST
  end
CODE
=> :say

>> p M::say
"Hello, world"
=> "Hello, world"
```



## 次のプログラムを実行するとどうなりますか

```ruby
>> class C
>>   CONST = "Hello, world"
>> end
=> "Hello, world"

>> $c = C.new
=> #<C:0x007fa39b80c758>

>> class D
>>   class << $c
>>     def say
>>       CONST
>>     end
>>   end
>> end
=> :say

>> p $c.say
"Hello, world"
=> "Hello, world"
```

レキシカルスコープには定数はありません。その場合はスーパークラスを探索します。

特異クラスの継承関係にクラスCがありますので定数を見つけることができます。

参考：特異クラスの継承関係

```ruby
[#<Class:#<C:0x007fa4741607e0>>, C, Object, Kernel, BasicObject]
```

![問題21_2回目](./images/gold/問題21_2回目.png)




## 次のプログラムを実行するとどうなりますか

```ruby
>> module SuperMod
>> end
=> nil

>> module SuperMod::BaseMod
>>   p Module.nesting
>> end
[SuperMod::BaseMod]
=> [SuperMod::BaseMod]
```



### 解説

`Module.nesting`はネストの状態を表示します。

次のプログラムを実行すると、`[SuperMod]`と表示されます。

```ruby
>> module SuperMod
>>   p Module.nesting
>> end
[SuperMod]
=> [SuperMod]
```

モジュールがネストされた場合は、ネストの状態をすべて表示します。

`SuperMod::BaseMod`のようにプログラムを書くと、モジュールSuperModの内側にモジュールBaseModがあることを表現することが出来ます。

インデントして別々に書いた場合に比べて、プレフィックスがある場合は内側にあるモジュールしかネストの状態は表示されません。

```ruby
>> module SuperMod
>>   p Module.nesting
>> end
[SuperMod]
=> [SuperMod]

>> module SuperMod
>>   module BaseMod
>>     p Module.nesting
>>   end
>> end
[SuperMod::BaseMod, SuperMod]
=> [SuperMod::BaseMod, SuperMod]

>> module SuperMod::BaseMod
>>   p Module.nesting
>> end
[SuperMod::BaseMod]
=> [SuperMod::BaseMod]
```

* 定数はネストした構造を持つことがある（これは実行時に値から参照できる構造）

* 一方でプログラム中の定数の参照は、構文的な構造に依存するもので、実行時の構造は関係がない(レキシカルスコープ)

* SuperModの中に書いたBaseModは、それぞれのモジュール式を遡って行って、SuperMod::BaseMod、SuperModを出力

* 一方で、SuperMod::BaseModという名前のモジュール式の中に書いたものは、モジュール式を遡ることができず、SuperMod::BaseModが出力



## 次のプログラムを実行するとどうなりますか

```ruby
>> module SuperMod
>>   module BaseMod
>>     p Module.nesting
>>   end
>> end
[SuperMod::BaseMod, SuperMod]
=> [SuperMod::BaseMod, SuperMod]
```



### 解説

`Module.nesting`はネストの状態を表示します。

次のプログラムを実行すると、`[SuperMod]`と表示されます。

```ruby
>> module SuperMod
>>   p Module.nesting
>> end
[SuperMod]
=> [SuperMod]
```

モジュールがネストされた場合は、ネストの状態をすべて表示します。

ネストされたモジュールはプレフィックスに外側にあるモジュールが付与されます。

また、ネスト状態はすべて表示されますがネストが内側から順に表示されます。

```ruby
module SuperMod
  p Module.nesting #=> [SuperMod]

  module BaseMod
    p Module.nesting #=> [SuperMod::BaseMod, SuperMod]

    module BaseBaseMod
      p Module.nesting #=> [SuperMod::BaseMod::BaseBaseMod, SuperMod::BaseMod, SuperMod]
    end
  end
end
```


## 次のコードで指定した行を書き換えた時，同じ結果になるものを選べ（複数選択）

```ruby
class C
  def v=(other) # ここから
    @v = other
  end
  def v
    @v
  end           # ここまで
end

c = C.new
c.v = 100
p c.v
```

* 解答

```ruby
# 1
attr_reader :v
attr_writer :v

# 2
attr_accessor :v
```

* `attr_reader`はインスタンス変数を返すメソッド`(def v\ end)`を作成します。

* `attr_writer`はインスタンス変数を変更するメソッド`(def v=\ end)`を作成します。

* `attr_accessor`はインスタンス変数を返すメソッドと変更するメソッドを作成します。



## 次のプログラムを実行するとどうなりますか

```ruby
>> m = Module.new
=> #<Module:0x007f96b40472f0>

>> CONST = "Constant in Toplevel"
=> "Constant in Toplevel"
>>
>> _proc = Proc.new do
>>   CONST = "Constant in Proc"
>> end
=> #<Proc:0x007f96b38b0ac8@(irb):5>

>> m.instance_eval(<<-EOS)
  CONST = "Constant in Module instance"

  def const
    CONST
  end
EOS
=> :const

>> m.module_eval(&_proc)
(irb):6: warning: already initialized constant CONST
(irb):3: warning: previous definition of CONST was here
=> "Constant in Proc"

>> p m.const
"Constant in Module instance"
=> "Constant in Module instance"
```



### 解説

メソッド`const`は特異クラスで定義されていますので、実行することができます。

その中で参照している定数`CONST`はレキシカルに決定されますので、`"Constant in Module instance"`が表示されます。


`instance_eval`はブロックを渡す場合と、文字列を引数とする場合でネストの状態が異なります。

ブロックを渡した場合はネストは変わりませんが、文字列を引数とした場合は期待するネストの状態になります。

ネストが変わらない状態で定数の代入を行うと、再代入になり警告が表示される場合があります。

例えば、次のプログラムでは`module_eval`に文字列を引数とするとモジュールを再オープン、または定義したネストと同じです。

```ruby
>> module M
>>   p Module.nesting
>> end
[M]
=> [M]

>> M.module_eval(<<-EVAL)
  p Module.nesting
EVAL
[M]
=> [M]

>> M.instance_eval do
>>   p Module.nesting
>> end
[]
=> []

>> module M
>>   p Module.nesting
>> end
[M]
=> [M]
```



## 次のプログラムを実行するとどうなりますか

```ruby
>> mod = Module.new
=> #<Module:0x007ff489046ca0>

>> mod.module_eval do
>>   EVAL_CONST = 100
>> end
=> 100

>> puts "EVAL_CONST is defined? #{mod.const_defined?(:EVAL_CONST, false)}"
EVAL_CONST is defined? false
=> nil
>> puts "EVAL_CONST is defined? #{Object.const_defined?(:EVAL_CONST, false)}"
EVAL_CONST is defined? true
=> nil
```

定数のスコープはレキシカルに決定されます。

ブロックはネストの状態を変更しないので、`module_eval`のブロックで定義した定数は

この問題ではトップレベルで定義したことになります。

また、文字列を引数とした場合はネストの状態を変更します。ネストの状態が変更されるので、

この問題ではモジュールの中でプログラムを書いたことと同じことになります。



## 次のプログラムを実行するとどうなりますか

```ruby
>> mod = Module.new
=> #<Module:0x007fc676047bf0>

>> mod.module_eval do
>>   EVAL_CONST = 100
>> end
=> 100

>> puts "EVAL_CONST is defined? #{mod.const_defined?(:EVAL_CONST)}"
EVAL_CONST is defined? true
=> nil
>> puts "EVAL_CONST is defined? #{Object.const_defined?(:EVAL_CONST)}"
EVAL_CONST is defined? true
=> nil
```



### 解説

定数のスコープはレキシカルに決定されます。

**ブロックはネストの状態を変更しない** ので、`module_eval`のブロックで定義した定数はこの問題ではトップレベルで定義したことになります。

定数`EVAL_CONST`はトップレベルで定義していることになりますので、Objectクラスに定数あることが確認することが出来ます。

また、Moduleクラスのインスタンスには直接、定数は定義されていませんが継承関係を探索して参照することが出来ます。

`const_defined?`メソッドは第2引数に継承関係を探索するか指定出来るため、この問題では探索を行うかによって結果が変わります。

```ruby
>> mod = Module.new
=> #<Module:0x007f7f0504b600>

>> mod.module_eval do
>>   EVAL_CONST = 100
>> end
=> 100

>> puts Object.const_defined? :EVAL_CONST
true
=> nil

>> puts mod.const_defined? :EVAL_CONST
true
=> nil

# 第2引数にfalseを指定すると継承関係まで探索しない
>> puts mod.const_defined? :EVAL_CONST, false
false
=> nil
```

この問題では指定してない（デフォルト値`true`）ため探索を行い、定数をどちらも見つけることが出来ます。



## 次のプログラムを実行するとどうなりますか

```ruby
>> m = Module.new
=> #<Module:0x007fb8b5846f50>

>> CONST = "Constant in Toplevel"
=> "Constant in Toplevel"

>> _proc = Proc.new do
>>   CONST = "Constant in Proc"
>> end
=> #<Proc:0x007fb8b48b0a28@(irb):5>

>> m.module_eval(<<-EOS)
  CONST = "Constant in Module instance"

  def const
    CONST
  end
EOS
=> :const

>> m.module_eval(&_proc)
(irb):6: warning: already initialized constant CONST
(irb):3: warning: previous definition of CONST was here
=> "Constant in Proc"

>> p m.const
NoMethodError: undefined method 'const' for #<Module:0x007fb8b5846f50>
```

メソッド`const`は特異クラスで定義されていないので、例外が発生します。

`const`メソッドを実行したい場合は次のように`module_function`または`instance_eval`を使う必要があります。

```ruby
>> m.module_eval(<<-EOS)  # module_eval のまま
  CONST = "Constant in Module instance"

  def const
    CONST
  end

  module_function :const  # module_function にシンボルでメソッドを指定する
EOS
(eval):1: warning: already initialized constant #<Module:0x007fb8b5846f50>::CONST
(eval):1: warning: previous definition of CONST was here
=> #<Module:0x007fb8b5846f50>
```

```ruby
>> m.instance_eval(<<-EOS)  # instance_eval で特異クラスにメソッドを定義する
  CONST = "Constant in Module instance"

  def const
    CONST
  end
EOS
=> :const
```






## 次のプログラムを実行するとどうなりますか

> 正解していたが、念のため
>
> 2018/11/10

```ruby
>> class C
>>   @@val = 10
>> end
=> 10

>> module B
>>   @@val = 30
>> end
=> 30

>> module M
>>   include B
>>   @@val = 20
>>
>>   class << C
>>     p @@val
>>   end
>> end
20
=> 20
```



### 解説

クラス変数はクラスに所属するあらゆるもので情報を共有する為にあり、

特異クラス定義の中でクラス変数を定義してもレキシカルに決定されます。

次のプログラムではクラス変数は共有されます。

```ruby
>> class C
>>   class << self
>>     @@val = 10
>>   end
>> end
=> 10

>> p C.class_variable_get(:@@val)
10
=> 10
```

この問題ではクラスCの特異クラス定義をモジュールMで行っています。

**クラス変数はレキシカルに決定** されますので答えは`20`です。





































# alias


## 期待した出力結果になるようにXXXXに適切なコードを選べ

```ruby
class String
  XXXX
end

p "12345".hoge
```

```ruby
# 実行結果
54321
```

1. `alias :hoge, :reverse`

2. `alias :reverse, :hoge`

3. `alias hoge reverse`

4. `alias reverse hoge`



### 解説

`alias`式はメソッドやグローバル変数に別名を付けることができます。

定義は以下のようにします。

```ruby
alias new_method old_method
alias :new_method :old_method
alias $new_global_val $old_global_val
```

メソッド内でメソッドに別名をつける必要がある場合は、`Module#alias_method`を使います。

```ruby
alias_method "new_method", "old_method"
alias_method :new_method, :old_method
```



## 期待した出力結果になるようにXXXXに適切なコードを選べ

```ruby
class String
  XXXX
end

p "12345".hoge
```

```ruby
# 実行結果
54321

# 解答
alias_method :hoge, :reverse
```

`alias_method`は既に存在するメソッドの別名を付けます。

宣言は`alias 新メソッド名 旧メソッド名`形式で行います。


よく似たメソッドに`alias`があります。異なる点は下記です。

`alias`のメソッド名は識別子かSymbolを受け取ります。

`alias_method`のメソッド名はStringかSymbolを受け取ります。



## 期待した出力結果になるように`XXXX`に適切なコードを選べ

```ruby
class String
  XXXX
end

p "12345".hoge

#
# 実行結果
#
54321
```

1. `alias :hoge, :reverse`

1. `alias :reverse, :hoge`

1. `alias hoge reverse`

1. `alias reverse hoge`



### 解説

`alias`式はメソッドやグローバル変数に別名を付けることができます。

定義は以下のようにします。

```ruby
alias new_method old_method
alias :new_method :old_method
alias $new_global_val $old_global_val
```

メソッド内でメソッドに別名をつける必要がある場合は、`Module#alias_method`を使います。

```ruby
alias_method "new_method", "old_method"
alias_method :new_method, :old_method
```

```ruby
>> class String
>>   alias hoge reverse
>> end
=> nil
>> p "12345".hoge
"54321"
=> "54321"
```






































# アクセサ



## 次のプログラムと同じ結果になる選択肢を選んでください

この問題ではアクセサを`attr_reader`で作成していますが、`alias`で`original_name`として別名をつけています。

新しく定義した`name`メソッドを実行すると、`Mr. Andrew`と表示されます。

```ruby
>> class Human
>>   attr_reader :name
>>
>>   alias original_name name
>>
>>   def name
>>     "Mr. " + original_name
>>   end
>>
>>   def initialize(name)
>>     @name = name
>>   end
>> end
=> :initialize

>> human = Human.new("Andrew")
=> #<Human:0x007f95588e40c8 @name="Andrew">
>> puts human.name
Mr. Andrew
=> nil
```

#### 選択肢1

`alias`と同じくメソッドの別名をつけます。オーバーライドして元のアクセサを呼び出すことができますので、問題と同じ結果になります

```ruby
>> class Human
>>   attr_reader :name
>>
>>   alias_method :original_name, :name
>>
>>   def name
>>     "Mr. " + original_name
>>   end
>>
>>   def initialize(name)
>>     @name = name
>>   end
>> end
=> :initialize

>> human = Human.new("Andrew")
=> #<Human:0x007fa7228176c8 @name="Andrew">
>> puts human.name
Mr. Andrew
=> nil
```

#### 選択肢2

`name`メソッドの中で`super`で親クラスの同名のメソッドを呼び出そうとしていますが、

親クラスのObjectにはそのようなメソッドはありませんので同じ結果になりません。

```ruby
>> class Human
>>   attr_reader :name
>>
>>   def name
>>     "Mr. " + super
>>   end
>>
>>   def initialize(name)
>>     @name = name
>>   end
>> end
=> :initialize

>> human = Human.new("Andrew")
=> #<Human:0x007fd32a0a7670 @name="Andrew">
>> puts human.name
NoMethodError: super: no superclass method 'name' for #<Human:0x007fd32a0a7670 @name="Andrew">
```

* 選択肢3

イニシャライザで初期化したインスタンス変数を`name`メソッドで参照していますので、問題と同じ結果になります。

```ruby
>> class Human
>>   attr_reader :name
>>
>>   def name
>>     "Mr. " + @name
>>   end
>>
>>   def initialize(name)
>>     @name = name
>>   end
>> end
=> :initialize

>> human = Human.new("Andrew")
=> #<Human:0x007feb948cbbf8 @name="Andrew">
>> puts human.name
Mr. Andrew
=> nil
```

* 選択肢4

`name`メソッドの中で同名のメソッドを呼び出していますので、再帰呼出し

終了せず、例外が発生しますので問題と同じ結果にはなりません。

```ruby
>> class Human
>>   attr_reader :name
>>
>>   def name
>>     "Mr. " + name
>>   end
>>
>>   def initialize(name)
>>     @name = name
>>   end
>> end
=> :initialize

>> human = Human.new("Andrew")
=> #<Human:0x007fd656213250 @name="Andrew">
>> puts human.name
SystemStackError: stack level too deep
```




# Refinement

## 次のコードを実行するとどうなりますか

`Refinement`は有効化したスコープのみに影響を与えることが出来ます。

この問題ではクラスオープンした際に`using`で`Refinement`を有効化していますが、

スコープ外は無効になります。

よって、`puts C.new.m1`とした結果は`400`になります。

```ruby
>> class C
>>   def m1
>>     400
>>   end
>> end
=> :m1
>>
>> module M
>>   refine C do
>>     def m1
>>       100
>>     end
>>   end
>> end
=> #<refinement:C@M>
>>
>> class C       # クラスの再オープン時に、refinentを定義している
>>   using M
>> end
=> C
>>
>> puts C.new.m1
400
=> nil
```




## 次のコードを実行するとどうなりますか

同じメソッドに対して`Refinement`で再定義を2つのモジュールで行っています。

もし、`using`を2行書いたとしても **1つのメソッドで有効になる再定義は1つだけ** です。

最後に書いた`using`から優先されます。

この問題では`using R2`が最後に有効化された`Refinement`です。

有効になる再定義は1つだけですので、モジュール`R2`にある`super`はクラス`C`にある`m1`を呼び出します。

よって、`super + 100`は`100 + 100`となり`200`が表示されるのが正解です。

```ruby
class C
  def m1(value)
    100 + value
  end
end

module R1
  refine C do
    def m1
      super 50
    end
  end
end

module R2
  refine C do
    def m1
      super 100
    end
  end
end

using R1
using R2

puts C.new.m1
=> 200
```

一方で、`using R1`に書いた内容はすべて無効になったかというとそういうわけではありません。

次のサンプルコードだとモジュール`R2`に`m2`が定義されていなくても呼び出すことが出来ます。

```ruby
class C
  def m1(value)
    100 + value
  end

  def m2(value)
    value + ", world"
  end
end

module R1
  refine C do
    def m1
      super 50
    end

    def m2
      super "Hello"
    end
  end
end

module R2
  refine C do
    def m1
      super 100
    end
  end
end

using R1
using R2

puts C.new.m1
puts C.new.m2
=> 200
=> Hello, world
```



## 次のコードを実行するとどうなりますか

```ruby
class C
  def self.m1
    200
  end
end

module R
  refine C.singleton_class do
    def m1
      100
    end
  end
end

using R

puts C.m1
=> 100
```



### 解説

`Module#refine`は無名のモジュールを作成します。ブロック内の`self`は無名モジュールになります。

```ruby
>> class C
>> end
=> nil

>> module M
>>   refine C do
>>     self # 無名モジュールを指します
>>   end
>> end
=> #<refinement:C@M>
```

Refinementでクラスメソッドを再定義する場合は次のように`singleton_class`を使います。

ブロックの中で`self.m1`としないのがポイントです。

```ruby
class C
  def self.m1
    'C.m1'
  end
end

module M
  refine C.singleton_class do
    def m1
      'C.m1 in M'
    end
  end
end

using M

puts C.m1
=> C.m1 in M
```



## 次のプログラムを実行するとどうなりますか

```ruby
class C
end

module M
  refine C do
    def m1(value)
      super value - 100
    end
  end
end

class C
  def m1(value)
    value - 100
  end
end

using M

class K < C
  def m1(value)
    super value - 100
  end
end

puts K.new.m1 400
=> 100
```



### 解説

`super`を実行した場合にもRefinementが影響します。

```ruby
class C
end

module M
  refine C do
    def m1(value)
      p "define m1 using Refinement"
      super value - 100 # 300 - 100
    end
  end
end

class C
  def m1(value)
    p "define m1 in C"
    value - 100 # 200 - 100
  end
end

using M # ここからRefinementが有効になる

class K < C
  def m1(value)
    p "define m1 in K"
    super value - 100 # 400 - 100
    # Refinementが有効なのでsuperはモジュールMにあるm1を参照する
  end
end

puts K.new.m1 400
```

プログラムを実行するとコメントは次の順に表示されます。

1. "define m1 in K"

1. "define m1 using Refinement"

1. "define m1 in C"

`super`を実行したクラスの親クラスにRefinemnetがあれば同名のメソッドを探索して実行します。

さらに、Refinementのなかで`super`を実行するとRefinementの対象クラスのメソッドを探索します。



## 次のコードを実行するとどうなりますか

`using`はメソッドの中で呼び出すことは出来ません。呼び出した場合は`RuntimeError`が発生します。

```ruby
>> class C
>> end
=> nil
>>
>> module M
>>   refine C do
>>     def m1
>>       100
>>     end
>>   end
>> end
=> #<refinement:C@M>
>>
>> class C
>>   def m1
>>     400
>>   end
>>
>>   def self.using_m
>>     using M
>>   end
>> end
=> :using_m
>>
>> C.using_m
RuntimeError: Module#using is not permitted in methods
>>
>> puts C.new.m1
400
=> nil
```



## 次のコードを実行するとどうなりますか

```ruby
class C
  def m1
    200
  end
end

module R
  refine C do
    def m1
      300
    end
  end
end

using R

class C
  def m1
    100
  end
end

puts C.new.m1
=> 300
```

Refinementで再定義したメソッドの探索ですが、prependより優先して探索が行われます。

例えば、クラスCはクラスBを継承しているとすると次のような順に探索を行います。

Refinement -> prependしたモジュール -> クラスC -> includeしたモジュール -> クラスCの親（クラスB）

問題では`using`の後にクラスオープンしてメソッドを再定義していますが、Refinementにある`300`が表示されます。

> 探索についてもう一度復習！
>
> 2018/11/03
