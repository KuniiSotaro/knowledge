動的なプログラミング
================

## 7-1.オープンなクラス

Rubyでは、既に定義されたクラスに対して再度メソッドを定義し直したり、メソッドを追加することができる

* オープンクラス：定義済みクラスの拡張が可能で、後から拡張することができる機能

* 自分で定義したクラス以外にも、組み込みクラスに対してもオープンクラスによって変更を加えることができる



### 7-1-1.オープンクラス

同名のクラスを複数回定義してもエラーにはならない

class式は **クラスオブジェクトが存在しない場合に生成** する。

既にクラスオブジェクトが存在する場合には、そのオブジェクトをもう一度「開いて」評価する

```ruby
>> class Hoge
>>   def fuga1; end
>> end
=> :fuga1
>>
?> class Hoge
>>   def fuga2; end
>> end
=> :fuga2
>>
?> Hoge.instance_methods(false)
=> [:fuga1, :fuga2]
```

* 最初の`class Hoge`の段階では、まだクラスは存在していない。Rubyがこのクラス(と`fuga1`メソッド)の定義の中に入った時に始めてクラスを定義

* 2回目の`class Hoge`の段階では、既にそのクラスは存在しているので改めてクラスを定義する必要がない

* いつでもクラスを再オープンして、その場で修正できる
  → **オープンクラス**

* 一度定義したクラスを再定義のために開くこと

  → **クラスの再オープン**

例)Ruby on Railsの添付されているActiveSupportのcore_extによる拡張

  →オープンクラスを利用して、StringやArrayなどの組み込みクラスに様々な便利機能を提供



### 7-1-3.オープンクラスの問題点

組み込みクラスを再オープンするとき、同名のメソッドを上書きするとプログラム全体がバグを起こす

→ **モンキーパッチ**

```ruby
>> class String
>>   def huga; 1; end
>>   def reverse; 2; end
>> end
=> :reverse
>>
?> p "my string".huga
1
=> 1
>> p "my string".reverse   # 上書きされたメソッドで実行されている
2
=> 2
```

スーパークラスを指定して再オープンする場合、スーパークラスはオープンする前のクラスと同じでなければならない

```ruby
>> class Foo; end
=> nil
>> class Bar; end
=> nil
>> class Baz < Foo
>> end
=> nil

>> class Baz < Bar
>> end
TypeError: superclass mismatch for class Baz

>> class Baz < Foo   # OK
>> end
=> nil

>> class Baz         # OK
>> end
=> nil
```


## 7-2.`Refinements`

* Rubyは既存のクラスに対して、メソッドを任意に変更したり追加することができるが、一度書き換えると全体へ影響を及ぼす

* この問題の解決策として、`Refinements`と言う仕組みができた

* オープンクラスによる機能拡張の影響範囲を、より細かい範囲に限定することができる



### 7-2-1. `Refinements`の基本

* `refine`メソッドで変更を加えるクラスを宣言

  →引数にクラス・モジュールをとり、ブロック内で引数のクラスに対しての処理を記述する

* `using`メソッドを呼び出した以降から、変更したメソッドの呼び出しが有効になる

```ruby
module StringExtensions
  refine String do
    def to_alphanumeric
      gsub(/[^\w\s]/, '')
    end
  end
end

"my *1st* refinement!".to_alphanumeric
using StringExtensions
"my *1st* refinement!".to_alphanumeric

# 実行結果
NoMethodError: undefined method 'to_alphanumeric' for "my *1st* refinement!":String
"my 1st refinement"  # usingを使用しているので、変更される
```



#### トップレベルでusingする

* トップレベルで`Module#refine`したモジュールをusingした場合、usingした後のそのファイル内でRefinementsが有効になる

* ファイルの中でのみusingできることは忘れてはいけない

```ruby
reqiure_relative 'refine_module'

using refineModule

'Bob.hello'
```

```ruby
$ ruby using_module.rb
"Bob.hello"
```



#### ModuleまたはClassのコンテキストでusingする

* モジュールの中でも`using`を呼び出すことができ、モジュールの定義の終わりまで有効

* `refine`ブロックそのもので有効になる

* `using`を呼び出した場所からファイルの終わりまで(トップレベルにいる場合)有効になる

```ruby
>> module StringExtensions
>>   refine String do
?>     def reverse
>>       "esrever"
>>     end
>>   end
>> end
=> #<refinement:String@StringExtensions>

?> module StringStuff
>>   using StringExtensions
>>   "my_string".reverse
>> end
=> "esrever"

?> "my_string".reverse
=> "gnirts_ym"
```



### Refinementsを使ってクラスメソッドを定義する

* `refine`ブロックの中では、Refinements用に定義された特殊なModuleのスコープで評価される

  →その中で`self`を呼んでも、拡張対象のクラスを指定したことにならない

* `Object#singleton_class`を用いて、クラスメソッドを定義する

  →あるクラスの特異クラスをRefinementsで拡張することで、クラスメソッドをRefinementsの拡張対象として定義することができる

```ruby
module RefineModule
  refine String.singleton_class do
    def hello
      puts "#{self} hello class"
    end
  end
end

using RefineModule
String.hello
```

```ruby
# 実行結果
String hello class
```


### 7-2-2.`Refinements`の問題点

* `using`の呼び出しの後に`my_method`を呼び出すと、refineされたバージョンのメソッドが手に入る

* 一方、`using`の後に`another_method`を呼び出すと、元のrefineされていないバージョンのメソッドが呼び出される

  →メソッド呼び出しの時に、再確認する必要がある

```ruby
class MyClass
  def my_method
    "original my_method"
  end

  def another_method
    my_method
  end
end

module MyClassRefinements
  refine MyClass do
    def my_method
      "refined my_method"
    end
  end
end

using MyClassRefinements
MyClass.new.my_method
MyClass.new.another_method

# 実行結果
"refined my_method"
"original my_method"
```

* 他にも、クラスはモジュールであるにも関わらず、クラスの中では呼び出せない

* `methods`や`ancestors`などのメタプログラミングのメソッドは、`Refinements`を無視する



#### 他の注意点

* もし、`using`を2行書いたとしても **1つのメソッドで有効になる再定義は1つだけ** です。

* 最後に書いた`using`から優先されます。

* `using`はメソッドの中で呼び出すことは出来ません。呼び出した場合は`RuntimeError`が発生します。

* Refinementで再定義したメソッドの探索ですが、prependより優先して探索が行われます。

  例)Refinement -> prependしたモジュール -> クラスC -> includeしたモジュール -> クラスCの親（クラスB）



| 版 |  年/月/日 |
|---|-----------|
|初版|2018/11/03|
