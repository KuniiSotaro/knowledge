5-7.`Array`クラス
================

## 5-7-1.配列の生成

* `配列式`と呼ばれる記法で配列を生成

* `Array`クラスのクラスメソッドである、 **`[]`メソッド** や **`new`メソッド** を使って配列を生成

```ruby
# 配列の生成(1)
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.class
=> Array

# 配列の生成(2)
>> Array[1, 2, 3]            # `[]`メソッドは、引数に要素を指定
=> [1, 2, 3]

# 配列の生成(3)
>> Array.new(3, "str")       # `new`メソッドでの、配列の長さと初期値を指定
=> ["str", "str", "str"]

# 配列の生成(4)
>> Array.new([1, 2, 3])      # `new`メソッドでの、引数に配列を指定する方法(配列の複製)
=> [1, 2, 3]

# 配列の生成(5)
>> Array.new(3) {|i| i * 3}  # `new`メソッドに、配列の長さとブロックを渡す方法(ブロックには、配列のインデックスを渡す)
=> [0, 3, 6]
```

***

## 5-7-2.配列に要素を追加する

### 全て破壊的メソッドなので、注意する

* `<<`メソッド・`push`メソッド：指定された引数にあるオブジェクトを、自分自身の末尾に追加

* `concat`メソッド：指定された配列を、自分自身の末尾に連結

* `insert`メソッド：1番目の引数で指定された場所に、それ以降で指定されたオブジェクトを挿入

* `unshift`メソッド：指定されたオブジェクトを、配列の先頭に追加。引数がない場合は実行しない

```ruby
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a << 4                      # 末尾に[4]を追加
=> [1, 2, 3, 4]
>> a.concat [5, 6]             # 末尾に[5,6]を追加
=> [1, 2, 3, 4, 5, 6]
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.unshift(10)               # 配列aの先頭に、[10]を追加
=> [10, 1, 2, 3]
```

### 以下、非破壊メソッド

* `+`メソッド：自分自身と引数で与えられた配列を連結した配列を新たに生成して返す

```ruby
>> a = [1, 2, 3, 9, 4, 5, 6]   # 配列の3番目に、[9]を追加
[1, 2, 3, 9, 4, 5, 6]
>> a.object_id
=> 70235495510920
>> b = a + [10]                # 配列aの末尾に、10を追加
=> [1, 2, 3, 9, 4, 5, 6, 10]
>> b.object_id
=> 70235499700020
```

***

## 5-7-3.配列の要素を変更する

* `[]=`メソッド：指定したインデックスにある要素を書き換える

※インデックスは、整数や`Range`オブジェクト、始点と終点を指定可能。
配列の要素数よりも大きな数が指定された場合は、自動的に配列の長さが伸長され、その部分は`nil`で初期化される。

* `fill`メソッド：配列の全ての要素を指定したオブジェクトに変更

※引数を2つ以上取る場合は、配列の始点と終点や、`Range`オブジェクトを取ることもでき、その場合は該当する部分のみ変更する。
ブロックを取ることもでき、その場合はブロックの評価結果で要素を変更する。

* `replace`メソッド：引数で指定された配列で、自分自身の内容を置き換える。オブジェクトIDが変化しない。

```ruby
# `[]=`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a[1] = 10          # 配列の1番目に、10を追加
=> 10
>> a
=> [1, 10, 3]
>> a[1..2] = [11, 12] # 配列の1〜2番目に、11と12を追加
=> [11, 12]
>> a
=> [1, 11, 12]
>> a[8] = 8           # 配列の8番目に、8を追加(3〜7番目は`nil`)
=> 8
>> a
=> [1, 11, 12, nil, nil, nil, nil, nil, 8]

# `fill`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.fill("s")                   # aの配列の内容を、全て"s"に変更
=> ["s", "s", "s"]
>> a.fill("t", 1..2)             # aの配列のうち、1〜2番目を"t"に変更
=> ["s", "t", "t"]
>> a
=> ["s", "t", "t"]
>> a.fill("u", 1, 2)             # 第1引数："u"に変更、第2引数：1番目から、第3引数：2文字分
=> ["s", "u", "u"]
>> a.fill(1..2){|index| index}   # aの配列のうち、1〜2番目を1、2に変更
=> ["s", 1, 2]

# `replace`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.object_id
=> 70273659485340
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.object_id          # 異なるオブジェクトID
=> 70273659433960
>> a.replace([4, 5, 6])
=> [4, 5, 6]
>> a.object_id
=> 70273659433960       # 置換する前と同じオブジェクトID
```

***

## 5-7-4.配列の要素を参照する

* `[]`メソッド：変更の場合と同様に、 **整数** や **`Range`オブジェクト** 、始点と終点で指定したインデックスに対応する要素を返す

* `slice`メソッド：`[]`メソッドと同様

* `at`メソッド：`[]`メソッドと同様だが、インデックスが整数の場合に利用する。要素数よりも大きい場合は、`nil`を返す

* `values_at`メソッド：`[]`メソッドと同様の動作をするが、結果を配列で返す

```ruby
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a[1]            # 配列aの1番目の値を取り出す
=> 2
>> a.at(1)         # 配列aの1番目の値を取り出す
=> 2
>> a[1..2]         # 配列aの1〜2番目の配列を取り出す
=> [2, 3]
>> a.values_at(1)  # 配列aの1番目の配列を取り出す
=> [2]
```

***

* `fetch`メソッド：`at`メソッドと同様。引数がインデックスのみの場合は、`IndexError`が発生する。
  2番目の引数がある場合にはその値を、ブロックを取っている場合はその評価結果を返す

* `first`メソッド：配列の先頭を返す。引数が指定された場合は、先頭から指定した数だけ要素を返す

* `last`メソッド：配列の末尾の要素を返す。引数が指定された場合は、末尾から指定した数だけ要素を返す

* `assoc`メソッド：配列の配列を検索し、その配列の最初の要素が指定された値と`==`で等しければ、その配列を返す
  該当する要素がなければ、`nil`を返す

* `rassoc`メソッド：配列の配列を検索し、その配列のインデックス1の要素が指定された値と`==`で等しければ、その要素を返す

```ruby
# `fetch`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.fetch(4)
IndexError: index 4 outside of array bounds: -3...3
>> a.fetch 4, "ERROR"
=> "ERROR"
>> a.fetch(4){|n| "ERROR #{n}"}
=> "ERROR 4"

# `first`、`last`メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.first
=> 1
>> a.last
=> 5
>> a.first(3)   # 最初から3個まで出力
=> [1, 2, 3]

# `assoc`メソッド
>> a = [[1, 2], [3, 4], [5, 6], [7, 8]]
=> [[1, 2], [3, 4], [5, 6], [7, 8]]
>> a.assoc(3)     # 配列の最初の要素が3の配列は、[3, 4]
=> [3, 4]

# `rassoc`メソッド
>> a = [[1, 2], [3, 4], [5, 6], [7, 8]]
=> [[1, 2], [3, 4], [5, 6], [7, 8]]
>> a.rassoc(4)    # 配列の要素に4が含まれる配列は、[3, 4]
=> [3, 4]
```

***

## 5-7-5.配列の要素を調べる

* `include?`メソッド：指定された値が要素の中に存在する場合に、 **真** を返す

* `index`、`rindex`メソッド：それぞれの配列の先頭と末尾から指定された値と`==`で等しい要素の位置を返す
  見つからない場合は、`nil`を返す。

※`rindex`は末尾から探すが、配列の位置は末尾から指定できないので、`index`と同じインデックスとなる。

```ruby
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.include?(3)
=> true
>> a.include?(10)
=> false
>> a.index(4)
=> 3
>> a.rindex(4)
=> 3
```

***

## 5-7-6.配列の要素を削除する

### 全て破壊的メソッドなので注意！

* `delete_at`メソッド：指定されたインデックスに対応する要素を取り除き、その要素を返す

* `delete_if`・`reject!`メソッド：ブロックに要素を渡し、その評価結果が真になった要素を全て取り除いた自分自身を返す。
  →Silverではよく間違えていた！！

* `delete`メソッド：指定された値と`==`メソッドで等しい要素があれば、取り除いてその値を、なければ`nil`を返す

* `clear`メソッド：要素を全て削除する

* `slice!`メソッド：指定されたインデックスに対応する要素を取り除き、その取り除いた要素を返す。(インデックスには整数やRangeオブジェクト、視点と長さを指定可能)

* `shift`メソッド：先頭から指定された数だけ要素を取り除いて返す。指定がなければ、1が指定されたとして先頭の要素を返す

* `pop`メソッド：末尾から指定された数だけ要素を取り除いて返す。指定がなければ、1が指定されたとして末尾の要素を返す(`shift`メソッドの逆)

* `-`メソッド：指定された配列にある要素を、自分自身から取り除いた配列を返す

```ruby
# delete_atメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete_at(2)
=> 3
>> a
=> [1, 2, 4, 5]

# delete_ifメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete_if{|n| n % 2 == 0}
=> [1, 3, 5]

# deleteメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete(3)
=> 3
>> a
=> [1, 2, 4, 5]
>> a.delete(10)
=> nil
>> a
=> [1, 2, 4, 5]

# clearメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.clear
=> []

# slice!メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.slice!(2,2)        # 2番目から2つの値を削除(2、3番目の値を削除)
=> [3, 4]
>> a
=> [1, 2, 5]

# shiftメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.shift(2)           # 先頭から2個削除
=> [1, 2]
>> a
=> [3, 4, 5]
>> a.shift              # 先頭から1個削除
=> 3
>> a
=> [4, 5]

# popメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.pop(2)             # 末尾から2個削除
=> [4, 5]
>> a
=> [1, 2, 3]
>> a.pop                # 末尾から1個削除
=> 3
>> a
=> [1, 2]

# -メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a - [1, 2]
=> [3, 4, 5]
>> a - [1, 3, 5, 7]
=> [2, 4]
```

***

## 5-7-7.配列の演算

Rubyでは、配列を集合と見なした演算ができる

* `|`メソッド：和集合を求める。両方のいずれかに含まれる要素を含む配列を返す

* `&`メソッド：積集合を求める。両方に含まれる要素を含む配列を返す

```ruby
# |メソッド
>> [1, 2, 3] | [1, 3, 5]
=> [1, 2, 3, 5]

# &メソッド
>> [1, 2, 3] & [1, 3, 5]
=> [1, 3]
```

***

## 5-7-8.配列の比較

* `==`メソッド：配列同士を比較する。先頭から要素を比較し、全ての要素が等しければその結果を返す

* `<=>`メソッド：先頭から比較し、同じであれば`0`、左辺が大きければ`1`、右辺が大きければ`-1`を返す

```ruby
>> [1, 2, 3] == [1, 3, 5]
=> false
>> [1, 2, 3] <=> [1, 3, 5]
=> -1
```

***

## 5-7-9.配列の要素での繰り返し

* `each`メソッド：ブロックに各要素が渡る

* `each_index`メソッド：配列のインデックスが渡る

* `reverse_each`メソッド：要素の逆順に繰り返す

* `cycle`メソッド：配列の要素を順に繰り返し、末尾まで来たらまた先頭に戻って繰り返し続ける

```ruby
# eachメソッド
>> [1, 3, 5, 7, 9].each{|n| puts n * 2}
2
6
10
14
18
=> [1, 3, 5, 7, 9]

# each_indexメソッド
>> [1, 3, 5, 7, 9].each_index{|n| puts n * 2}
0
2
4
6
8
=> [1, 3, 5, 7, 9]

# reverse_eachメソッド
>> [1, 3, 5, 7, 9].reverse_each{|n| puts n * 2}
18
14
10
6
2
=> [1, 3, 5, 7, 9]

# cycleメソッド
>> [1, 2, 3].cycle{|n| puts n }
1
2
3
1
2
3
# ...(省略)
```

***

## 5-7-10.配列の要素を連結する

* `join`、`*`メソッド：配列の要素を指定された区切り文字で連結した文字列を返す

```ruby
>> [1, 2, 3].join(",")
=> "1,2,3"
```

***

## 5-7-11.配列の長さを求める

* `length`、`size`メソッド：配列の長さを求める。空の場合は0を返す

* `empty?`メソッド：配列が空の場合に真を返す

```ruby
>> [1, 2, 3].length
=> 3
>> [].length
=> 0
>> [].empty?
=> true
```

***

## 5-7-12.配列をソートする

* `sort`メソッド：配列をソートする。要素同士の比較は、`<=>`メソッドが使用される。

* ブロックが与えられた場合、2つの要素が渡され、その評価結果に応じてソートされる。

  * 正の整数：1つ目の要素が大きい

  * 0：同じ

  * 負の整数：2つ目の要素が大きい


```ruby
>> a = [1, 3, 5, 2, 4, 6]
=> [1, 3, 5, 2, 4, 6]
>> a.sort
=> [1, 2, 3, 4, 5, 6]
>> a
=> [1, 3, 5, 2, 4, 6]
>> a.sort!                 # 破壊的メソッド(自分自身をソート結果で書き換える)
=> [1, 2, 3, 4, 5, 6]
>> a
=> [1, 2, 3, 4, 5, 6]

# ブロックが与えられた場合
>> [1, 3, 5, 2, 4, 6].sort{|a, b| a <=> b}    # 0番目と1番目の数を比べて、1番目の数の方が大きい場合(負の整数・・・1番目の方が大きいとしてソート)
=> [1, 2, 3, 4, 5, 6]
>> [1, 3, 5, 2, 4, 6].sort{|a, b| b <=> a}    # 1番目と0番目の数を比べて、0番目の数の方が大きい場合(正の整数・・・0番目の方が大きいとしてソート)
=> [6, 5, 4, 3, 2, 1]
```

このブロックはわからないので、省略
2018/9/8

問題解決
2018/9/29

***

## 5-7-13.配列を変換する

### `!`が付いているものは、全て破壊的メソッド

* `uniq`メソッド：配列から重複した要素を取り除いた配列を返す

* `uniq!`メソッド：`uniq`メソッドと同じだが、取り除かれなかった場合に`nil`を返す

* `compact`メソッド：要素の`nil`を取り除いた配列を返す。

* `compact!`メソッド：`compact`メソッドと同じだが、取り除かれなかった場合に`nil`を返す

* `reverse`メソッド：配列の要素を逆順に並べ替えた配列を返す

* `flatten`メソッド：配列を再帰的に平滑化した配列を返す。引数が指定された場合は、その深さまで再帰的に平滑化する。

* `flatten!`メソッド：`flatten`メソッドと同じだが、平滑化されなかった場合には`nil`を返す

* `map`、`collect`メソッド：要素ごとにブロックを評価し、その結果で要素を書き換えた配列を返す

* `shuffle`メソッド：配列の要素をシャッフルして返す

```ruby
# uniqメソッド
>> [1, 1, 2, 3, 3].uniq
=> [1, 2, 3]

# compactメソッド
>> [1, nil, 2, nil, 3].compact
=> [1, 2, 3]

# reverseメソッド
>> [1, 2, 3, 4, 5].reverse
=> [5, 4, 3, 2, 1]

# flattenメソッド
>> [[[1, 2], 3], [[4, 5], 6]].flatten
=> [1, 2, 3, 4, 5, 6]
>> [[[1, 2], 3], [[4, 5], 6]].flatten(1)
=> [[1, 2], 3, [4, 5], 6]

# mapメソッド
>> [1, 2, 3, 4, 5].map{|n| n * 2}
=> [2, 4, 6, 8, 10]

# shuffleメソッド
>> [1, 2, 3, 4, 5].shuffle
=> [5, 1, 2, 3, 4]
```

***

## 5-7-14.配列を組み合わせて生成する

* `product`メソッド：自身と与えられた配列から1つずつ要素を取って組み合わせた配列を作り、その全ての組み合わせを要素とする配列を返す

* `zip`メソッド：自身と与えられた配列から1つずつ要素を取って配列を作り、それを要素とする配列を返す。`product`メソッドとは異なり、
  組み合わせは前から順に同じインデックスのもののみとなる。ブロックが与えられた場合は、自分自身と引数に指定された配列を順にブロックに渡す。

* `*`メソッド：与えられた数値の分だけ、繰り返した配列を返す

```ruby
# productメソッド
>> [1, 2].product(["a", "b", "c"])
=> [[1, "a"], [1, "b"], [1, "c"], [2, "a"], [2, "b"], [2, "c"]]

# zipメソッド
>> [1, 2].zip(["a", "b"])
=> [[1, "a"], [2, "b"]]
>> [1, 2].zip(["a", "b"], ["x", "y"])
=> [[1, "a", "x"], [2, "b", "y"]]

# zipメソッドの便利な手法
ary1 = [1,2,3,4,5]
ary2 = [10,20,30,40,50]
ary3 = [100,200,300,400,500]

result = []
ary1.zip(ary2,ary3) do |a,b,c|
  result << a + b + c
end
p result
[111, 222, 333, 444, 555]

# *メソッド
>> [1, 2] * 4
=> [1, 2, 1, 2, 1, 2, 1, 2]
```


※Silverで間違えている

* `Array#zip`は、自身と引数に渡した配列の各要素からなる配列を生成して返す。
  ブロックを渡した場合は、各要素を順番に返す

* `Array#transpose`は、2次元配列の行と列を入れ替えるメソッド

```ruby
# 1問目
>> a.zip(b).each{|x| p x}
["a", 1]
["b", 2]
["c", 3]
=> [["a", 1], ["b", 2], ["c", 3]]

# 2問目
>> a.zip(b){|x| p x}
["a", 1]
["b", 2]
["c", 3]
=> nil

# 3問目
>> [a, b].zip{|x, y| p [x, y]}
["a", "b"]
[1, 2]
=> nil

# 4問目
>> [a, b].transpose.each{|x, y| p [x, y]}
["a", 1]
["b", 2]
["c", 3]
=> [["a", 1], ["b", 2], ["c", 3]]
```

***

## 5-7-15.配列をパックする

* `pack`メソッド：自身を指定されたテンプレートに従ってパックする。

```ruby
>> ["ルビー"].pack('m')
=> "44Or44OT44O8\n"
```
