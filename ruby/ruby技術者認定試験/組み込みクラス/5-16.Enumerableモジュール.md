5-16.`Enumerable`モジュール
=========================

* `Array`、`Hash`クラスにインクルードされている

* 全てのメソッドが`each`メソッドを元に定義されているため、`each`メソッドが定義されているクラスであれば、そのクラスでも利用可能

## `map`、`collect`メソッド

* 与えられたブロックを評価した結果の配列を返す

```ruby
>> [1, 2, 3, 4, 5].map{|i| i ** 2}
=> [1, 4, 9, 16, 25]
```

## `each_with_index`メソッド

* 要素とそのインデックスをブロックに渡して繰り返す

```ruby
>> [:a, :b, :c, :d, :e].each_with_index{|v, i| puts "#{v} => #{i}"}
a => 0
b => 1
c => 2
d => 3
e => 4
=> [:a, :b, :c, :d, :e]
```

## `inject`、`reduce`メソッド

* `Enumerable#inject`：ブロックを使用して繰り返し計算を行います。自身のたたみこみ演算を行う(初期値と自身の要素を順に組み合わせて結果を返す)

  * 引数を省略した場合は、配列の先頭がブロック引数の1番目に渡されます。

  * 引数を指定した場合は、その値が初期値になります。

  * ブロック引数の1番目は前回の戻り値が渡されます。初回は、初期値が渡されます。

  * ブロック引数の2番目は要素が順番に渡されます

```ruby
>> [1, 2, 3, 4, 5].inject(0) {|result, v| result + v ** 2}  # 1から5までの数値の2乗の和を求める(1+4+9+16+25=55)
=> 55
```

※Silverでかなり間違えている

```ruby
>> p [1, 2, 3].inject{|x, y| x + y ** 2} rescue p $!
14
=> 14
>> p [1, 2, 3].inject(0){|x, y| x + y ** 2} rescue p $!
14
=> 14
>> p [1, 2, 3].inject([]){|x, y| x << y ** 2} rescue p $!
[1, 4, 9]
=> [1, 4, 9]
>> p [1, 2, 3].inject do|x, y| x + y ** 2 end rescue p $!
#<LocalJumpError: no block given>
=> #<LocalJumpError: no block given>
```

```ruby
# injectメソッドを使用しない場合
>> sum = 0
=> 0
>> (1..10).each {|i| sum += i }
=> 1..10
>> puts sum
55
=> nil

# injectメソッド使用時
>> (1..10).inject(0) {|sum, i| sum + i }
=> 55

# injectメソッド使用時(引数なし)
>> (1..10).inject {|sum, i| sum + i }
=> 55
```

### 一行目

```ruby
>> p [1, 2, 3].inject{|x, y| x + y ** 2} rescue p $!
14
=> 14

# 解説
5 = 1 + 2 ** 2  # 配列の最初の要素は1なので、xに1がセット、yに2がセット
14 = 5 + 3 ** 2 # 最後に、xが5にセット、yに3がセット
```

### 二行目

```ruby
>> p [1, 2, 3].inject(0){|x, y| x + y ** 2} rescue p $!
14
=> 14

# 解説
1 = 0 + 1 ** 2   # 初期値は0なのでで、xに0がセット、yに1がセット
5 = 1 + 2 ** 2   # xに1がセット、yに2がセット
14 = 5 + 3 ** 2  # xに5がセット、yに3がセット
```

### 三行目

```ruby
>> p [1, 2, 3].inject([]){|x, y| x << y ** 2} rescue p $!
[1, 4, 9]
=> [1, 4, 9]

# 解説
[1] = [] << 1 ** 2            # 初期値としてxに[]がセット、yに1がセット
[1, 4] = [1] << 2 ** 2        # xに[1]がセット、yに2がセット
[1, 4, 9] = [1, 4] << 3 ** 2  # xに[1,4]がセット、yに3がセット
```

### 四行目

`[1, 2, 3].inject`までが`p`メソッドの引数となるため、`p`メソッドへブロックが不正に渡されるため、エラーとなります。

```ruby
>> p([1, 2, 3].inject) do|x, y|    # ブロックのdo...end記法は、pの引数が実行
?>   x + y ** 2
>> end rescue p $!
#<LocalJumpError: no block given>
=> #<LocalJumpError: no block given>
```


```ruby
>> p (1..10).lazy.map{|num|
?>   num * 2
>> }.take(3).inject(0, &:+)
12
=> 12

# 解説
p (1..10).lazy.map{|num| num * 2 }.take(3).inject(0, &:+) # 3回遅延評価をしたら、出力する。(1*2)+(2*2)+(3*2)=12
```


```ruby
>> numbers = [3,89,40,39,29,10,50,59,69]
=> [3, 89, 40, 39, 29, 10, 50, 59, 69]
>> num = numbers.inject do |i,j|       # 一番最初にi > jとなるのは、89 > 40。よって、89が変数numに代入される
?>   i > j ? i : j
>> end
=> 89
>> p num
89
=> 89
```

***

## `each_slice`、`each_cons`メソッド

* `each_slice`：要素を指定された数で区切ってブロックに渡す。要素数が指定された数で割きれない場合は、最後だけ渡される数が少なくなる

* `each_cons`：先頭から要素を1つずつ選び、さらに余分に指定された数に合うように要素を選び、それらをブロックに渡していく

```ruby
# each_consメソッド
>> (1..10).each_cons(3) {|items| p items}
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
=> nil

# each_sliceメソッド
>> (1..10).each_slice(3) {|items| p items}
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]
=> nil
```

## `reverse_each`メソッド

* `each`メソッドとは逆順にブロックに要素を渡して繰り返す

```ruby
>> [1, 2, 3, 4, 5].reverse_each {|i| puts i}
5
4
3
2
1
=> [1, 2, 3, 4, 5]
```

## `all?`、`any?`、`none?`、`one?`、`member?`、`include?`メソッド

* `all?`：全ての要素が真であれば`true`を返す

* `any?`：真である要素が1つでもあれば`true`を返す

* `none?`：全ての要素が偽であれば`true`を返す

* `one?`：1つの要素だけが真であれば`true`を返す

* `member?`、`include?`：指定された値と`==`メソッドが`true`となる要素がある場合に`true`を返す

```ruby
>> [1, nil, 3].all?
=> false
>> [1, nil, 3].any?
=> true
>> [].all?
=> true
>> [].any?
=> false

# include?メソッド
>> [1, 2, 3, 4, 5].include?(3)
=> true
```

※Silverで間違えている

`Enumerable#any?`はブロックの戻り値が`true`になると繰り返しをその時点で止めます。
繰り返しが止まるのは3回目の繰り返し、つまり`$val`が3になった時点です。

```ruby
>> $val = 0
=> 0
>>
?> class Count
>>   def self.up
>>     $val = $val + 1
>>     $val == 3 ? true : false
>>   end
>> end
=> :up
>>
?> [*1..10].any? do
?>   Count.up
>> end
=> true
>>
?> p $val
3
=> 3
```

***

## `find`、`find_index`、`select`などのメソッド

* `find`、`detect`：ブロックを評価して最初に真となる要素を返す
  →何度もSilverで間違っている

* `find_index`：要素の代わりにインデックスを返す

* `find_all`、`select`：ブロックの評価が真となる全ての要素を返す
  →何度もSilverで間違っている

* `reject`：偽になった全ての要素を返す

* `grep`：指定したパターンとマッチする(`==`メソッドが`true`となる)要素を全て含んだ配列を返す

```ruby
>> [1, 2, 3, 4, 5].find {|i| i % 2 == 0}
=> 2
>> [1, 2, 3, 4, 5].find_index {|i| i % 2 == 0}
=> 1
>> [1, 2, 3, 4, 5].select {|i| i % 2 == 0}
=> [2, 4]
```

※Silverで間違えている

* `Enumerable#select`：ブロックの戻り値がtrueになる要素を配列にして返します。レシーバーをすべて走査して繰り返しを終了します。

配列の長さは10ですので、ブロックの戻り値がtrueかを問わず10が表示されます。

```ruby
>> $val = 0
=> 0
>>
?> class Count
>>   def self.up
>>     $val = $val + 1
>>     $val == 3 ? true : false
>>   end
>> end
=> :up
>>
?> [*1..10].select do   # *1で、配列として展開
?>   Count.up
>> end
=> [3]
>>
?> p $val
10
=> 10
```

***

## `sort`、`sort_by`メソッド

* `sort`：要素を`<=>`メソッドで比較して昇順にソートした配列を、新たに生成して返す。ブロックをとる場合は、ブロックの評価結果を元にソートする

* `sort_by`：ブロックの評価結果を`<=>`メソッドで比較して昇順にソートした配列を使って、元の配列をソートした新しい配列を生成して返す

```ruby
>> ["aaa", "b", "cc"].sort{|a, b| a.length <=> b.length} # 1番目の引数の方が大きい場合は、正の数・・・徐々に大きくなる
=> ["b", "cc", "aaa"]
>> ["aaa", "b", "cc"].sort_by{|a| a.length}
=> ["b", "cc", "aaa"]
```

## `max`、`min`メソッド

* それぞれ要素の最大値と最小値を返す

* `<=>`メソッドで比較するため、全ての要素がそれに対応する必要がある

* ブロックを渡すと、ブロックの評価結果を元に大小判定を行う

* `max_by`、`min_by`：ブロックの評価結果が最大であった要素を返す

```ruby
>> (1..10).map{|v| v % 5 + v}
=> [2, 4, 6, 8, 5, 7, 9, 11, 13, 10]
>> (1..10).max{|a, b| (a % 5 + a) <=> (b % 5 + b)}
=> 9
>> (1..10).max_by{|v| v % 5 + v}
=> 9
```

## `count`メソッド

* 要素数を返す

```ruby
>> [1, 2, 3, 4, 5].count
=> 5
```

## `cycle`メソッド

* 要素を先頭から順に取り出し、末尾まで到達したら再度先頭に戻り、それを繰り返す

```ruby
>> [:a, :b, :c].cycle{|v| p v}
:a
:b
:c
:a
# 省略
```

## `group_by`メソッド

* ブロックの評価結果をキーとし、同じキーを持つ要素を配列としたハッシュを返す

```ruby
>> (1..10).group_by{|v| v % 2}
=> {1=>[1, 3, 5, 7, 9], 0=>[2, 4, 6, 8, 10]} # 余りは1か0のどれか
```

## `zip`メソッド

* 自身と引数に指定した配列から、1つずつ要素を取り出して配列を作り、それを要素とする配列を返す

```ruby
>> [:a, :b, :c].zip([1, 2, 3], ["a", "b", "c"])
=> [[:a, 1, "a"], [:b, 2, "b"], [:c, 3, "c"]]
```

## `first`、`take`メソッド

* `take`：先頭から指定した数の要素を配列として返す

* `first`：`take`メソッドと同じだが、数を指定しない場合に先頭の要素のみを返す

```ruby
>> [:a, :b, :c].take(2)
=> [:a, :b]
>> [:a, :b, :c].first
=> :a
```

## `take_while`、`drop`メソッド

* `take_while`：先頭からブロックを評価し、最初に偽になった要素の直前までを返す

* `drop`：`take`メソッドとは逆に、先頭から指定した数の要素を取り除いた残りの要素を配列として返す

```ruby
# take_whileメソッド
>> [:a, :b, :c, :d, :e].take_while { |e| e != :d }
=> [:a, :b, :c]

# dropメソッド
>> [:a, :b, :c, :d, :e].drop(3)
=> [:d, :e]
```

## `drop_while`メソッド

* 先頭からブロックを評価し、最初に偽になった要素の手前までを切り捨て、残りの要素を配列として返す

```ruby
>> [:a, :b, :c, :d, :e].drop_while { |e| e != :c}
=> [:c, :d, :e]
```

## `select`、`reject`メソッド

* `select`：各要素に対してブロックの評価結果が真であった要素を含む配列を返す

* `reject`：ブロックの評価結果が偽であった要素を含む配列を返す

```ruby
>> [1, 2, 3, 4, 5].select { |e| e % 2 == 0 }
=> [2, 4]
>> [1, 2, 3, 4, 5].reject { |e| e % 2 == 0 }
=> [1, 3, 5]
```

## `lazy`メソッド

* `map`、`select`メソッドなどのメソッドが、遅延評価を行うように再定義される

* 遅延評価になるとそれぞれのメソッドが配列でなく`Enumerator::Lazy`を返すようになるため、メソッドを評価するタイミングを文字通り遅らせることができる

```ruby
>> a = [1, 2, 3, 4, 5].lazy.select { |e| e % 2 == 0 }
=> #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>
>> b = a.map { |e| e * 2}
=> #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>:map>
>> c = a.take(3)
=> #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>:take(3)>
>> c.to_a  # ここで評価される
=> [2, 4]
```



## `partition`メソッド

各要素を、ブロックの条件を満たす要素と満たさない要素に分割します。

各要素に対してブロックを評価して、その値が真であった要素の配列と、 偽であった要素の配列の2つを配列に入れて返します。

ブロックを省略した場合は、各要素に対しブロックを評価し、 上のようにその値が真であった要素の配列と、 偽であった要素の配列のペアを返すような Enumerator を 返します。

```ruby
>> a = (1..5).partition(&:odd?)
=> [[1, 3, 5], [2, 4]]
>> p a
[[1, 3, 5], [2, 4]]
=> [[1, 3, 5], [2, 4]]
```


## `Enumerator`クラス

> パーフェクトRuby(5-5-4引用)
>
> 2018/11/02

* 繰り返し処理を行う様々なメソッドに対して、`Enumerable`の機能を提供する

  →Stringクラス(Enumerable無)に対して、`each_char`、`each_line`などの繰り返しのメソッドを適用

* 外部イテレータ(繰り返しのタイミングを制御できる方式)と呼ばれる柔軟な処理を提供する



### Enumeratorオブジェクト

* 繰り返し処理を行うメソッドを、ブロック無しで呼び出した場合

  →Enumeratorオブジェクトが返される

```ruby
>> [].each                     # Array#each
=> #<Enumerator: []:each>
>> {}.each                     # Hash#each
=> #<Enumerator: {}:each>
>> (1..10).each                # Range#each
=> #<Enumerator: 1..10:each>
>> ''.each                     # Stringにはeachメソッドは無い(Enumerableがincludeされていない)
NoMethodError: undefined method 'each' for "":String
>> ''.each_char                # String#each_char
=> #<Enumerator: "":each_char>
>> 10.times                    # Integer#times
=> #<Enumerator: 10:times>
>> loop                        # Kernel.#loop
=> #<Enumerator: main:loop>
```

* Enumeratorオブジェクトは、

  1. `Object#to_emun`

  1. `Object#enum_for`

  1. `Enumerator.new`

  で生成される

* 引数には、`each`の代わりに使うメソッド名を渡すことができる

```ruby
# to_enum・enum_forメソッド
>> [1, 2, 3].to_enum
=> #<Enumerator: [1, 2, 3]:each>
>> [1, 2, 3].enum_for
=> #<Enumerator: [1, 2, 3]:each>

# Enumerator.newメソッド
>> str = "xyz"
=> "xyz"
>> enum = Enumerator.new(str, :each_byte)
(irb):18: warning: Enumerator.new without a block is deprecated; use Object#to_enum
=> #<Enumerator: "xyz":each_byte>

# enum_forを用いた例
>> 'Alice'.enum_for(:each_char)
=> #<Enumerator: "Alice":each_char>
```

> 実際の例
>
> String#each_lineを元にEnumeratorオブジェクトを生成し、Enumerable#mapにより行列の配列を生成

```ruby
>> lines = <<EOM
Alice
Bob
Charlie
EOM
=> "Alice\nBob\nCharlie\n"
>>
>> enum = lines.each_line
=> #<Enumerator: "Alice\nBob\nCharlie\n":each_line>
>> enum.map {|line| line.length}
=> [6, 4, 8]
```



### `Enumerator#with_index`

* 生成時のパラメータに従って、要素にインデックスを添えて繰り返す

* 繰り返しのたびに、インクリメントされる値と一緒に繰り返し処理を行うことができる

* インデックスは offset から始まる

* ブロックを指定した場合の戻り値は生成時に指定したレシーバ自身

> 例
>
> 1つ目：単に繰り返しを行う例
>
> 2つ目：インデックスと一緒に繰り返したい場合の例
>
> Enumerable#selectの条件に、配列の添字を使うことができる

```ruby
# 1つ目(Enumerable#each_with_index)
>> %w(Alice Bob Charlie).each_with_index do |name, index|
>>   puts "#{index}: #{name}"
>> end
0: Alice
1: Bob
2: Charlie
=> ["Alice", "Bob", "Charlie"]

# 1つ目(Enumerator#with_index)
>> %w(Alice Bob Charlie).each.with_index do |name, index|
>>   puts "#{index}: #{name}"
>> end
0: Alice
1: Bob
2: Charlie
=> ["Alice", "Bob", "Charlie"]

# 2つ目
>> %w(Alice Bob Charlie).select.with_index do |name, index|
>>   index > 0
>> end
=> ["Bob", "Charlie"]
```



### 外部イテレータ

※内部イテレータ：繰り返し処理は、これらのメソッドに渡したブロックの中で行われる

→繰り返しを簡潔に記述でき、本質的な処理に集中できる

→一方で、2つの配列を同時に繰り返したい場合には、Array#eachではうまくいかなくなる(繰り返しの処理は、each内部で行われている)

●外部イテレータ：繰り返しの処理のタイミンングを制御できる

* Enumeratorオブジェクトには、

  * `next`：次の要素を返し、内部で指している要素の位置を1つ先に進める

  * `rewind`：初めから繰り返しを行う

```ruby
>> enum = [4, 4, 2, 3].to_enum
=> #<Enumerator: [4, 4, 2, 3]:each>
>>
>> enum.next
=> 4
>> enum.next
=> 4
>> enum.next
=> 2
>>
>> enum.rewind            # 始めから繰り返しをやり直す
=> #<Enumerator: [4, 4, 2, 3]:each>
>>
>> enum.next
=> 4
>> enum.next
=> 4
>> enum.next
=> 2
>> enum.next
=> 3
>> enum.next
StopIteration: iteration reached an end
```

* Enumerator#nextは、次の要素が無い場合は例外`StopIteration`を発生させる

* 自分で`rescue`することもできるが、Kernel#loopを使って制御することもできる

  →ブロック内で発生した例外`StopIteration`を補足して、ループを終了させる

```ruby
>> enum = [4, 4, 2, 3].to_enum
=> #<Enumerator: [4, 4, 2, 3]:each>
>>
>> loop do
>>   puts enum.next
>> end
4
4
2
3
=> [4, 4, 2, 3]
```

* 繰り返しを途中で止めて、他の処理を挟むことができたり、複数の繰り返し処理を同時に行うことができる

> 例
>
> Enumeratorオブジェクトを使って、人物の名前の配列と年齢の配列を同時に繰り返して出力

```ruby
>> people = %w(Alice Bob Charlie).to_enum
=> #<Enumerator: ["Alice", "Bob", "Charlie"]:each>
>> ages   = [14, 32, 28].to_enum
=> #<Enumerator: [14, 32, 28]:each>

>> loop do
>>   person = people.next
>>   age    = ages.next
>>
>>   puts "#{person} (#{age})"
>> end
Alice (14)
Bob (32)
Charlie (28)
=> ["Alice", "Bob", "Charlie"]
```

* `feed`：map、selectのようなブロックの戻り値を使用するタイプのメソッドを呼び出す。

  →戻り値に当たる値を渡す

  →メソッド自体の戻り値は、StopIteration#resultで得ることができる

  * Enumerator 内部の yield が返す値を設定

  * これで値を設定しなかった場合は yield は nil

  * この値は内部で yield された時点でクリア

> 例
>
> Enumeratorを用いて、正規表現にマッチする要素を配列から取得

```ruby
>> enum = %w(Alice Bob Charlie).select
=> #<Enumerator: ["Alice", "Bob", "Charlie"]:select>

# /li/にマッチする要素だけを得る
>> loop do
>>   begin
>>     person = enum.next
>>
>>     enum.feed /li/ === person     # ブロックの戻り値に当たる値
>>   rescue StopIteration => e
>>     p e.result                    # selectの戻り値を表示させる
>>     break
>>   end
>> end
["Alice", "Charlie"]                 # selectの戻り値
=> nil
```



## `Enumerator::Lazy`

* 繰り返し処理の実行を遅延させることができる

  →大きな配列や無限の要素を持つオブジェクトの集まりを手軽に扱える

```ruby
# 無限にある数値をEnumerable#mapが全て繰り返す
# 結果は帰ってこない
#
>> (0..Float::INFINITY).map {|n| n.succ}.select {|n| n.odd?}.take(3) # 返ってこない
=> IRB::Abort: abort then interrupt!                                 # 強制終了
```

```ruby
# 全ての要素を処理することが不可能であったり、時間や空間を要する場合には、Enumerator::Lazyを用いる
#
>> odd_numbers = (0..Float::INFINITY).lazy.map {|n| n.succ}.select {|n| n.odd?}.take(3)
=> #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 0..Infinity>:map>:select>:take(3)>
>> odd_numbers.force
=> [1, 3, 5]
```

* `Enumerator::Lazy`に対してメソッドを呼び出すと、戻り値として新しい`Enumerator::Lazy`オブジェクトが得られる

  →この時点では、実際の処理は行われない

* 値を取り出すには、

  * `Enumerator::Lazy#force`：必要な回数だけ処理が実行され、値が得られる

  * `Enumerator::Lazy#first`：最初の要素を返す。また、回数の指定があった場合は、先頭からn番目までの値が得られる

を呼び出す必要があります。

* `Enumerable#lazy`では、交互で値を出力することができない。また、余分な中間データが生成する

  →`Enumerator::Lazy`では、それらの問題を解決する

> 例
>
> 繰り返しの順番を確かめる

```ruby
# Enumerator::Lazy
>> (0..Float::INFINITY).lazy.map {|n|
>>   puts "map: #{n}"
>>   n.succ
>> }.select {|n|
>>   puts "select: #{n}"
>>   n.odd?
>> }.take(3).force
map: 0
select: 1
map: 1
select: 2
map: 2
select: 3
map: 3
select: 4
map: 4
select: 5
=> [1, 3, 5]
```



## ジェネレータ

* ジェネレータ：部分的な結果だけを計算して返し、次回また続きから計算できるサブルーチンのこと

  →実際の計算を最小限で済ませ、大きなデータを少ないリソースで扱うことができる

### Enumerator::Yielder

* Enumerator.new にブロックを渡すと、ブロック引数として Enumerator::Yielder のインスタンスが渡される。

* 生成された Enumerator オブジェクトに対して`each`を呼ぶと、この生成時に指定されたブロックを実行

* Yielderオブジェクトに対して`<<`メソッドが呼ばれるたびに、 `each`に渡されたブロックが繰り返される(値が返される)

* `new`に渡されたブロックが終了した時点で`each`の繰り返しが終わります。 このときのブロックの返り値が`each`の返り値となります。

```ruby
>> enum = Enumerator.new do |yielder|
>>   yielder.yield 1
>>   yielder.yield 2
>>   yielder.yield 3
>> end
=> #<Enumerator: #<Enumerator::Generator:0x007fc1bf036848>:each>
>> enum.next()
=> 1
>> enum.next()
=> 2
>> enum.next()
=> 3
>> enum.next()
StopIteration: iteration reached an end
```


|  版  | 年/月/日 |
|-----|----------|
| 初版 |2018/10/13|
|第二版|2018/11/02|
