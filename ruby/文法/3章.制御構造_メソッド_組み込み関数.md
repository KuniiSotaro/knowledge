3章 制御構造 メソッド 組み込み関数
=============================

## 3-2.基本的な制御構造

## 3-2-5.プログラムの終端を明示する

* `__END__`：ファイルの途中でプログラムの終端を明示する

  これ以降はRubyプログラムとして実行されることはない

* `__END__`の次の行以降のデータは、`DATA`という定数にFileオブジェクトとして保持されており、実行時に参照可能

* `__END__`キーワードがなければ、定数`DATA`は定義されない

```ruby
DATA.each_line do |line|
  puts line
end

__END__
いろはにほへと
ちりぬるを

# 実行結果
いろはにほへと
ちりぬるを
```



## 3-3.例外処理

## 3-3-1.例外の発生とクラス

![Excerptionを継承した例外クラス](./images/Excerptionを継承した例外クラス.png)



## 3-3-2.例外を制御する

### `Kernel.#raise`

* 例外を発生させる

* 第1引数に文字列を指定した場合は、それを例外のメッセージとして例外RuntimeErrorを発生させる

```ruby
>> raise 'error!'
RuntimeError: error!
```

* 第1引数には、例外クラスも指定できる。その場合は、例外メッセージは第2引数に指定する

```ruby
>> raise StandardError, 'error!'
StandardError: error!
```

* 例外を捕捉するには、例外の発生する可能性のある式を`begin`の中に記述する

* 発生した例外はrescue節で捕捉できる

* rescue節で`=> e`と変数を指定することで、捕捉した例外オブジェクトが変数`e`に代入される

```ruby
>> begin
>>   do_process    # 例外が発生する可能性のある何らかの処理
>> rescue => e
>>   puts "Error occurred #{e.class}"
>> end
Error occurred NameError
=> nil
```

* 例外オブジェクトには、

  * `Excerption#message`：例外についての人間が読める形式の詳細なメッセージを文字列で返す

    -> `raise`に渡された例外メッセージは、このメソッドで取り出せる

  * `Excerption#backtrace`：例外が発生した時点のコールスタック(プログラムで実行中のサブルーチンに関する情報を格納するスタック)を配列で返す

```ruby
>> e.class
=> NameError
>> e.message
=> "undefined local variable or method `do_process' for main:Object"
>> e.backtrace
=> ["(irb):2:in `irb_binding'",
```

* 配列の要素には、以下の形式の文字列が格納されている

```ruby
ファイル名:行番号:in 'メソッド名'
```



## 3-5.メソッドの定義と呼び出し

## 3-5-9.ブロック

* メソッドは、ブロックを受け取ることができる

* 受け取ったブロックは、任意のタイミングで任意の回数実行できる

* 配列の`each`メソッドは、ブロックを受け取り、要素の数だけブロックを実行する



### yield

* メソッドの中で`yield`を呼び出すと、受け取ったブロックを実行する

```ruby
>> def block_sample
>>   puts 'stand up'
>>   yield
>>   puts 'sit down'
>> end
=> :block_sample

>> block_sample do
>>   puts 'walk'
>> end
stand up
walk
sit down
=> nil
```

* `yield`を呼び出すメソッドをブロック無しで呼び出すと、LocalJumpErrorという例外が発生する

  => `yield`を呼び出すのは、ブロックが与えられているときのみ

```ruby
>> block_sample
stand up
LocalJumpError: no block given (yield)
```

* メソッドに対してブロックが与えられたかどうかを知るには、`block_given?`を使用する

  => 実行中のメソッドがブロック付きで呼び出されている時に真を返す

```ruby
def block_sample
  puts 'stand up'
  yield if block_given?
  puts 'sit down'
end
```

```ruby
# ブロックを渡さない
>> block_sample
stand up
sit down
=> nil

# ブロックを渡す
>> block_sample do
>>   puts 'walk'
>> end
stand up
walk
sit down
=> nil
```

* ブロックの有無で挙動を変えることの例として、`File.open`が挙げられる

* Fileクラスの`open`メソッドは、ブロックの有無によって2つのインターフェースを提供している

```ruby
# ブロックを使わずにファイルの書き込み処理を行う
file = File.open("README.md", 'w')
file.puts 'README'
file.close

# ブロックを使った場合(ファイルは自動的にクローズされる)
File.open "README.md", 'w' do |file|
  file.puts "README"
end
```

* `File.open`は、ブロック無しで呼び出されると戻り値としてFileオブジェクトを返す

  => この場合、プログラマは自らファイルを閉じる必要がある

* ブロック付きで呼び出された時には、Fileオブジェクトがブロックの引数として与えられる

  => ファイルはブロックの終了と共に自動的に閉じられる



### ブロックの戻り値/引数
