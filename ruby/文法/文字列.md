## 3-4.文字列

文字列の特徴

* リテラル書式のバリエーションが豊富
* `ヒアドキュメント`と、`パーセント記法`が利用可能
* 各書式には、`式展開`が適用できるものとできないものがある


### 3-4-1.文字列リテラルと式展開

基本的には、 **ダブルクオート`""`** と **シングルクオート`''`** で囲む
↓
文字列の値として認識され、Stringクラスのインスタンスが生成

```ruby
>> a = "abcd"       # 文字列
=> "abcd"
>> p a
"abcd"
=> "abcd"
>> p a.class        # 変数aのクラス・・・Stringクラス
String
=> String
>> b = "ab" 'cd'    # 文字列リテラルを連続して記述することで、それらを連結した文字列を生成
=> "abcd"
>> p b
"abcd"
=> "abcd"
```

***

#### 式展開

式展開とは、

* ダブルクオートで囲まれた`#{}`で囲まれた部分が式として評価され、その結果を文字列中に展開されること
* シングルクオートで囲まれたものは、式展開が行われずに文字列として評価される

```ruby
>> a = 1
=> 1
>> p "a is #{a}"
"a is 1"
=> "a is 1"
>> p 'a is #{a}'
"a is \#{a}"
=> "a is \#{a}"
```

〜解説〜

* `#{}`内部では、任意の式を指定。評価結果となった値の`to_s`メソッドが呼び出される
* `to_s`メソッドは、オブジェクトの文字列表現を返す
* この場合、`#{a}`は`"1"`という文字列に変換され、指定箇所に挿入される

***

#### 文字列から数値に変換

* 数値から文字列：`to_s`メソッド
* 文字列から整数：`to_i`メソッド
* 文字列から浮動小数点数：`to_f`メソッド
* 文字列から有理数：`to_r`メソッド
* 文字列から複素数：`to_c`メソッド

```ruby
>> "100".to_i       # 文字列"100"が数値100に変換
=> 100
>> "1.9".to_f       # 文字列"1.9"が浮動小数点数1.9に変換
=> 1.9
>> "5/2".to_r       # 文字列"5/2"が有理数5/2に変換
=> (5/2)
>> "1+2i".to_c      # 文字"1+2i"が複素数(1+2i)に変換
=> (1+2i)
>> "12ab3".to_i     # 文字列"12ab3"のうち、abの前の12が数値12へ変換
=> 12
>> "12ab3".to_f     # 文字列"12ab3"のうち、abの前の12が浮動小数点数12.0へ変換
=> 12.0
>> "1.9".to_i       # 文字列"1.9"のうち、.の前の1が数値1へ変換
=> 1
>> "1.9.9".to_f     # 文字列"1.9.9"のうち、.9の前の1.9が浮動小数点数1.9へ変換
=> 1.9
```

※ 最初の文字が無効である場合は、`0`が返される

***

### 3-4-2.バックスラッシュ記法

バックスラッシュ記法とは・・・
`\`に続けて文字を指定する方法

* `\x`：xの文字そのもの
* `\n`：改行
* `\r`：キャリッジリターン・・・カーソルを文頭へ戻す
* `\f`：改ページ
* `\a`：ベル
* `\e`：エスケープ
* `\s`：空白
* `\b`：バックスペース
* `\t`：タブ
* `\v`：垂直タブ
* `\nnn`：8進数表記(nは0-7)
* `\xnn`：16進数表記(nは0-9、a-f)
* `\cx`、または`\C-x`：コントロール文字(xはASCII文字)
* `\M-x`：メタx
* `\M-\C-x`：メタ コントロールx
* `unnnn`：Unicode文字(nは0-9、a-f、A-F)
* `\u{nnnn}`：Unicode文字(nは0-9、a-f、A-F)。nnnnは16進数で1〜6桁まで指定可能。スペースorタブ区切りで複数のUnicode文字を指定可能

※ 時間があるときに、例を追加する
2018/08/13

***

#### 8進数表記と16進数表記

```ruby
>> p "\101"     # "A"の文字コートは8進数で101
"A"
=> "A"
>> p "\x41"     # "A"の文字コードは16進数で41
"A"
=> "A"
```

***

#### `p`と`print`と`puts`の違い

* `p`：出力する値と共に型情報（文字列や数値型など）を一緒に出力。引数ごとに改行。
* `print`：半角スペースを空けて出力する値を指定するだけで利用可能。改行しない。
* `puts`：末尾に改行が入る形で出力される。

```ruby
>> p "a\nb"       # バックスラッシュ記法が適用されずに出力
"a\nb"
=> "a\nb"
>> print "a\nb"   # バックスラッシュ記法を適用して出力(改行されない)
a
b=> nil
>> puts "a\nb"    # バックスラッシュ記法を適用して出力(改行される)
a
b
=> nil
```

|メソッド|     改行    |出力内容の構築メソッド|バックスラッシュ記法|
|-------|------------|-------------------|----------------|
|   p   |引数ごとに改行 |   inspectメソッド  |   そのまま出力   |
| print |  改行しない  |    to_sメソッド    | 適用した結果を出力 |
|  puts |引数ごとに改行 |    to_sメソッド    | 適用した結果を出力 |

***

#### `p`のバックスラッシュ記法

バックスラッシュ記法が解釈された結果の文字によって、  
バックスラッシュ記法で別途エスケープして出力

```ruby
>> p "\x61"
"a"
=> "a"
>> p "\x0a"
"\n"
=> "\n"
>> p '\x0a'     # シングルクオートで囲んだ場合は、シングルクオートとバックスラッシュのエスケープのみが適用
"\\x0a"
=> "\\x0a"
```

***

### 3-4-3.ヒアドキュメント

バックスラッシュ記法を簡単にしたもの

* より簡単に改行コードを含む文字列を指定
* `<<`に続けて文字列の終端を示す任意の識別子を指定

```ruby
>> query = <<SQL
  select *
  from my_table;
SQL
=> "  select *\n  from my_table;\n"
>> query
=> "  select *\n  from my_table;\n"
```

***

#### 階層が深い場合のヒアドキュメント
ヒアドキュメントでは、 **終端を示す識別子の前には、スペースなどの文字を記述してはいけない**
→開始の識別子の頭に、ハイフン`-`をつけることで回避

```ruby
# Silverで間違えてます！！！
>> def foo
>>     <<-RESULT
      Ru
      By
    RESULT
>> end
=> :foo
>> p foo
"      Ru\n      By\n"
=> "      Ru\n      By\n"
```

ハイフン`-`をつけると空白になるので、チルダ`~`をつけることで対処できる

```ruby
>> def foo
>>     <<~RESULT
      Ru
      By
    RESULT
>> end
=> :foo
>> p foo
"Ru\nBy\n"
=> "Ru\nBy\n"
```

例)Silverで間違えた問題

```ruby
>> s = <<'EOF'
Hello,
Ruby
EOF
'EOF' # ただの文字列として認識される(ヒアドキュメントとして認識されない)
?> p s
"Hello,\nRuby\n"
=> "Hello,\nRuby\n"
```

開始ラベル：説明
* `"識別子"`：式展開が有効
* `識別子`：式展開が有効。ダブルクオートと同じ結果
* `'識別子'`：式展開できない(シングルクオート)
* ``識別子``：コマンド出力(バッククオート)

***

#### ヒアドキュメントのシングルクオート、ダブルクオート

* `"識別子"`：式展開が有効
* `識別子`：式展開が有効。ダブルクオートと同じ結果
* `'識別子'`：式展開できない(シングルクオート)
* ``識別子``：コマンド出力(バッククオート)

```ruby
# Silverで間違えています！！！
>> a = 1
=> 1

>> s = <<'TEST'     # シングルクオート
#{a}
TEST
=> "\#{a}\n"
>> p s
"\#{a}\n"
=> "\#{a}\n"

>> s =<<"TEST"      # ダブルクオート
#{a}
TEST
=> "1\n"
>> p s
"1\n"
=> "1\n"
```

***

### 3-4-4.パーセント記法
パーセント記法とは・・・
文字列を囲む記号を、プログラマ自身が指定可能


```ruby
>> a = %*test*       # %を使用することで、ダブルクオート文字列にする
=> "test"
>> p a
"test"
=> "test"
>> a = %*"test"*     # エスケープなしでダブルクオートを文字列中に使用
=> "\"test\""
>> p a
"\"test\""
=> "\"test\""
>> a = %[test]       # 文字列を囲む記号は対になれば、何でも良い
=> "test"
>> p a
"test"
=> "test"
>> a = 1
=> 1
>> %q!#{a + 1}!      # %qを指定することで、シングルクオートになる
=> "\#{a + 1}"
>> %Q?#{a + 1}?      # %Qを指定することで、ダブルクオート文字列になる
=> "2"
```

例)Silverで危うく間違えそうだった問題

```ruby
>> %|apple bananba orange|
=> "apple bananba orange"
```

***

#### パーセント記法の例

* `%`：ダブルクオート文字列
* `%Q`：ダブルクオート文字列(`%`のみと同等)
* `%q`：シングルクオート文字列・・・文字型としてよく使用
* `%s`：シンボル
* `%W`：要素がダブルクオート文字列となる配列(要素の区切り・空白文字)
* `%w`：要素がシングルクオート文字列となる配列(要素の区切り・空白文字)→enumでよく使用
* `%x`：コマンド出力
* `%r`：正規表現

***

### 3-4-5.文字列演算
文字列・・・`加算(+メソッド)`と`乗算(*メソッド)`の2つが適用可能

```ruby
>> a = "ru" + "by"    # 加算は、文字連結された値を返す
=> "ruby"
>> a * 3              # 乗算は、右辺の数値の回数だけ文字連結された値を返す
=> "rubyrubyruby"
>> 3 * a              # 左辺に数値は指定できない
TypeError: String can｀t be coerced into Integer
```

***

#### `<<`メソッドによる連結

```ruby
>> a = "ru"
=> "ru"
>> p a << "by"     # 破壊的メソッド
"ruby"
=> "ruby"
>> p a
"ruby"
=> "ruby"
```

***

#### 異なる文字コード間での文字列操作

`String`クラスのインスタンス内に、文字コードの情報を持つ。
→異なる文字コード間で文字列操作を行おうとすると例外発生

※デフォルトは`UTF-8`

```ruby
>> a = "ルビー"
=> "ルビー"
>> a.encoding
=> #<Encoding:UTF-8>
>> b = a.encode("SJIS")        # "ルビー"をWindows-31Jに変換
=> "\x{838B}\x{8372}\x{815B}"
>> b.encoding
=> #<Encoding:Windows-31J>
>> a + b
Encoding::CompatibilityError: incompatible character encodings: UTF-8 and Windows-31J
```

***

#### 文字列の比較

文字列の場合は、文字コードの大小で不等号の結果が成立
↓
文字コードの大小は、`辞書順`

```ruby
>> "a" < "b"
=> true
>> "ab" < "ac"
=> true
>> "Ab" < "Ab"
=> false
>> "Ab" == "Ab"
=> true
>> "Ab" <=> "Ab"
=> 0
```

***

#### 文字列の参照

```ruby
>> "abcde".length    # 文字列の長さ
=> 5
>> "日本語".length    # 文字列の長さ
=> 3
```

***

### 3-4-6.`sprintf`によるフォーマット指定

* 第一引数：フォーマット
* 第二引数以降：フォーマットしたい値

```ruby
# 進数の指定
>> sprintf("result: %#b", 16)          # b：2進数
=> "result: 0b10000"
>> sprintf("result: %#o", 16)          # o：8進数
=> "result: 020"
>> sprintf("result: %#x", 16)          # x：16進数
=> "result: 0x10"
>> sprintf("result: %#X", 16)          # X：16進数
=> "result: 0X10"
>> sprintf("result: %02d", 1)          # 2桁指定
=> "result: 01"
>> sprintf("result: %03d", 1)          # 3桁指定
=> "result: 001"
>> sprintf("result: %05.2f", 1.1111)   # 符号と小数点を含んで5桁、小数点以下が2桁
=> "result: 01.11"
```

***

#### `sprintf`関数の文字列`%`演算

`String`クラスの`%`演算と同じ結果を得られる

```ruby
>> "result: %02d" % 1 # 1を2進数、2桁で出力
=> "result: 01"
>> "result: %03d" % 1
=> "result: 001"
>> "result: %05.2f" % 1.1111
=> "result: 01.11"
```

例)Silverで間違えた問題

* `"%d"`：10進数表現で数値を出力します。

```ruby
>> p "Hello%d" % 5
"Hello5"
=> "Hello5"
```

文字列`"Hello"`にフォーマットに必要な指示子が無いためそのまま出力されます。
→フォーマットが未指定だと、そのまま出力される

```ruby
# 問題
p "Hello" % 5

# 解答
?> p "Hello" % 5
"Hello"
=> "Hello"
```
