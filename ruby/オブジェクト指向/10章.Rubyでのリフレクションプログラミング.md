10章 Rubyでのリフレクションプログラミング
===================================

* `リフレクション`：プログラム実行中に、そのプログラムの情報を取得したり、操作したりすること



## 10-1.オブジェクトについて調べる

* Rubyでは、オブジェクトから以下のような情報を取得することができる

  * オブジェクトが持つインスタンス変数

  * オブジェクトが持つメソッド

  * オブジェクト自身



### 10-1-1.オブジェクトが持つインスタンス変数にアクセスする

* オブジェクトが持つインスタンス変数に対して、以下の操作をするためのAPIが用意されている

  * インスタンス変数名の確認

  * インスタンス変数の参照

  * インスタンス変数の設定

* 上のAPIを用いることで、

  * インスタンス変数に対して「ゲッターメソッド」や「セッターメソッド」が用意されていないインスタンス変数へのアクセス

  * 新しいインスタンス変数を定義

  することができる


### インスタンス変数名の確認

* `インスタンス変数`：オブジェクトに状態を持たせるために使われる

* インスタンス変数の名前がわかることで、オブジェクトがどのような情報を持つのか推測できる

```ruby
>> class Hoge
>>   def initialize
>>     @foo = 1
>>     @bar = 2
>>   end
>> end
=> :initialize

>> obj = Hoge.new
=> #<Hoge:0x007fe5168b1048 @foo=1, @bar=2>
```

* `Object#instance_variables`：呼び出し時点で、オブジェクトに定義されているインスタンス変数を全て取得する

  ```ruby
  >> obj.instance_variables
  => [:@foo, :@bar]
  ```

  * 結果が配列で返ってくるので、`select`メソッドや`any?`メソッドを使い、結果から調査したいインスタンス変数名があるかどうかを絞り込むことができる

  ```ruby
  >>   obj.instance_variables.any? do |val|
  >>     val =~ /fo/
  >>   end
  => true

  >>   obj.instance_variables.select do |val|
  >>     val =~ /fo/
  >>   end
  => [:@foo]
  ```

  * `Object#instance_variable_defined?`：オブジェクトに対して、インスタンス変数名が定義されているかを直接問い合わせる

    * 問い合わせたいインスタンス変数名は、`@`をつけて引数に渡す必要がある

      -> `@`が付いていないなどの、インスタンス変数名として不適切な場合は、NameErrorが発生する

  ```ruby
  >>   obj.instance_variable_defined? :@foo
  => true
  >>   obj.instance_variable_defined? :@buzz
  => false
  >>   obj.instance_variable_defined? :foo
  NameError: 'foo' is not allowed as an instance variable name
  ```



### インスタンス変数の値を参照

* オブジェクトが持つインスタンス変数の値を参照するには、そのインスタンス変数に対応する「ゲッターメソッド」が定義されている必要がある

* 一方、リフレクションを使用すれば、そのようなメソッドが定義されていないインスタンス変数の値を参照できる

* `Object#instance_variable_get`：「ゲッターメソッド」が定義されていないインスタンス変数の値も参照できる

  * `引数`：値を取得したいインスタンス変数をシンボル、または文字列で渡す

    -> そのインスタンス変数の値が返る

  * 引数に渡したインスタンスメソッド名が、オブジェクトに定義されたいない場合は`nil`が返ってくる

  ```ruby
  >>   obj.instance_variable_get :@foo
  => 1
  >>   obj.instance_variable_get :@buzz
  => nil
  >>   obj.instance_variable_get :foo
  NameError: 'foo' is not allowed as an instance variable name
  ```



### インスタンス変数の値を更新

* インスタンス変数に対して、値をセットすることができる

* `Object#instance_variable_set`：インスタンス変数に値をセットする

  * `引数`：値を設定したいインスタンス変数名のシンボルと設定したい値を渡す

  ```ruby
  >>   obj.instance_variable_get :@foo
  => 1
  >>   obj.instance_variable_set :@foo, 2
  => 2
  >>   obj.instance_variable_get :@foo
  => 2
  ```

* `Object#instance_variable_set`を使用すれば、存在していないインスタンス変数も設定することができる

  ```ruby
  >>   obj.instance_variable_defined? :@buzz
  => false
  >>   obj.instance_variable_set :@buzz, 3
  => 3
  >>   obj.instance_variable_defined? :@buzz
  => true
  >>   obj.instance_variables
  => [:@foo, :@bar, :@buzz]
  ```



## 10-2.オブジェクトが持つメソッドを調べる

* Objectクラスには、オブジェクトが持つメソッド名を調べたり、実行するためのAPIが用意されている

* このAPIを用いることで、メソッドの可視性に関わらずメソッドを実行したりすることが可能

* また、オブジェクトがどんな振る舞いができるかを確認することができる



### オブジェクトの持つメソッドを一覧で確認する

* 初めて使うライブラリやドキュメントの少ないライブラリなどを使用する際に、オブジェクトがどのようなメソッドを持っているかを確認したいとき、

  -> Objectクラスの持つメソッド名を取得するメソッドを使い、名前から動作を推測したりする

* Objectクラスには、メソッドの可視性などによりメソッド名を取得するメソッドが複数定義されている

  -> それぞれ、メソッド名をシンボルで表現した配列が返る

|         メソッド名         |              取得できるメソッド              |
|:-------------------------|:------------------------------------------|
|`Object#methods`          |オブジェクトの持つプライベートメソッド以外のメソッド|
|`Object#public_methods`   |オブジェクトの持つパブリックメソッド             |
|`Object#private_methods`  |オブジェクトの持つプライベートメソッド            |
|`Object#protected_methods`|オブジェクトの持つプロテクテッドメソッド          |
|`Object#singleton_methods`|オブジェクトの持つ特異メソッド                   |

```ruby
# 準備
class Parent
  def super_public_method; end

  private
  def super_private_method; end
end

class Child < Parent
  def public_method; end

  private
  def private_method; end

  protected
  def protected_method; end
end

child = Child.new
def child.singleton_method; end

# 各メソッドの確認
>> child.methods
=> [:singleton_method, :public_method, :protected_method, :super_public_method, ] # 省略
>> child.public_methods
=> [:singleton_method, :public_method, :super_public_method, ] # 省略
>> child.private_methods
=> [:private_method, :super_private_method, ] # 省略
>> child.protected_methods
=> [:protected_method]
>> child.singleton_methods
=> [:singleton_method]
```

* `Object#methods`を使うと、オブジェクトに定義されているメソッド名が配列で返る

  * 引数を指定しない場合やtrueを指定した場合に、オブジェクトのプライベートメソッド以外のメソッドを返す

    -> 特異メソッドも含む

  * 引数にfalseを指定した場合、そのオブジェクトの特異メソッドのみを返す

  ```ruby
  >> child.methods(false)
  => [:singleton_method]
  ```

* `Object#singleton_method`：引数を指定しない場合や、trueを指定した場合にオブジェクトに定義されている全ての特異メソッドを返す

  * `Object#extend`によってMix-inされたメソッド、ClassクラスやModuleクラスのオブジェクトのときは、親クラスのクラスメソッドも含む

  * falseを指定した場合は、そのオブジェクトで定義された特異メソッドのみとなる

    -> `Object#methods`にfalseを渡した時と同じ挙動

  ```ruby
  >>   module Huga
  >>     def singleton_method_huga; end
  >>   end
  => :singleton_method_huga

  >>   child.extend Huga
  => #<Child:0x007fb1358daa98>

  >>   child.singleton_methods
  => [:singleton_method, :singleton_method_huga]

  >>   child.singleton_methods(false)
  => [:singleton_method]
  >>   child.methods(false)
  => [:singleton_method]
  ```

* `Object#public_methods`・`Object#private_methods`・`Object#protected_methods`

  * メソッドの可視性に応じて、メソッド名を返す

  * オブジェクトが応えられるメソッド名を、メソッド名の接頭辞で表現されている可視性に応じて返す

  * 引数を指定しない場合、trueを指定した場合は、オブジェクトの持つ全てのメソッドを返す

  * falseを指定したいした場合、親クラスから継承したメソッドを含めなくなる

```ruby
>> child.public_methods(false)
=> [:singleton_method, :singleton_method_huga, :public_method]
>> child.private_methods(false)
=> [:private_method]
>> child.protected_methods(false)
=> [:protected_method]
```



### オブジェクトにメソッドが定義されているかを確認する

* `Object#respond_to?`：オブジェクトに指定したメソッドが定義されているかどうかを、実際にメソッドを呼び出さずに確認する

  * 確認したいメソッド名を、文字列かシンボルで引数に渡す

```ruby
>> class Hoge
>>   def has_method
>>     'has_method'
>>   end
>> end
=> :has_method

>> class Huga
>> end
=> nil

>> hoge = Hoge.new
=> #<Hoge:0x007ff9319d8028>
>> huga = Huga.new
=> #<Huga:0x007ff9319d0e40>

>> hoge.respond_to? :has_method
=> true
>> huga.respond_to? :has_method
=> false
```

* `Object#respond_to?`は、デフォルトではpublicなメソッドが存在していた場合にtrueを返す

* 一方、第二引数にtrueを指定すると、privateメソッドに指定したメソッド名が定義されている時にもtrueを返す

```ruby
>> class Hoge
>>   private
>>   def private_method
>>     'private_method'
>>   end
>> end
=> :private_method

>> hoge = Hoge.new
=> #<Hoge:0x007f9fe48b5480>

>> hoge.respond_to? :private_method
=> false
>> hoge.respond_to? :private_method, true
=> true
>> hoge.respond_to? :private_method, false # 引数を渡していない時と同じ挙動
=> false
```

* `Object#respond_to?`は、`Object#method_missing`で処理をされるメソッドについては、trueを返さない

* しかし、`Object#method_missing?`というメソッドが、そのメソッド名を引数で受けた時にtrueを返すように

  オーバーライドされている場合は、trueを返すようになる

```ruby
>> class Hoge
>>   def method_missing(method_name, *args)
>>     if method_name == :except_method
>>       'except_method'
>>     else
?>       super
>>     end
>>   end
>> end
=> :method_missing
>>
?> hoge = Hoge.new
=> #<Hoge:0x007fbbe9029c28>
>> hoge.except_method
=> "except_method"
>> hoge.respond_to? :except_method
=> false
>>
?> class Hoge
>>   def method_missing(method_name, include_private = false)
>>     if method_name.to_sym == :except_method
>>       'except_method'
>>     else
?>       super
>>     end
>>   end
>> end
=> :method_missing
>>
?> hoge.respond_to? :except_method
=> false # trueらしい
```

※`include_private`について、調べておく



### メソッドの呼び出し

* `Object#send`：任意のメソッドを実行できる

  * 引数で指定されたメソッド名に合致するメソッドを、レシーバのオブジェクトで呼び出す

  * 第一引数：メソッド名を、シンボルまたは文字列で受ける

  * 第二引数：指定されたメソッドの引数にする

  -> メソッドを呼びだす

```ruby
>> class Hello
>>   def hi
>>     'hi'
>>   end
>>
>>   def hello(name)
>>     "hello #{name}"
>>   end
>> end
=> :hello

>> hello = Hello.new
=> #<Hello:0x007fbbe7921c38>
>> hello.send :hi
=> "hi"
>> hello.send :hello, "takkanm"
=> "hello takkanm"
```

* `Object#send`は、メソッドの可視性に関わらずメソッドを呼び出すことができる

```ruby
>> class Hello
>>   protected
>>   def protected_hello
>>     'protected hello'
>>   end
>>
>>   private
>>   def private_hello
>>     'private hello'
>>   end
>> end
=> :private_hello

>> hello = Hello.new
=> #<Hello:0x007fdb9c8929f0>

>> hello.protected_hello
NoMethodError: protected method 'protected_hello' called for #<Hello:0x007fdb9c8929f0>
>> hello.send :protected_hello
=> "protected hello"

>> hello.private_hello
NoMethodError: private method 'private_hello' called for #<Hello:0x007fdb9c8929f0>
>> hello.send :private_hello
=> "private hello"
```

* `Object#__send__`：`Object#send`と同じインターフェース

```ruby
>> class MailSender
>>   attr_reader :from
>>
>>   def initialize(from)
>>     @from = from
>>   end
>>
>>   def send(to)
>>     "send mail: #{to}"
>>   end
>> end
=> :send

>> mail_sender = MailSender.new('takkanm')
=> #<MailSender:0x007fc1980d2918 @from="takkanm">
>> mail_sender.send 'takkanm@example.com'
=> "send mail: takkanm@example.com"
>> mail_sender.__send__ :from
=> "takkanm"
```



## 10-2.クラスについて調べる

* クラスもオブジェクトと同様に、定義されたクラス変数やメソッドに対してアクセスするためのメソッドが用意されている

* クラスの継承関係や、ネスト構造を取得するメソッドも用意されている



### 10-2-1.クラスが持つ値にアクセスする

* Rubyでは、クラスやモジュールに対して以下のような情報を取得する方法が用意されている

  * クラスが持つクラス変数

  * クラスやモジュールが持つ定数

  * クラスの継承構造

  * クラスのネスト構造



### クラス内に定義されているクラス変数の名前を確認する

* クラス変数を一覧で確認する方法

* 名前を指定して確認する方法

が存在する

```ruby
# 準備
class Hoge
  @@val = :val

  def hoge_method
    @@hoge_method_val = :hoge_method_val
  end
end
```

* `Module#class_variables`：クラス変数を一覧で取得する

  * 呼び出し時点で定義されているクラス変数を全て取得

  * 結果の出力は、クラス名のシンボルの配列

  -> `Object#instance_variables`と同様

```ruby
>> Hoge.class_variables
=> [:@@val]

>> Hoge.new.hoge_method
=> :hoge_method_val

>> Hoge.class_variables
=> [:@@val, :@@hoge_method_val]
```

* `Module#class_variable_defined?`：クラスに対して、あるクラス変数名が定義されているかどうかを直接問い合わせる場合

  * 引数に、問い合わせたいクラス変数名を`@@`付きで渡す

  * `@@`から始まらない場合、適切でない文字列が与えられた場合はNameError

```ruby
>> Hoge.class_variable_defined? '@@hoge_method_val'
=> true
>> Hoge.class_variable_defined? '@@hoge_hoge'
=> false
```



### クラス変数の値を取得する

* `Module#class_variable_get`：クラス変数の値を取得する

  * インターフェースは、`Object#instance_variable_get`と同様

  * 一方、存在しないクラス変数に対しては、NameErrorとなる

  -> `Object#instance_variable_get`では、nilが返る

```ruby
>> Hoge.class_variable_get '@@val'
=> :val
>> Hoge.class_variable_get '@@val_val'
NameError: uninitialized class variable @@val_val in Hoge
```



### クラス変数に値を設定する

* `Module#class_variable_get`：クラス変数へ値を設定する

  * インターフェースは、`Object#instance_variable_get`と同様

  * 定義されていないクラス変数を定義することができる

```ruby
>> Hoge.class_variable_set '@@class_variable', :class_variable_set
=> :class_variable_set
>> Hoge.class_variable_get '@@class_variable'
=> :class_variable_set

>> Hoge.class_variable_get '@@undefined_class_variable'
NameError: uninitialized class variable @@undefined_class_variable in Hoge
>> Hoge.class_variable_set '@@undefined_class_variable', :defined
=> :defined
>> Hoge.class_variable_get '@@undefined_class_variable'
=> :defined
```



### クラス内に定義されている定数の名前を確認する

* `Module#constants`：クラス内に定義されている定数名を取得する

  * メソッドの戻り値は、定数名をシンボルにした配列

  * 継承したクラスやincludeしたモジュールで定義された定数を含める

  * 一方で、引数にfalseを渡すと含めなくなる

```ruby
>> module Huga
>>   HUGA_CONST = 1
>> end
=> 1

>> class Hoge
>>   include Huga
>>
>>   HOGE_CONST = 1
>>
>>   class InnerHoge
>>     INNER_HOGE_CONST = 1
>>   end
>> end
=> 1

>> Hoge.constants
=> [:HOGE_CONST, :InnerHoge, :HUGA_CONST]
>> Hoge.constants(false)
=> [:HOGE_CONST, :InnerHoge]
>> Hoge::InnerHoge.constants
=> [:INNER_HOGE_CONST]
```



### 定数の値を取得する

* `Module#const_get`：クラス内に定義されている定数の値を取得する

  * 定数名の文字列、またはシンボルを引数にとる

  * 存在しない定数名や、定数名にならない文字列を引数に渡すと、NameErrorが発生する

```ruby
>> class Hoge
>>   CONST_HOGE = 1
>> end
=> 1

>> Hoge.const_get :CONST_HOGE
=> 1
>> Hoge.const_get :CONST_HOGE_NO_EXIST
NameError: uninitialized constant Hoge::CONST_HOGE_NO_EXIST
>> Hoge.const_get :const_hoge_no_exist
NameError: wrong constant name const_hoge_no_exist
```



### クラスに新しい定数を定義する

* `Module#const_set`：クラスに新たに定数を定義する

  * `Object#instance_variable_set`と同様に、定義したい定数名の文字列またはシンボルと、設定したい値を引数にとる

  * 既に定義されている定数名を引数に渡した場合は、定数を再定義した時と同様にwarningが発生する

```ruby
>> class Hoge
>> end
=> nil

>> Hoge.constants
=> []
>> Hoge.const_set :CONST_VAR, 1
=> 1
>> Hoge.constants
=> [:CONST_VAR]
>> Hoge.const_get :CONST_VAR
=> 1

# 定数を再定義する
>> Hoge.const_set :CONST_VAR, 2
(irb):9: warning: already initialized constant Hoge::CONST_VAR
(irb):5: warning: previous definition of CONST_VAR was here
=> 2
>> Hoge.constants
=> [:CONST_VAR]
>> Hoge.const_get :CONST_VAR
=> 2
```



### 10-2-2.クラスが持つメソッドを調べる
