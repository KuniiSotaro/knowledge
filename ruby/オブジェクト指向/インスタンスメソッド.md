# 4-2.インスタンスメソッド

## 4-2-1.クラスオブジェクト

## 4-2-2.継承したクラスオブジェクト

## 4-2-3.メソッドの探索経路

## 4-2-4.継承チェーンと`method_missing`

## 4-2-5.オープンクラス

同名のクラスを複数回定義してもエラーにはならない

class式は **クラスオブジェクトが存在しない場合に生成** する。

既にクラスオブジェクトが存在する場合には、そのオブジェクトをもう一度「開いて」評価する

```ruby
>> class Hoge
>>   def fuga1; end
>> end
=> :fuga1
>>
?> class Hoge
>>   def fuga2; end
>> end
=> :fuga2
>>
?> Hoge.instance_methods(false)
=> [:fuga1, :fuga2]
```

* 最初の`class Hoge`の段階では、まだクラスは存在していない。Rubyがこのクラス(と`fuga1`メソッド)の定義の中に入った時に始めてクラスを定義

* 2回目の`class Hoge`の段階では、既にそのクラスは存在しているので改めてクラスを定義する必要がない

* いつでもクラスを再オープンして、その場で修正できる
  → **オープンクラス**

* 一度定義したクラスを再定義のために開くこと
  → **クラスの再オープン**

### オープンクラスの問題点

組み込みクラスを再オープンするとき、同名のメソッドを上書きするとプログラム全体がバグを起こす

→ **モンキーパッチ**

```ruby
>> class String
>>   def huga; 1; end
>>   def reverse; 2; end
>> end
=> :reverse
>>
?> p "my string".huga
1
=> 1
>> p "my string".reverse   # 上書きされたメソッドで実行されている
2
=> 2
```

スーパークラスを指定して再オープンする場合、スーパークラスはオープンする前のクラスと同じでなければならない

```ruby
>> class Foo; end
=> nil
>> class Bar; end
=> nil
>> class Baz < Foo
>> end
=> nil

>> class Baz < Bar
>> end
TypeError: superclass mismatch for class Baz

>> class Baz < Foo   # OK
>> end
=> nil

>> class Baz         # OK
>> end
=> nil
```
