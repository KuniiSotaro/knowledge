# 4-4.特異クラス

## 4-4-2.特異クラスの参照と定義

> @ todo 4-22,23

### `self`の参照先

* Rubyのコードは、オブジェクト(カレントオブジェクト)の内部で実行される。このオブジェクトを、`self`と呼ぶ

* `self`の役割を担えるオブジェクトは同時に複数は存在しない

* メソッドのレシーバが`self`になったら、全てのインスタンス変数は`self`のインスタンス変数になる。

  →レシーバを明示しないメソッド呼び出しは全て`self`に対しての呼び出しになる

* 他オブジェクトを明示してメソッドを呼び出すと、今度はそのオブジェクトが`self`になる

```ruby
>> class MyClass
>>   def testing_self
>>     @var = 10        # selfのインスタンス変数
>>     my_method        # `self.my_method`と同じ
>>     self
>>   end
>>   def my_method
>>     @var = @var + 1
>>   end
>> end
=> :my_method

>> obj = MyClass.new
=> #<MyClass:0x007fb18c0c3088>
>> obj.testing_self
=> #<MyClass:0x007fb18c0c3088 @var=11>
```

![オブジェクト_self](./images/オブジェクト_self.png)

### トップレベル

* メソッドを呼び出さない場合のオブジェクトの`self`は、`main`と呼ばれるオブジェクトの内部にいることになる。このオブジェクトを`トップレベルコンテキスト`という

* トップレベルの意味は、メソッドを呼び出していないとき、あるいは呼び出したメソッドが全て戻ってきた状態のことを言う

```ruby
>> self
=> main
>> self.class
=> Object
```

### クラス定義と`self`

* どこで使われるかで示すオブジェクトが異なる。メソッドのレシーバ(メソッドの受け手)自身を参照する

  * クラス内部で使用されれば、そのクラスを保持する

  * メソッド内部で使用されれば、そのメソッドを実行するオブジェクトを保持する(属しているインスタンスを参照できる)

```ruby
# クラス内部で使用
>> class MyClass
>>   p self
>> end
MyClass
=> MyClass

# メソッド内部で使用
>> class C1
>>   def method1
>>     self
>>   end
>> end
=> :method1

>> c1 = C1.new
=> #<C1:0x007fb96900cc68>
>> p c1 == c1.method1     # レシーバーと同じオブジェクト
true
=> true
```

![selfの参照先](./images/selfの参照先.png)

### `HelloWorld#name=`のメソッド呼び出し

* メソッド呼び出し時の`self`は省略することができない。省略するとローカル変数の代入として解釈される

```ruby
class helloWorld
  attr_accessor :name
  def greet
    puts "Hi, I am #{self.name}"
    puts "Hi, I am #{name}"        # レシーバを省略した呼び出し
  end
  def test_name
    name = "Ruby"                  # 変数nameの定義
    self.name = "Ruby"             # アクセサで定義したnameは、selfを省略できない
  end
end
```

### メソッドがネストした場合

* メソッドは、そのメソッドが定義されたクラスに所属する

* メソッドがネストした場合は、外側のメソッドが定義されたクラスに定義される

* 内側のメソッドは、外側のメソッドが実行されるまでは定義されない

```ruby
>> class C2
>>   def method1         # method1の定義先はC2
>>     def method2       # method2の定義先はmethod1のself(C2)
>>     end
>>   end
>> end
=> :method1

>> C2.instance_methods(false)  # まだmethod2はC2に定義されていない
=> [:method1]
>> C2.new.method1
=> :method2
>> C2.instance_methods(false)  # method1が実行され、method2が定義
=> [:method1, :method2]
```

***

## 4-4-3.`extend`メソッド

## 4-4-4.`prepend`メソッド

## 4-4-5.`Refinements`

* Rubyは既存のクラスに対して、メソッドを任意に変更したり追加することができるが、一度書き換えると全体へ影響を及ぼす

* この問題の解決策として、`Refinements`と言う仕組みができた

### `Refinements`の基本

* `refine`メソッドで変更を加えるクラスを宣言

* `using`メソッドを呼び出した以降から、変更したメソッドの呼び出しが有効になる

```ruby
module StringExtensions
  refine String do
    def to_alphanumeric
      gsub(/[^\w\s]/, '')
    end
  end
end

"my *1st* refinement!".to_alphanumeric
using StringExtensions
"my *1st* refinement!".to_alphanumeric

# 実行結果
NoMethodError: undefined method 'to_alphanumeric' for "my *1st* refinement!":String
"my 1st refinement"  # usingを使用しているので、変更される
```

* モジュールの中でも`using`を呼び出すことができ、モジュールの定義の終わりまで有効

* `refine`ブロックそのもので有効になる

* `using`を呼び出した場所からファイルの終わりまで(トップレベルにいる場合)有効になる

```ruby
>> module StringExtensions
>>   refine String do
?>     def reverse
>>       "esrever"
>>     end
>>   end
>> end
=> #<refinement:String@StringExtensions>

?> module StringStuff
>>   using StringExtensions
>>   "my_string".reverse
>> end
=> "esrever"

?> "my_string".reverse
=> "gnirts_ym"
```

### `Refinements`の問題点

* `using`の呼び出しの後に`my_method`を呼び出すと、refineされたバージョンのメソッドが手に入る

* 一方、`using`の後に`another_method`を呼び出すと、元のrefineされていないバージョンのメソッドが呼び出される

  →メソッド呼び出しの時に、再確認する必要がある

```ruby
class MyClass
  def my_method
    "original my_method"
  end

  def another_method
    my_method
  end
end

module MyClassRefinements
  refine MyClass do
    def my_method
      "refined my_method"
    end
  end
end

using MyClassRefinements
MyClass.new.my_method
MyClass.new.another_method

# 実行結果
"refined my_method"
"original my_method"
```

* 他にも、クラスはモジュールであるにも関わらず、クラスの中では呼び出せない

* `methods`や`ancestors`などのメタプログラミングのメソッドは、`Refinements`を無視する


|版|年/月/日|
|--|-------|
|初版|2018/10/|
