# 第4章 オブジェクト指向

## Silverの範囲

* クラス定義
* モジュール定義

4章では、構文の知識を問う問題なので、あまり難しい場合はカット

***

## 4-1.クラス定義

クラス定義の例

```ruby
>> class Foo
>>   def initialize(a)
>>     @a = a
>>   end
>>   def method1
>>     @a
>>   end
>> end
=> :method1
>> foo1 = Foo.new(1)
=> #<Foo:0x007fc8890059c0 @a=1>
>> foo2 = Foo.new(2)
=> #<Foo:0x007fc889873558 @a=2>
>> p foo1.method1
1
=> 1
>> p foo2.method1
2
=> 2
```

### 4-1-1.`class式`

#### クラス定義

* クラス名：大文字で始める
  →クラス名は、 **定数** のため

* Rubyインタプリタのクラス定義は、

  1. 指定された`クラス名`で **定数** を作成する

  2. `1`の **定数** に、定義された`クラス`を格納する

```ruby
class <クラス名>
end
```

#### クラスオブジェクト

* Rubyにおいて、クラスは`オブジェクト`
  →メソッドの実行や、変数の再代入が可能

```ruby
>> a = Foo        # Fooの参照先を変数aに代入
=> Foo
>> a.new(1)       # Fooを扱うのと同じように操作可能
=> #<Foo:0x007ffa2e9ab5e8 @a=1>
>> Foo = 1        # 定数なので警告が出る
(irb):12: warning: already initialized constant Foo
(irb):2: warning: previous definition of Foo was here
=> 1
```

#### `class式`の評価順序

* `class式`が評価されると、クラス定義の内部が評価される

```ruby
>> p 1
1
=> 1
>> class Hoge
>>   p 2
>> end
2
=> 2
>> p 3           # 1 2 3の順序で出力
3
=> 3
```

***

### 4-1-2.`インスタンスメソッド`と`初期化メソッド`

```ruby
>> class Foo
>>   def initialize(a)
>>     @a = a
>>   end
>>   def method1
>>     @a
>>   end
>> end
=> :method1
>> foo1 = Foo.new(1)
=> #<Foo:0x007fc8890059c0 @a=1>
>> foo2 = Foo.new(2)
=> #<Foo:0x007fc889873558 @a=2>
>> p foo1.method1
1
=> 1
>> p foo2.method1
2
=> 2
```

#### 解説

* `def method1`：インスタンスメソッドの定義。クラス内部に記述することで、そのクラスのインスタンスメソッドになる。
  →`method1`というインスタンスメソッドを、`Fooクラス`に定義

* `def initialize(a)`：初期化の時に実行されるメソッド
  →引数`a`を受ける初期化メソッドを定義

* `@a`：インスタンス変数。変数名の先頭に`@`を付けることで、値がインスタンスに保持される

* `Foo.new()`：作成したクラスオブジェクトに対して、`new`メソッドを実行することで、インスタンスを生成できる
  →`new`メソッドに渡した引数が異なるので、`@`は異なる値で初期化

***

#### `classメソッド`

* インスタンスから生成元のクラスオブジェクトを参照するには、インスタンスに対して`classメソッド`を呼び出す

```ruby
>> foo1.class == Foo
=> true
```

* `foo1`に対して`classメソッド`を実行し、その結果が`Foo`の参照先と一致しているかどうか判定

* `foo1`が指すオブジェクトは、`Fooクラス`のインスタンスなので、`foo1.class`は`Foo`が返り、条件式は`true`

***

### 4-1-3.クラス継承

* `Fooクラス`を継承した`FooExt`クラスを定義

* class定義において、`<`で区切ってクラスオブジェクトを指定すると、指定したオブジェクトを継承したクラスオブジェクトを生成
  →`Fooクラス`を継承しているので、`method1`を`FooExtクラス`でも実行可能

```ruby
>> class FooExt < Foo
>>   def initialize(a,b)
>>     @b = b
>>     super a
>>   end
>>   def method2(c)
>>     @a + @b + c
>>   end
>> end
=> :method2
>> fooExt = FooExt.new(3,4)
=> #<FooExt:0x007f9a9b995ee8 @b=4, @a=3>
>> p fooExt.method1
3
=> 3
>> p fooExt.method2(5)
12
=> 12
```

***

#### スーパークラスの取得

* クラスオブジェクトからスーパークラスを取得するには、クラスオブジェクトに対して`superclassメソッド`を実行することで参照

```ruby
>> FooExt.superclass == Foo
=> true
```

***

### 4-1-4.`super`

```ruby
>> class FooExt < Foo
>>   def initialize(a,b)
>>     @b = b
>>     super a
>>   end
>>   def method2(c)
>>     @a + @b + c
>>   end
>> end
=> :method2
>> fooExt = FooExt.new(3,4)
=> #<FooExt:0x007f9a9b995ee8 @b=4, @a=3>
>> p fooExt.method1
3
=> 3
>> p fooExt.method2(5)
12
=> 12
```

#### 解説

* `def initialize(a,b)`では、`FooExtクラス`独自の初期化メソッドを定義

* 初期化メソッドでは、引数`b`の値をインスタンスに格納した上で、スーパークラスの初期化メソッドを呼び出している
  →`Fooクラス`の初期化メソッドは、引数で与えられた値を保持するので、
    結果的に`FooExt`のインスタンスは、初期化メソッドで引数で与えられた2つの値を保持

* スーパークラスの同名メソッドを呼び出す場合は、`super`を使う
  →任意のメソッドでも実行できる。カッコと引数を付けずに、`super`とすると、メソッドが受け取った引数を **そのまま** スーパークラスの同名メソッドに渡して実行する

※Silverで間違えている！！

例)
### 以下のコードを実行するとどうなりますか

```ruby
>> class Hoge
>>   attr_reader :message
>>   def initialize
>>     @message = "Hello"
>>   end
>> end
=> :initialize
>>
?> class Piyo < Hoge
>>   def initialize
>>     @message = "Hi"
>>     super
>>   end
>> end
=> :initialize
>>
?> puts Piyo.new.message
Hello
=> nil
```

#### 解説

1. `Piyo`クラス：インスタンス化される(`initialize`メソッド)。`@message`に`"Hi"`の文字を格納した後に、`super`メソッドを呼び出す。

2. `Hoge`クラス：`Piyo`のスーパークラス。`initialize`メソッドで`@message`に`"Hello"`を代入している。

* `super`：メソッドが受け取った引数を、 **そのまま** スーパークラスの同名メソッドに渡して実行する。(`()`と引数を付けない場合)

***

### 4-2.インスタンスメソッド

#### これまでの確認

* インスタンスは、クラスで定義されたインスタンスメソッドを呼び出すことができる

* 継承したクラスのインスタンスは、スーパークラスで定義されたインスタンスメソッドを呼び出すことができる

ここでは、Rubyインタプリタがどのように実行するメソッドを特定しているかを理解することで、

`モジュール`や`特異クラス`の理解を容易にする。

→呼び出されたメソッドが探索される経路を詳細に見てみる

### 4-2-1.クラスオブジェクト


* クラスをグループとして捉えた時、

  * プログラム上でのオブジェクトの **雛形** が`クラス`

  * `クラス`から`オブジェクト`を生成することを、 **インスタンス化** と呼ぶ

  * 例として、HTMLのクラス属性や正規表現の文字クラス

***


* `Fooクラス`に対応するオブジェクトが生成する

* インスタンスを生成すると、１つ上のクラスレイヤからオブジェクトが生成されてインスタンスレイヤに降ってくる

***


* メモリ上では、インスタンスメソッドはクラスオブジェクトに保持

* メモリ上では、インスタンス変数はインスタンスに保持

* `classオブジェクト`は、生成元のクラスオブジェクトを返す

***

### 4-2-2.継承したクラスオブジェクト

Silver試験範囲外なので、パス
それ以降も、クラス関係はパス

2018/08/22

***

## 4-3.Mix-in

Rubyで多重継承を実現する機能

### 4-3-1.モジュールの定義とインクルード

Rubyのクラス継承は、単一継承のみ許されている

→同時に複数のスーパークラスをもつ多重継承を許していない

→`class式`で指定できるスーパークラスは必ず１つ

***

#### Mix-inとモジュール

* クラスに機能を混ぜ合わせることで、複数のクラスで機能を共有する`Mix-in`という機能を提供

* 複数のクラスで適用したい機能は、`モジュール`というオブジェクトで定義

* モジュールの特徴

  * モジュールは、単独ではインスタンス化できない(`new`できない)

  * モジュールは、継承できない

  * モジュールは、クラスや他のモジュールに取り込むことができる

* クラスの代わりにモジュールというオブジェクトを生成し、これらをクラスに取り込むことでクラスの機能を拡張

* モジュールの目的は、 **名前空間の提供** と **Mix-inにおける機能の定義**

***

#### モジュールの定義

```ruby
>> module Bar
>>   def methodA
>>     @a
>>   end
>> end
=> :methodA
>> p Bar.ancestors
[Bar]
=> [Bar]
>> p Bar.instance_methods
[:methodA]
=> [:methodA]
>> p Bar.new
NoMethodError: undefined method ｀new｀ for Bar:Module
```

* 生成したモジュールオブジェクトは、`includeメソッド`を使用してクラスに取り込むことができる

```ruby
>> class FooExt < Foo
>>   include Bar
>> end
=> FooExt
>> fooExt = FooExt.new(3,4)
=> #<FooExt:0x007f9a9b9512c0 @b=4, @a=3>
>> p fooExt.methodA
3
=> 3
```

* `FooExt`のインスタンスから、`Bar`モジュールで定義された`methodA`を実行できる
  →`クラスFooExt`のインスタンスが、`モジュールBar`の機能を持っているため

***

### 4-3-2.モジュールのメソッドの探索経路

範囲外だと思われるため、カット

2018/08/22

## 4-4.特異クラス

これ以降は、Silverの範囲外なので、カット

2018/08/22

***
