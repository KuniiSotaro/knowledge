# `String`クラス

## 5-6-1.文字列の文字コード情報

* `UTF-8`：主に利用されている文字コード

* `EUC-JP`：古いUNIX系システムで利用されていた文字コード

* `JIS`：JISで策定された7bit文字のみを使った文字コード

* `Shift_JIS`：マルチバイト文字とASCII文字を切り替えることなく利用できるようにした文字コード

* `Windows-31J`：主にWindowsで利用されいるShift_JISの亜種。機種依存文字などが利用できる文字コード

* `US-ASCII`：ASCII文字だけで構成されている文字コード

***

### 文字列のエンコーディングの取得・変更

* `encoding`メソッド：`String`オブジェクトの文字コード情報(エンコーディング)を取得

* `encode`：引数で指定した文字コードに変換した新しいインスタンスを返す

* `encode!`：オブジェクトのエンコーディングを変更(破壊的メソッド)

* 文字列の操作は、このエンコーディング情報を元に行われるため、エンコーディングの異なる文字列を結合したり比較する際には注意が必要

```ruby
# エンコーディングの取得
>> a = "abc"
=> "abc"
>> a.encoding
=> #<Encoding:UTF-8>

# エンコーディングの変更(encode)
>> b = a.encode("EUC-JP")
=> "abc"
>> b.encoding
=> #<Encoding:EUC-JP>

# エンコーディングの変更(encode!)
>> a = "ルビー"
=> "ルビー"
>> a.encode!("EUC-JP")
=> "\x{A5EB}\x{A5D3}\x{A1BC}"
>> a.encoding
=> #<Encoding:EUC-JP>
```

***

## 5-6-2.文字列の比較

* `==`：大文字小文字、全角半角を含めて同じかどうかを比較

* `>`、`>=`、`<`、`<=`：文字列同士をアスキーコードで比較(`true`or`false`)

* `<=>`、`casecmp`：比較した結果を-1、0、1の整数値で返す(UFO演算子と同じ働き)
  →`<=>`は大文字小文字を区別するが、`casecmp`は区別しない

```ruby
>> "abc" == "abc"
=> true
>> "abc" == "ABC"  # 大文字小文字は区別
=> false
>> "a" < "b"       # 辞書順では、aの方が小さい
=> true
>> "A" > "a"       # なぜかわからないので、あとで調べる
=> false
>> "aa" < "b"      # 辞書順では、aaの方が小さい
=> true
>> "a" <=> "b"     # aの方が小さい(-1)
=> -1
```

***

### 文字列と数値の比較

* `==`メソッド：異なるクラスのオブジェクトと比較できる。(型の自動変換は行われないので、`false`)

```ruby
>> '100' == 100
=> false
>> '100' >= 100
ArgumentError: comparison of String with 100 failed
```

***

#### 文字列比較のときのエンコーディング

* `==`、`eql?`メソッド：両者のエンコーディングが等しく、文字列自身のバイト列表現が等しい場合のみ`true`を返す

* ただし、両者のエンコーディングがASCII互換でASCII文字しか含まない場合は、エンコーディングが異なる場合もバイト表現が一致すれば`true`を返す

```ruby
# ASCII互換
>> a = "abc"
=> "abc"
>> b = a.encode("EUC-JP")
=> "abc"
>> b.encoding
=> #<Encoding:EUC-JP>
>> a == b
=> true

>> a = "ルビー"
=> "ルビー"
>> b = a.encode("EUC-JP")
=> "\x{A5EB}\x{A5D3}\x{A1BC}"
>> a == b
=> false
```

***

## 5-6-3.文字列の切り出し

* `[]`、`slice`：文字列から指定された一部分を切り出すメソッド

* `slice!`：文字列から指定された一部分を切り出し、返した文字を元の文字列から取り除く

* `split`：文字列や正規表現を使って文字列を分割

```ruby
# []
>> a = 'abcdef'
=> "abcdef"
>> puts a[2]
c
=> nil

# slice
>> a.slice(2)
=> "c"

# slice!
>> a.slice!(2)
=> "c"
>> puts a
abdef
=> nil

# split
>> 'abcdefg'.split('d')
=> ["abc", "efg"]
>> 'abcdef'.split(/d/)
=> ["abc", "ef"]
>> "abcde\nfghij".split(/\n/)  # ダブルクオートに注意
=> ["abcde", "fghij"]
```

※Silverで間違えている！！

* `String#slice(nth, len)`：文字列の`nth`目から`len`文字の文字列を作って返します。

```ruby
# 解答
>> string = "test code"
=> "test code"
>> string.slice(0,4)
=> "test"
>> p string
"test code"
=> "test code"

# 破壊的メソッドの場合
>> string = "test code"
=> "test code"
>> string.slice!(0,4)
=> "test"
>> p string    # 0から4番目(test )が削除
" code"
=> " code"
```

* `";|:"`は文字列中にないので、そのまま(正規表現で指定すれば、分割される)

```ruby
>> str = "1;2:3;4"
=> "1;2:3;4"
>> p str.split(";|:")
["1;2:3;4"]
=> ["1;2:3;4"]

# 例
>> p str.split(/;|:/)
["1", "2", "3", "4"]
=> ["1", "2", "3", "4"]
```

* `String#split`メソッドは引数で指定した特定の文字列を区切り文字として、文字列から配列を生成します。

また、第二引数で生成される配列の要素数を指定することもできます。

```ruby
>> str = "a,b,c,d"
=> "a,b,c,d"
>> p str.split(/,/, 2)
["a", "b,c,d"]
=> ["a", "b,c,d"]
```

***

### 数値を指定した場合

* 数値を指定した場合は、数値の位置にある文字を返す

* 負の数値の場合は、末尾から数えてた位置の文字を返す

```ruby
>> 'abcdefg'[2]       # 0,1,2・・・"c"
=> "c"
>> 'abcdefg'.slice(2) # 0,1,2・・・"c"
=> "c"
>> 'abcdefg'[-2]      # 6,5・・・"f"
=> "f"
>> a = 'abcdefg'
=> "abcdefg"
>> a.slice!(2)        # 0,1,2・・・"c"でカット
=> "c"
>> puts a
abdefg
=> nil
```

***

### 範囲指定の場合

* 範囲として`Range`オブジェクトを指定した場合は、該当する範囲の文字列を返す

* 範囲指定は、開始位置と長さで指定可能。

  * 開始位置が範囲外の場合：`nil`

  * 開始位置が負の場合：末尾から数えた位置となる

  * 長さが文字列より長い場合には、可能な部分までを返す

```ruby
# Rangeオブジェクトで指定
>> puts a
abdefg
=> nil
>> 'abcdefg'[1..3]
=> "bcd"
>> 'abcdefg'.slice(1..3)
=> "bcd"
>> a = 'abcdefg'
=> "abcdefg"
>> a.slice!(1..3)
=> "bcd"
>> puts a
aefg
=> nil

# 開始位置と長さで指定
>> 'abcdefg'[1,3]
=> "bcd"
>> 'abcdefg'.slice(1,3)
=> "bcd"
>> 'abcdefg'[-2,3]  # 最後から2文字目から、3文字(どう頑張っても最後から2文字分しか出力されない)
=> "fg"
>> a = 'abcdefg'
=> "abcdefg"
>> a.slice!(1,3)
=> "bcd"
>> puts a
aefg
=> nil
```

***

### 文字列で指定

* 元の文字列に含まれていればその部分を、含まれていなければ`nil`を返す

```ruby
>> 'abcdefg'["bc"]
=> "bc"
>> 'abcdefg'.slice("bc")
=> "bc"
>> 'abcdefg'["bd"]  # "bd"で表される文字は含まれない
=> nil
>> a = 'abcdefg'
=> "abcdefg"
>> a.slice!("bc")
=> "bc"
>> puts a
adefg
=> nil
```

***

#### 正規表現で指定

* マッチした部分があればその部分を、マッチしなければ`nil`を返す

```ruby
>> 'abcdefg'[/bc/]
=> "bc"
>> 'abcdefg'.slice(/bc/)
=> "bc"
>> a = 'abcdefg'
=> "abcdefg"
>> a.slice!(/bc/)
=> "bc"
>> puts a
adefg
=> nil
```

※Silverで間違えている！！

* `slice`は、最初にマッチしたものを返す

```ruby
>> p "hogepiyohogehoge".slice(/o../)
"oge"
=> "oge"
```

***

## 5-6-4.文字列の変更

* `[]=`、`insert`メソッド：文字列の一部分を変更する。範囲や位置の指定ができ、該当する部分を新しい文字列で置換することができる

```ruby
>> a = 'abcdefg'
=> "abcdefg"
>> a[1..3] = 'xyz'
=> "xyz"
>> puts a
axyzefg
=> nil

# インデックスが足りなくても、挿入する文字自体はそのまま挿入される。指定していない文字も消される。
>> a = 'abcdefgh'
=> "abcdefgh"
>> a[1..2] = 'xyz'
=> "xyz"
>> a
=> "axyzdefgh"
```

***

## 5-6-5.文字列の置換

* 定数を置換する場合、警告が発生しない。オブジェクトIDが変更されない為

### `sub`メソッド・`gsub`メソッド

* `sub`メソッド：指定したパターンにマッチした最初の部分を、特定の文字列に置換する

* `gsub`メソッド：マッチした全ての部分を置換する

```ruby
>> a = 'abcdefg-abcdefg'
=> "abcdefg-abcdefg"
>> a.sub(/abc/, 'xyz')
=> "xyzdefg-abcdefg"
>> a.sub(/abc/, 'xyz')
=> "xyzdefg-abcdefg"
```

* ブロックも取ることができ、その場合にはブロックにマッチした部分が渡され、ブロックの実行結果と置換される

```ruby
>> a = 'abcdefg-abcdefg'
=> "abcdefg-abcdefg"
>> a.sub(/abc/) {|str| 'xyz'}
=> "xyzdefg-abcdefg"
>> a.gsub(/abc/) {|str| 'xyz'}
=> "xyzdefg-xyzdefg"
```

***

### `tr`メソッド・`tr_s`メソッド

* `tr`メソッド：指定したパターンに含まれる文字を検索し、それを特定の文字列やパターンに合わせて置換する

* `tr_s`メソッド：`tr`メソッドの機能に加えて、重複する文字を1文字に圧縮

```ruby
>> a = 'aabbccddeeffgg'
=> "aabbccddeeffgg"
>> a.tr('a-c', 'A-C')
=> "AABBCCddeeffgg"
>> a.tr_s('a-c', 'A-C')
=> "ABCddeeffgg"
```

***

### `delete`メソッド

* 指定したパターンに含まれる文字を、元の文字列から削除

* パターンを複数指定すると、全てのパターンに含まれる文字列のみ削除する

```ruby
>> a = 'aabbccddeeffgg'
=> "aabbccddeeffgg"
>> a.delete('a-f', 'd-g')
=> "aabbccgg"
```

※Silverで間違えている！！

```ruby
>> puts "0123456789-".delete("^13-56-")
13456-
=> nil

>> puts "0123456789".delete("0-58-")
679
=> nil

>> puts "Ruby on Rails".delete("Rails")  # R、a、i、l、sの5文字を指定して取り除く
uby on
=> nil
```

* `String#delete`は、引数に含まれる文字を文字列から取り除く

* `^`で始まる文字列は、その文字列以外を削除する。(例：`[^1]`の場合、`1`以外を削除する)

* `[-]`は文字の範囲を示す。(例：`[1-3]`の場合、1,2,3を意味する)

* `-`の両端に文字列がある場合は範囲指定をしていることになります。

* `"0-5"`で0から5までの数字を取り除きますが、続く`"8-"`では範囲指定とは見なされず、8と-を削除します。

* 正規表現とは別物として考える！！

***

### `squeeze`メソッド

* 指定した文字が複数並んでいた場合に、一文字に圧縮

```ruby
>> a = 'aabbccddeeffgg'
=> "aabbccddeeffgg"
>> a.squeeze('a-e')
=> "abcdeffgg"
```

***

### `replace`メソッド

* 引数の文字列で自分自身の内容を置き換える

```ruby
>> a = 'abc'
=> "abc"
>> a.object_id
=> 70159960401620
>> a.replace('xyz')
=> "xyz"
>> a.object_id
=> 70159960401620    # 置換されただけなので、オブジェクトIDは変更されない
>> puts a
xyz
=> nil
```

***

## 5-6-6.文字列の連結

* `+`：文字列を結合した新しいオブジェクトを生成

* `*`：文字列の内容を指定した数値の数だけ、繰り返した文字列を返す

* `<<`、`concat`：元のオブジェクトの内容に文字列を追記
  →破壊的メソッド

* 異なるエンコーディングの文字列を結合するとき、互換性がない場合はエラー

* 互換性がなくても、文字列がASCII文字列のみからなるASCII互換であれば結合可能

```ruby
>> a = 'abc'
=> "abc"
>> a.object_id
=> 70263014985560   # 元々のオブジェクト
>> a << 'def'
=> "abcdef"
>> a.object_id
=> 70263014985560   # 同じオブジェクト
>> a = a + 'ghi'
=> "abcdefghi"
>> a.object_id
=> 70263018562880   # 新しいオブジェクト
>> 'abc' * 2
=> "abcabc"
```

※Silverで間違えている

* `String`に`append`メソッドはありません。
  文字列を結合するには、`String<<`を用います。

```ruby
>> a = "Ruby"
=> "Ruby"
>> b = " on Rails"
=> " on Rails"
>> a.append b
NoMethodError: undefined method ｀append｀ for "Ruby":String

# 文法を変えた場合
>> a << b
=> "Ruby on Rails"
>> a.reverse       # 破壊的メソッドではない
=> "sliaR no ybuR"
>> p a
"Ruby on Rails"
=> "Ruby on Rails"
>> p a.index("R", 1)   # 右から1番目(u)から、最初にRが見つかる場所(8番目)
8
=> 8
```

***

## 5-6-7.文字列の大文字・小文字への変換

* `capitalize`：文字列の先頭にある半角英字を大文字に、残りの半角英字を小文字にして返す

* `downcase`、`upcase`：それぞれ半角英字を小文字化、大文字化して返す

* `swapcase`：半角英字の小文字を大文字に、大文字を小文字に変更して返す

```ruby
>> a = 'abcDEF'
=> "abcDEF"
>> a.capitalize
=> "Abcdef"
>> a.upcase
=> "ABCDEF"
>> a.downcase
=> "abcdef"
>> a.swapcase
=> "ABCdef"
```

***

## 5-6-8.文字列の末尾や先頭にある空白や改行を削除

* `chomp`：末尾から引数で指定する改行コードを取り除いた文字列を返す。
  →指定がない場合は、`"\r"`、`"\r\n"`、`"\n"`の全てを改行コードと見なして取り除く

* `strip`、`lstrip`、`rstrip`：先頭と末尾、先頭、末尾にある空白文字を取り除いた文字列を返す
  →`"\t"`、`"\r"`、`"\n"`、`"\f"`、`"\v"`など

* `chop`：末尾の文字を取り除いた文字列を返す

```ruby
>> a = "\nabcdef\n"
=> "abcdef\n"
>> a.chomp         # 末尾の改行コードを取り除く
=> "\nabcdef"
>> a.strip         # 改行コードを取り除く
=> "abcdef"
>> a.lstrip        # 左の改行コードを取り除く
=> "abcdef\n"
>> a.rstrip        # 右の改行コードを取り除く
=> "\nabcdef"
>> a.chop          # 末尾の文字を取り除く
=> "\nabcdef"
>> a.chop.chop     # 末尾から2文字取り除く
=> "\nabcde"
>> a.chomp.chomp   # 改行コードのみ取り除く
=> "\nabcdef"
```

※Silverで間違えている

`str.chop`は末尾の文字を取り除きます。ただし、文字列の末尾が`"\r\n"`であれば、2文字とも取り除きます。
破壊的メソッドではないので、`self`は影響を受けません。

```ruby
>> str = "Liberty Fish   \r\n"
=> "Liberty Fish   \r\n"
>> str.chop
=> "Liberty Fish   "
>> p str
"Liberty Fish   \r\n"
=> "Liberty Fish   \r\n"
>> str.chop!
=> "Liberty Fish   "
>> p str
"Liberty Fish   "
=> "Liberty Fish   "
```

***

## 5-6-9.文字列を逆順にする

* `reverse`：並び順をバイト単位で逆にする

```ruby
>> a = "abcdef"
=> "abcdef"
>> a.reverse
=> "fedcba"
```

***

## 5-6-10.文字列の長さ

* `length`、`size`：文字数を返す

* `count`：指定されたパターンに該当する文字がいくつあるかを返す

* `empty?`：文字列が空かどうかを返す

* `bytesize`：バイト数が返る

```ruby
# 文字列の長さ
>> a = "abcdef"
=> "abcdef"
>> a.length
=> 6
>> a.count('a-c')
=> 3
>> a.empty?
=> false
>> "".empty?
=> true

# 文字列のバイト数
>> a = "ルビー"
=> "ルビー"
>> a.length
=> 3
>> a.bytesize
=> 9
```

***

## 5-6-11.文字列の割り付け

文字列をある長さの文字列の中に割り付ける

メソッドを呼び出すときに、

  * 返す文字列の長さ

  * 割り付ける余白に使用する文字

を指定できる

* `center`：中央に割り付ける

* `ljust`：左側に割り付ける

* `rjust`：右側に割り付ける

```ruby
>> a = "abc"
=> "abc"
>> a.center(20)
=> "        abc         "
>> a.center(20, "*")
=> "********abc*********"
>> a.ljust(20)
=> "abc                 "
>> a.rjust(20, "-")
=> "-----------------abc"
```

***

## 5-6-12.批評文字列を変換する

* `dump`：文字列の中にある改行コード(`"\n"`)や、タブ文字(`"\t"`)の非表示文字列を
  バックスラッシュ記法に置き換えた文字列を返す
  →例)改行コード(`"\n"`)、タブ文字(`"\t"`)

```ruby
>> a = "abc\tdef\tghi\n"
=> "abc\tdef\tghi\n"
>> puts a
abc	def	ghi
=> nil
>> puts a.dump
"abc\tdef\tghi\n"
=> nil
```

***

## 5-6-13.文字列をアンパックする

* `unpack`： **Array#pack** メソッドでパックされた文字列を、指定したテンプレートにし違ってアンパックする

例)MINEエンコードされた文字列のデコードや、バイナリデータから数値への変換などに利用

```ruby
# MINEエンコードされた文字列をアンパックする
>> '440r440T4408'.unpack('m')
=> ["\xE3\x8D+\xE3\x8D\x13\xE3\x8D<"]
```

* アンパックされた文字列のエンコーディングは、ASCII-8BITになる

```ruby
>> a = '440r440T4408'.unpack('m').first
=> "\xE3\x8D+\xE3\x8D\x13\xE3\x8D<"
>> a.force_encoding('UTF-8')
=> "\xE3\x8D+\xE3\x8D\u0013\xE3\x8D<"
```

***

## 5-6-14.文字列内での検索

* `include?`：指定した文字列が含まれている場合に`true`を返す

* `index`：指定された文字や文字コードの数値・正規表現などのパターンを、指定された一から右方向に検索して、
  最初に見つかった位置を返す

* `rindex`：`index`メソッドとは逆に左方向に検索する。同じ位置を参照する

* `match`：指定された正規表現によるマッチングを行い、マッチした場合には`MatchData`オブジェクトを返す
  →1個だけマッチしたオブジェクトを返す

* `scan`：指定された正規表現にマッチした部分文字列の配列を返す。ブロックを渡すことも可能
  →複数個マッチした配列を返す

```ruby
>> "abcdefg".include?("abc")
=> true
>> "abcdefg".index("bc")
=> 1
>> "abcdefg".match(/[c-f]/)
=> #<MatchData "c">
>> "abcdefg".scan(/[c-d]/)
=> ["c", "d"]
```

※Silverで間違えている

* `match`が一度しか正規表現によるマッチを行わないのに対し、`scan`は繰り返しマッチを行います。

```ruby
>> s = "To be or not to be, that is the question."
=> "To be or not to be, that is the question."
>> hash = Hash.new(0)
=> {}
>> s.scan(/\w+/) {|i| hash[i] += 1}
=> "To be or not to be, that is the question."
>> p hash["be"]
2
=> 2
```

***

## 5-6-15.次の文字列を求める

* `succ`、`next`：次の文字列を求める

ここでの **次の文字列** とは、、、

対象となる文字列の右端がアルファベットならアルファベット順に、数字であれば10進数の数値と見なして計算

計算時に桁上がりが発生した場合は、それに応じて１つ左の文字が変化するか、文字列が伸長する

```ruby
>> "abc123".succ
=> "abc124"
>> "123abc".succ
=> "123abd"
>> "123xyz".succ
=> "123xza"
>> "99999".succ
=> "100000"
>> "zzzzz".succ
=> "aaaaaa"
>> "ZZZZZ".succ
=> "AAAAAA"
```

***

## 5-6-16.文字列に対する繰り返し

* `each_line`、`lines`：文字列の各行に対して繰り返す。オプションとして行の区切りを指定可能

* `each_byte`、`bytes`：文字列をバイト単位で繰り返す

* `each_char`、`chars`：文字単位で繰り返す

* `upto`：自分自身から指定された文字列まで、`succ`メソッドで生成される次の文字列を使って繰り返す

```ruby
>> "abc\ndef\nghi".each_line {|c| puts c}
abc
def
ghi
=> "abc\ndef\nghi"
>> "abc".each_byte {|c| puts c
>> }
97
98
99
=> "abc"
>> "ルビー".each_char {|c| puts c}
ル
ビ
ー
=> "ルビー"
>> "a".upto("c") {|c| puts c}
a
b
c
=> "a"
```

***

## 5-6-17.他のクラスへの変換

### `hex`メソッド

* 文字列が16進数であるとして、数値に変換

* 接頭辞`0x`、`0X`とアンダースコア`_`は無視され、
  16進数以外の文字がある場合にはそれ以降も無視

```ruby
>> "abc".hex
=> 2748
>> "azc".hex
=> 10
>> "0xazc".hex
=> 10
```

***

### `oct`メソッド

* 文字列が8進数であるとして、数値に変換

* `hex`メソッドとは異なり、接頭辞に応じて8進数以外の変換も行う

```ruby
>> "010".oct
=> 8
>> "0b010".oct   # 0bで2進数指定
=> 2
>> "0x010".oct   # 0xで16進数指定
=> 16
```

***

### `to_i`メソッド

* 文字列を10進数の整数であるとして、数値に変換する

* 整数として見なせない文字があれば、そこまでを変換して以降を無視する

* 空文字であれば、0を返す

```ruby
>> "123".to_i
=> 123
>> "0123".to_i
=> 123
>> "0x123".to_i
=> 0
>> "".to_i
=> 0
>> "110".to_i(2)   # 110(2進数)を、10進数に変換
=> 6
```

※Silverで間違えている！！

***

### `to_f`メソッド

* 文字列を10進数の小数として、`Float`オブジェクトに変換する

* 小数と見なせない文字があれば、そこまでを変換して以降を無視する

* 空文字であれば、0.0を返す

```ruby
>> "1.23".to_f
=> 1.23
>> "01.23".to_f
=> 1.23
>> "0x1.23".to_f
=> 0.0
>> "".to_f
=> 0.0
```

***

### `to_s`、`to_str`メソッド

* 自分自身を返す

```ruby
>> "ルビー".to_s
=> "ルビー"
>> "ルビー".to_str
=> "ルビー"

# IntegerクラスからStringクラスへの変換
>> 7.to_s(3)   # 7を3進数の文字列に変換
=> "21"
```

***

### `to_sym`、`intern`メソッド

* 文字列に対応するシンボル値を返す

```ruby
=> :abc
>> a.object_id
=> 70263022623280    # オブジェクトid
>> b = :abc
=> :abc
>> b.object_id
=> 70263022623280    # 同じオブジェクトid
```

※以下のクラスは、`String`クラスに用意されていない

* `to_h`

* `to_a`

***

# 5-7.`Array`クラス

## 5-7-1.配列の生成

* `配列式`と呼ばれる記法で配列を生成

* `Array`クラスのクラスメソッドである、 **`[]`メソッド** や **`new`メソッド** を使って配列を生成

```ruby
# 配列の生成(1)
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.class
=> Array

# 配列の生成(2)
>> Array[1, 2, 3]            # `[]`メソッドは、引数に要素を指定
=> [1, 2, 3]

# 配列の生成(3)
>> Array.new(3, "str")       # `new`メソッドでの、配列の長さと初期値を指定
=> ["str", "str", "str"]

# 配列の生成(4)
>> Array.new([1, 2, 3])      # `new`メソッドでの、引数に配列を指定する方法(配列の複製)
=> [1, 2, 3]

# 配列の生成(5)
>> Array.new(3) {|i| i * 3}  # `new`メソッドに、配列の長さとブロックを渡す方法(ブロックには、配列のインデックスを渡す)
=> [0, 3, 6]
```

***

## 5-7-2.配列に要素を追加する

### 全て破壊的メソッドなので、注意する

* `<<`メソッド・`push`メソッド：指定された引数にあるオブジェクトを、自分自身の末尾に追加

* `concat`メソッド：指定された配列を、自分自身の末尾に連結

* `insert`メソッド：1番目の引数で指定された場所に、それ以降で指定されたオブジェクトを挿入

* `unshift`メソッド：指定されたオブジェクトを、配列の先頭に追加。引数がない場合は実行しない

```ruby
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a << 4                      # 末尾に[4]を追加
=> [1, 2, 3, 4]
>> a.concat [5, 6]             # 末尾に[5,6]を追加
=> [1, 2, 3, 4, 5, 6]
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.unshift(10)               # 配列aの先頭に、[10]を追加
=> [10, 1, 2, 3]
```

### 以下、非破壊メソッド

* `+`メソッド：自分自身と引数で与えられた配列を連結した配列を新たに生成して返す

```ruby
>> a = [1, 2, 3, 9, 4, 5, 6]   # 配列の3番目に、[9]を追加
[1, 2, 3, 9, 4, 5, 6]
>> a.object_id
=> 70235495510920
>> b = a + [10]                # 配列aの末尾に、10を追加
=> [1, 2, 3, 9, 4, 5, 6, 10]
>> b.object_id
=> 70235499700020
```

***

## 5-7-3.配列の要素を変更する

* `[]=`メソッド：指定したインデックスにある要素を書き換える

※インデックスは、整数や`Range`オブジェクト、始点と終点を指定可能。
配列の要素数よりも大きな数が指定された場合は、自動的に配列の長さが伸長され、その部分は`nil`で初期化される。

* `fill`メソッド：配列の全ての要素を指定したオブジェクトに変更

※引数を2つ以上取る場合は、配列の始点と終点や、`Range`オブジェクトを取ることもでき、その場合は該当する部分のみ変更する。
ブロックを取ることもでき、その場合はブロックの評価結果で要素を変更する。

* `replace`メソッド：引数で指定された配列で、自分自身の内容を置き換える。オブジェクトIDが変化しない。

```ruby
# `[]=`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a[1] = 10          # 配列の1番目に、10を追加
=> 10
>> a
=> [1, 10, 3]
>> a[1..2] = [11, 12] # 配列の1〜2番目に、11と12を追加
=> [11, 12]
>> a
=> [1, 11, 12]
>> a[8] = 8           # 配列の8番目に、8を追加(3〜7番目は`nil`)
=> 8
>> a
=> [1, 11, 12, nil, nil, nil, nil, nil, 8]

# `fill`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.fill("s")                   # aの配列の内容を、全て"s"に変更
=> ["s", "s", "s"]
>> a.fill("t", 1..2)             # aの配列のうち、1〜2番目を"t"に変更
=> ["s", "t", "t"]
>> a
=> ["s", "t", "t"]
>> a.fill("u", 1, 2)             # 第1引数："u"に変更、第2引数：1番目から、第3引数：2文字分
=> ["s", "u", "u"]
>> a.fill(1..2){|index| index}   # aの配列のうち、1〜2番目を1、2に変更
=> ["s", 1, 2]

# `replace`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.object_id
=> 70273659485340
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.object_id          # 異なるオブジェクトID
=> 70273659433960
>> a.replace([4, 5, 6])
=> [4, 5, 6]
>> a.object_id
=> 70273659433960       # 置換する前と同じオブジェクトID
```

***

## 5-7-4.配列の要素を参照する

* `[]`メソッド：変更の場合と同様に、 **整数** や **`Range`オブジェクト** 、始点と終点で指定したインデックスに対応する要素を返す

* `slice`メソッド：`[]`メソッドと同様

* `at`メソッド：`[]`メソッドと同様だが、インデックスが整数の場合に利用する。要素数よりも大きい場合は、`nil`を返す

* `values_at`メソッド：`[]`メソッドと同様の動作をするが、結果を配列で返す

```ruby
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a[1]            # 配列aの1番目の値を取り出す
=> 2
>> a.at(1)         # 配列aの1番目の値を取り出す
=> 2
>> a[1..2]         # 配列aの1〜2番目の配列を取り出す
=> [2, 3]
>> a.values_at(1)  # 配列aの1番目の配列を取り出す
=> [2]
```

***

* `fetch`メソッド：`at`メソッドと同様。引数がインデックスのみの場合は、`IndexError`が発生する。
  2番目の引数がある場合にはその値を、ブロックを取っている場合はその評価結果を返す

* `first`メソッド：配列の先頭を返す。引数が指定された場合は、先頭から指定した数だけ要素を返す

* `last`メソッド：配列の末尾の要素を返す。引数が指定された場合は、末尾から指定した数だけ要素を返す

* `assoc`メソッド：配列の配列を検索し、その配列の最初の要素が指定された値と`==`で等しければ、その配列を返す
  該当する要素がなければ、`nil`を返す

* `rassoc`メソッド：配列の配列を検索し、その配列のインデックス1の要素が指定された値と`==`で等しければ、その要素を返す

```ruby
# `fetch`メソッド
>> a = [1, 2, 3]
=> [1, 2, 3]
>> a.fetch(4)
IndexError: index 4 outside of array bounds: -3...3
>> a.fetch 4, "ERROR"
=> "ERROR"
>> a.fetch(4){|n| "ERROR #{n}"}
=> "ERROR 4"

# `first`、`last`メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.first
=> 1
>> a.last
=> 5
>> a.first(3)   # 最初から3個まで出力
=> [1, 2, 3]

# `assoc`メソッド
>> a = [[1, 2], [3, 4], [5, 6], [7, 8]]
=> [[1, 2], [3, 4], [5, 6], [7, 8]]
>> a.assoc(3)     # 配列の最初の要素が3の配列は、[3, 4]
=> [3, 4]

# `rassoc`メソッド
>> a = [[1, 2], [3, 4], [5, 6], [7, 8]]
=> [[1, 2], [3, 4], [5, 6], [7, 8]]
>> a.rassoc(4)    # 配列の要素に4が含まれる配列は、[3, 4]
=> [3, 4]
```

***

## 5-7-5.配列の要素を調べる

* `include?`メソッド：指定された値が要素の中に存在する場合に、 **真** を返す

* `index`、`rindex`メソッド：それぞれの配列の先頭と末尾から指定された値と`==`で等しい要素の位置を返す
  見つからない場合は、`nil`を返す。

※`rindex`は末尾から探すが、配列の位置は末尾から指定できないので、`index`と同じインデックスとなる。

```ruby
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.include?(3)
=> true
>> a.include?(10)
=> false
>> a.index(4)
=> 3
>> a.rindex(4)
=> 3
```

***

## 5-7-6.配列の要素を削除する

### 全て破壊的メソッドなので注意！

* `delete_at`メソッド：指定されたインデックスに対応する要素を取り除き、その要素を返す

* `delete_if`・`reject!`メソッド：ブロックに要素を渡し、その評価結果が真になった要素を全て取り除いた自分自身を返す。
  →Silverではよく間違えていた！！

* `delete`メソッド：指定された値と`==`メソッドで等しい要素があれば、取り除いてその値を、なければ`nil`を返す

* `clear`メソッド：要素を全て削除する

* `slice!`メソッド：指定されたインデックスに対応する要素を取り除き、その取り除いた要素を返す。(インデックスには整数やRangeオブジェクト、視点と長さを指定可能)

* `shift`メソッド：先頭から指定された数だけ要素を取り除いて返す。指定がなければ、1が指定されたとして先頭の要素を返す

* `pop`メソッド：末尾から指定された数だけ要素を取り除いて返す。指定がなければ、1が指定されたとして末尾の要素を返す(`shift`メソッドの逆)

* `-`メソッド：指定された配列にある要素を、自分自身から取り除いた配列を返す

```ruby
# delete_atメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete_at(2)
=> 3
>> a
=> [1, 2, 4, 5]

# delete_ifメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete_if{|n| n % 2 == 0}
=> [1, 3, 5]

# deleteメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.delete(3)
=> 3
>> a
=> [1, 2, 4, 5]
>> a.delete(10)
=> nil
>> a
=> [1, 2, 4, 5]

# clearメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.clear
=> []

# slice!メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.slice!(2,2)        # 2番目から2つの値を削除(2、3番目の値を削除)
=> [3, 4]
>> a
=> [1, 2, 5]

# shiftメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.shift(2)           # 先頭から2個削除
=> [1, 2]
>> a
=> [3, 4, 5]
>> a.shift              # 先頭から1個削除
=> 3
>> a
=> [4, 5]

# popメソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a.pop(2)             # 末尾から2個削除
=> [4, 5]
>> a
=> [1, 2, 3]
>> a.pop                # 末尾から1個削除
=> 3
>> a
=> [1, 2]

# -メソッド
>> a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
>> a - [1, 2]
=> [3, 4, 5]
>> a - [1, 3, 5, 7]
=> [2, 4]
```

***

## 5-7-7.配列の演算

Rubyでは、配列を集合と見なした演算ができる

* `|`メソッド：和集合を求める。両方のいずれかに含まれる要素を含む配列を返す

* `&`メソッド：積集合を求める。両方に含まれる要素を含む配列を返す

```ruby
# |メソッド
>> [1, 2, 3] | [1, 3, 5]
=> [1, 2, 3, 5]

# &メソッド
>> [1, 2, 3] & [1, 3, 5]
=> [1, 3]
```

***

## 5-7-8.配列の比較

* `==`メソッド：配列同士を比較する。先頭から要素を比較し、全ての要素が等しければその結果を返す

* `<=>`メソッド：先頭から比較し、同じであれば`0`、左辺が大きければ`1`、右辺が大きければ`-1`を返す

```ruby
>> [1, 2, 3] == [1, 3, 5]
=> false
>> [1, 2, 3] <=> [1, 3, 5]
=> -1
```

***

## 5-7-9.配列の要素での繰り返し

* `each`メソッド：ブロックに各要素が渡る

* `each_index`メソッド：配列のインデックスが渡る

* `reverse_each`メソッド：要素の逆順に繰り返す

* `cycle`メソッド：配列の要素を順に繰り返し、末尾まで来たらまた先頭に戻って繰り返し続ける

```ruby
# eachメソッド
>> [1, 3, 5, 7, 9].each{|n| puts n * 2}
2
6
10
14
18
=> [1, 3, 5, 7, 9]

# each_indexメソッド
>> [1, 3, 5, 7, 9].each_index{|n| puts n * 2}
0
2
4
6
8
=> [1, 3, 5, 7, 9]

# reverse_eachメソッド
>> [1, 3, 5, 7, 9].reverse_each{|n| puts n * 2}
18
14
10
6
2
=> [1, 3, 5, 7, 9]

# cycleメソッド
>> [1, 2, 3].cycle{|n| puts n }
1
2
3
1
2
3
# ...(省略)
```

***

## 5-7-10.配列の要素を連結する

* `join`、`*`メソッド：配列の要素を指定された区切り文字で連結した文字列を返す

```ruby
>> [1, 2, 3].join(",")
=> "1,2,3"
```

***

## 5-7-11.配列の長さを求める

* `length`、`size`メソッド：配列の長さを求める。空の場合は0を返す

* `empty?`メソッド：配列が空の場合に真を返す

```ruby
>> [1, 2, 3].length
=> 3
>> [].length
=> 0
>> [].empty?
=> true
```

***

## 5-7-12.配列をソートする

* `sort`メソッド：配列をソートする。要素同士の比較は、`<=>`メソッドが使用される。

* ブロックが与えられた場合、2つの要素が渡され、その評価結果に応じてソートされる。

  * 正の整数：1つ目の要素が大きい

  * 0：同じ

  * 負の整数：2つ目の要素が大きい


```ruby
>> a = [1, 3, 5, 2, 4, 6]
=> [1, 3, 5, 2, 4, 6]
>> a.sort
=> [1, 2, 3, 4, 5, 6]
>> a
=> [1, 3, 5, 2, 4, 6]
>> a.sort!                 # 破壊的メソッド(自分自身をソート結果で書き換える)
=> [1, 2, 3, 4, 5, 6]
>> a
=> [1, 2, 3, 4, 5, 6]

# ブロックが与えられた場合
>> [1, 3, 5, 2, 4, 6].sort{|a, b| a <=> b}    # 0番目と1番目の数を比べて、1番目の数の方が大きい場合(負の整数・・・1番目の方が大きいとしてソート)
=> [1, 2, 3, 4, 5, 6]
>> [1, 3, 5, 2, 4, 6].sort{|a, b| b <=> a}    # 1番目と0番目の数を比べて、0番目の数の方が大きい場合(正の整数・・・0番目の方が大きいとしてソート)
=> [6, 5, 4, 3, 2, 1]
```

このブロックはわからないので、省略
2018/9/8

問題解決
2018/9/29

***

## 5-7-13.配列を変換する

### `!`が付いているものは、全て破壊的メソッド

* `uniq`メソッド：配列から重複した要素を取り除いた配列を返す

* `uniq!`メソッド：`uniq`メソッドと同じだが、取り除かれなかった場合に`nil`を返す

* `compact`メソッド：要素の`nil`を取り除いた配列を返す。

* `compact!`メソッド：`compact`メソッドと同じだが、取り除かれなかった場合に`nil`を返す

* `reverse`メソッド：配列の要素を逆順に並べ替えた配列を返す

* `flatten`メソッド：配列を再帰的に平滑化した配列を返す。引数が指定された場合は、その深さまで再帰的に平滑化する。

* `flatten!`メソッド：`flatten`メソッドと同じだが、平滑化されなかった場合には`nil`を返す

* `map`、`collect`メソッド：要素ごとにブロックを評価し、その結果で要素を書き換えた配列を返す

* `shuffle`メソッド：配列の要素をシャッフルして返す

```ruby
# uniqメソッド
>> [1, 1, 2, 3, 3].uniq
=> [1, 2, 3]

# compactメソッド
>> [1, nil, 2, nil, 3].compact
=> [1, 2, 3]

# reverseメソッド
>> [1, 2, 3, 4, 5].reverse
=> [5, 4, 3, 2, 1]

# flattenメソッド
>> [[[1, 2], 3], [[4, 5], 6]].flatten
=> [1, 2, 3, 4, 5, 6]
>> [[[1, 2], 3], [[4, 5], 6]].flatten(1)
=> [[1, 2], 3, [4, 5], 6]

# mapメソッド
>> [1, 2, 3, 4, 5].map{|n| n * 2}
=> [2, 4, 6, 8, 10]

# shuffleメソッド
>> [1, 2, 3, 4, 5].shuffle
=> [5, 1, 2, 3, 4]
```

***

## 5-7-14.配列を組み合わせて生成する

* `product`メソッド：自身と与えられた配列から1つずつ要素を取って組み合わせた配列を作り、その全ての組み合わせを要素とする配列を返す

* `zip`メソッド：自身と与えられた配列から1つずつ要素を取って配列を作り、それを要素とする配列を返す。`product`メソッドとは異なり、
  組み合わせは前から順に同じインデックスのもののみとなる。ブロックが与えられた場合は、自分自身と引数に指定された配列を順にブロックに渡す。

* `*`メソッド：与えられた数値の分だけ、繰り返した配列を返す

```ruby
# productメソッド
>> [1, 2].product(["a", "b", "c"])
=> [[1, "a"], [1, "b"], [1, "c"], [2, "a"], [2, "b"], [2, "c"]]

# zipメソッド
>> [1, 2].zip(["a", "b"])
=> [[1, "a"], [2, "b"]]
>> [1, 2].zip(["a", "b"], ["x", "y"])
=> [[1, "a", "x"], [2, "b", "y"]]

# zipメソッドの便利な手法
ary1 = [1,2,3,4,5]
ary2 = [10,20,30,40,50]
ary3 = [100,200,300,400,500]

result = []
ary1.zip(ary2,ary3) do |a,b,c|
  result << a + b + c
end
p result
[111, 222, 333, 444, 555]

# *メソッド
>> [1, 2] * 4
=> [1, 2, 1, 2, 1, 2, 1, 2]
```


※Silverで間違えている

* `Array#zip`は、自身と引数に渡した配列の各要素からなる配列を生成して返す。
  ブロックを渡した場合は、各要素を順番に返す

* `Array#transpose`は、2次元配列の行と列を入れ替えるメソッド

```ruby
# 1問目
>> a.zip(b).each{|x| p x}
["a", 1]
["b", 2]
["c", 3]
=> [["a", 1], ["b", 2], ["c", 3]]

# 2問目
>> a.zip(b){|x| p x}
["a", 1]
["b", 2]
["c", 3]
=> nil

# 3問目
>> [a, b].zip{|x, y| p [x, y]}
["a", "b"]
[1, 2]
=> nil

# 4問目
>> [a, b].transpose.each{|x, y| p [x, y]}
["a", 1]
["b", 2]
["c", 3]
=> [["a", 1], ["b", 2], ["c", 3]]
```

***

## 5-7-15.配列をパックする

* `pack`メソッド：自身を指定されたテンプレートに従ってパックする。

```ruby
>> ["ルビー"].pack('m')
=> "44Or44OT44O8\n"
```

***

# 5-8.`Hash`クラス

ハッシュは連想配列とも呼ばれ、配列でのインデックスにあたるキーとして、数値以外のRubyオブジェクトを利用可能

Rubyでは、ハッシュはHashクラスのオブジェクトとして生成される

## 5-8-1.ハッシュの生成

* ハッシュは、ハッシュ式と呼ばれる記法、`[]`、`Hash.new`、`{}`、`Hash({})`を使用して生成できる

* ハッシュ式では、 **キー** と要素である **値** とを`=>`を使った組み合わせで表現する

```ruby
# ハッシュ式
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.class
=> Hash

# []メソッド
>> Hash["apple", "fruit", "coffee", "drink"]   # キーと値を、順番にカンマ`,`で列挙する
=> {"apple"=>"fruit", "coffee"=>"drink"}

# newメソッド
>> a = Hash.new
=> {}
>> a["apple"]
=> nil
>> a = Hash.new("NONE")   # キーが存在しない場合の初期値を設定できる
=> {}
>> a["apple"]
=> "NONE"

# newメソッド(ブロック)
>> a = Hash.new{|hash, key| hash[key] = nil}      # 初期値の設定
=> {}
>> a["apple"]
=> nil
>> a = Hash.new{|hash, key| hash[key] = "NONE"}
=> {}
>> a["apple"]
=> "NONE"

# {}メソッド
>> {}
=> {}

# Hash{()}メソッド
>> Hash({})
=> {}
```

* 初期値とブロックの参照は、

  * 初期値：`default`メソッド

  * ブロック：`default_proc`メソッド

  で参照可能

* 初期値は、あとで`default=`メソッドで指定可能

```ruby
>> a = Hash.new("NONE")
=> {}
>> a.default
=> "NONE"
>> a["apple"]
=> "NONE"
>> a.default = "Not exists"
=> "Not exists"
>> a["apple"]
=> "Not exists"
```

***

## 5-8-2.ハッシュの **キー** や **値** を取得する

* `[]`メソッド：指定されたキーに対応する値を返す

* `keys`、`values`メソッド：ハッシュの全てのキーと値の配列を生成する

* `values_at`メソッド：指定されたキーに対応する値を、配列で返す

* `fetch`メソッド：与えられたキーに対する **値** を返す。
  キーが存在しない場合には、2番目の引数が与えられた場合にはその値を、ブロックが与えられていた場合はそのブロックを評価した結果を返す。
  2番目の引数がない場合は、`IndexError`となる

* `select`メソッド：キーと値の組み合わせについてブロックを評価して、結果が真となる組み合わせのみを含むハッシュを返す

* `find_all`メソッド：キーと値の組み合わせについてブロックを評価するが、返り値はキーと値の配列。`select`と機能はほとんど変わらない。

```ruby
# []メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a["apple"]
=> "fruit"

# keys、valuesメソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.keys
=> ["apple", "coffee"]
>> a.values
=> ["fruit", "drink"]

# values_atメソッド
>> a = {1 => "a", 2 => "b", 3 => "c", 4 => "d"}
=> {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
>> a.values_at(1, 3)
=> ["a", "c"]

# fetchメソッド
>> a = {1 => "a", 2 => "b", 3 => "c", 4 => "d"}
=> {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
>> a.fetch(5, "NONE")
=> "NONE"
>> a.fetch(5){|key| % 2 == 0}
=> false

# selectメソッド
>> a = {1 => "a", 2 => "b", 3 => "c", 4 => "d"}
=> {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
>> a.select{|key, value| key % 2 == 0}
=> {2=>"b", 4=>"d"}
>> a.find_all{|key, value| key % 2 == 0}
=> [[2, "b"], [4, "d"]]
```

***

## 5-8-3.ハッシュを変更する

### `[]=`メソッド

配列の場合と同様に、指定されたキーに対応する値を変更する。キーが存在しない場合には、そのキーと値を登録する。

```ruby
# 破壊的メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a["apple"] = "red"
=> "red"
>> a
=> {"apple"=>"red", "coffee"=>"drink"}
>> a["orange"] = "orange"
=> "orange"
>> a
=> {"apple"=>"red", "coffee"=>"drink", "orange"=>"orange"}
```

### `delete`メソッド

指定されたキーに対応する値を取り除く。キーが存在していれば対応する値を、そうでなければ`nil`を返す。ブロックが与えられた場合には、キーが存在しない場合にブロックの評価結果を返す

```ruby
# 破壊的メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.delete("apple")
=> "fruit"
>> a
=> {"coffee"=>"drink"}
```

### `reject`メソッド

ブロックを評価した結果が真になる値を取り除いたハッシュを生成して返す。元のオブジェクトは変更されない。
→`reject!`とは異なるメソッド(1要素ずつブロックを要素に渡し、その評価結果が真になった要素を全て取り除いた自分自身を返す)

```ruby
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.reject{|key, value| value == "drink"}         # 値が"drink"であるものを取り除く
=> {"apple"=>"fruit"}
>> a
=> {"apple"=>"fruit", "coffee"=>"drink"}
```

### `delete_if`、`reject!`メソッド

ブロックを評価した結果が真になる値を取り除く。元のオブジェクトが変更される(破壊的メソッド)

```ruby
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.reject!{|key, value| value == "drink"}
=> {"apple"=>"fruit"}
>> a
=> {"apple"=>"fruit"}
```

### `replace`メソッド

引数で与えられたハッシュで自分自身を置き換える。

```ruby
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.object_id
=> 70364050765140
>> a.replace({"orange" => "fruit", "tea" => "drink"})
=> {"orange"=>"fruit", "tea"=>"drink"}
>> a.object_id
=> 70364050765140       # 同じオブジェクトID・・・自分自身の置き換え
```

### `shift`メソッド

ハッシュから先頭のキーと値の組み合わせを1つ取り除き、その組み合わせを配列として返す

```ruby
# 破壊的メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.shift
=> ["apple", "fruit"]
>> a
=> {"coffee"=>"drink"}
```

### `merge`メソッド

自分自身と引数で指定されたハッシュを統合した、新しいハッシュオブジェクトを返す。

デフォルト値は自分自身の設定が引き継がれる。

ブロックが与えられた場合は、キーと自分自身の値、指定されたハッシュの値が渡され、ブロックの評価結果が新しいハッシュの値となる

```ruby
>> a = {"apple" => "foods", "coffee" => "drink"}
=> {"apple"=>"foods", "coffee"=>"drink"}
>> a.merge({"orange" => "fruit", "tea" => "drink", "apple" => "fruit"})
=> {"apple"=>"fruit", "coffee"=>"drink", "orange"=>"fruit", "tea"=>"drink"}
>> a
=> {"apple"=>"foods", "coffee"=>"drink"}
>> a.merge({"orange" => "fruit", "tea" => "drink"}){|key, self_val, other_val| self_val}
=> {"apple"=>"foods", "coffee"=>"drink", "orange"=>"fruit", "tea"=>"drink"}
```

### `merge!`、`update`メソッド

自分自身と引数で指定されたハッシュを統合する。

`merge`メソッドとは異なり、元のオブジェクトが変更される。(破壊的メソッド)

```ruby
>> a = {"apple" => "foods", "coffee" => "drink"}
=> {"apple"=>"foods", "coffee"=>"drink"}
>> a.merge!({"orange" => "fruit", "tea" => "drink", "apple" => "fruit"})
=> {"apple"=>"fruit", "coffee"=>"drink", "orange"=>"fruit", "tea"=>"drink"}
>> a
=> {"apple"=>"fruit", "coffee"=>"drink", "orange"=>"fruit", "tea"=>"drink"}
```

### `invert`メソッド

キーと値を逆にしたハッシュを返す。

ただし、値が重複している場合には、結果は不定になる

```ruby
>> a = {"apple" => "foods", "coffee" => "drink"}
=> {"apple"=>"foods", "coffee"=>"drink"}
>> a.invert
=> {"foods"=>"apple", "drink"=>"coffee"}
>> {"orange" => "fruit", "coffee" => "drink", "apple" => "fruit", "tea" => "drink"}.invert
=> {"fruit"=>"apple", "drink"=>"tea"}
```

※Silverで間違えている

* `Hash#invert`は **キー** と **値** を入れ替えます。
  入れ替えの結果キーが重複した場合は、後に定義された方が優先されます。

* `Hash#revert`メソッドは存在しない。

```ruby
>> h = {a: 100, b: 100}
=> {:a=>100, :b=>100}
>> puts h.invert
{100=>:b}
=> nil
```

### `clear`メソッド

ハッシュを空にする

```ruby
>> a = {"apple" => "foods", "coffee" => "drink"}
=> {"apple"=>"foods", "coffee"=>"drink"}
>> a.clear
=> {}
```

***

## 5-8-4.ハッシュを調べる

* `length`、`size`メソッド：ハッシュの組み合わせの数を返す(間違えそうだったので、注意！！)

* `empty?`メソッド：ハッシュが空かどうかを調べる

* `has_key?`、`include?`、`key?`、`member?`メソッド：ハッシュに **キー** が存在する場合に真を返す(Silverでよく間違える！！)

* `has_value?`、`valid?`メソッド：ハッシュに **値** が存在する場合に真を返す

```ruby
# size、empty?メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.size
=> 2
>> a.empty?
=> false

# key?メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.key?("apple")
=> true
>> a.key?("orange")
=> false

# value?メソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.value?("fruit")
=> true
>> a.key?("foods")
=> false
```

***

## 5-8-5.ハッシュを使った繰り返し

* `each`、`each_pair`メソッド：与えられたブロックに **キー** と **値** を渡して評価する

* `each_key`、`each_value`メソッド： **キー** と **値** を与えられたブロックに渡して評価する

```ruby
# eachメソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.each{|key, value| puts "#{key} => #{value}\n"}
apple => fruit
coffee => drink
=> {"apple"=>"fruit", "coffee"=>"drink"}

# each_key、each_valueメソッド
>> a = {"apple" => "fruit", "coffee" => "drink"}
=> {"apple"=>"fruit", "coffee"=>"drink"}
>> a.each_key{|key| puts "key: #{key}\n"}
key: apple
key: coffee
=> {"apple"=>"fruit", "coffee"=>"drink"}
```

***

## 5-8-6.ハッシュをソートする

* `sort`メソッド：ハッシュとキーと値の組み合わせの配列に変換し、それをソートした結果を返す。

* ハッシュ自身はソートされない。ブロックが与えられた場合には、キーと値の組み合わせの配列が渡される。

```ruby
>> a = {4 => "a", 3 => "b", 2 => "c", 1 => "d"}
=> {4=>"a", 3=>"b", 2=>"c", 1=>"d"}
>> a.sort
=> [[1, "d"], [2, "c"], [3, "b"], [4, "a"]]
>> a.sort{|a, b| a[1] <=> b[1]}              # 0番目("a")と1番目("b")を比較して、1番目の方が大きいので、評価は-1・・・1番目の方からソート
=> [[4, "a"], [3, "b"], [2, "c"], [1, "d"]]
```

***

## 5-8-7.ハッシュを変換する

* `to_a`：ハッシュを配列に変換する。キーと値の組み合わせを配列の配列として生成する。二次元配列の場合に適用可能

```ruby
>> a = {4 => "a", 3 => "b", 2 => "c", 1 => "d"}
=> {4=>"a", 3=>"b", 2=>"c", 1=>"d"}
>> a.to_a
=> [[4, "a"], [3, "b"], [2, "c"], [1, "d"]]
```

***

# 5-9.`Symbol`クラス

コロン`:`で始まる文字列で表す

変更不可であり、また同じ表記であれば必ず同じオブジェクトIDであるため、必ず同値である。

## `Symbol`オブジェクト

```ruby
>> a = :foo
=> :foo
>> a.object_id
=> 1159388
>> b = :foo
=> :foo
>> b.object_id
=> 1159388      # 変数は異なるが、同じオブジェクトID
```

* Ruby内部では、メソッド名や変数名などの **名前** は整数値で管理されている。この整数をRubyのコード上で表現したものがSymbol

* 文字列そのものが必要でない場合に利用すると良い。例えば、ハッシュのキーなど、名前が重要な場合によく利用する。

***

## 5-9-1.定義済みの`Symbol`オブジェクトを取得する

* `Symbol.all_symbols`メソッド：定義済みのSymbolオブジェクトを取得できる

```ruby
>> :foo
=> :foo
>> Symbol.all_symbols
=> [:!, :"\"", :"#", :"$", :%, :&, :"'", #・・・省略
```

***

## 5-9-2.`Symbol`オブジェクトに対応する文字列を取得する

* `id2name`、`to_s`メソッド：`Symbol`オブジェクトに対応する文字列を取得する

```ruby
>> :foo.to_s
=> "foo"
>> :foo.id2name
=> "foo"
```
