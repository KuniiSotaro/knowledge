## 5-16.`Enumerable`モジュール

* `Array`、`Hash`クラスにインクルードされている

* 全てのメソッドが`each`メソッドを元に定義されているため、`each`メソッドが定義されているクラスであれば、そのクラスでも利用可能

#### `map`、`collect`メソッド

* 与えられたブロックを評価した結果の配列を返す

```ruby
>> [1, 2, 3, 4, 5].map{|i| i ** 2}
=> [1, 4, 9, 16, 25]
```

#### `each_with_index`メソッド

* 要素とそのインデックスをブロックに渡して繰り返す

```ruby
>> [:a, :b, :c, :d, :e].each_with_index{|v, i| puts "#{v} => #{i}"}
a => 0
b => 1
c => 2
d => 3
e => 4
=> [:a, :b, :c, :d, :e]
```

#### `inject`、`reduce`メソッド

* 自身のたたみこみ演算を行う(初期値と自身の要素を順に組み合わせて結果を返す)

* 引数は、たたみこみを行う際の初期値をとる

```ruby
>> [1, 2, 3, 4, 5].inject(0) {|result, v| result + v ** 2}  # 1から5までの数値の2乗の和を求める(1+4+9+16+25=55)
=> 55
```

#### `each_slice`、`each_cons`メソッド

* `each_slice`：要素を指定された数で区切ってブロックに渡す。要素数が指定された数で割きれない場合は、最後だけ渡される数が少なくなる

* `each_cons`：先頭から要素を1つずつ選び、さらに余分に指定された数に合うように要素を選び、それらをブロックに渡していく

```ruby
# each_consメソッド
>> (1..10).each_cons(3) {|items| p items}
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
=> nil

# each_sliceメソッド
>> (1..10).each_slice(3) {|items| p items}
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]
=> nil
```

#### `reverse_each`メソッド

* `each`メソッドとは逆順にブロックに要素を渡して繰り返す

```ruby
>> [1, 2, 3, 4, 5].reverse_each {|i| puts i}
5
4
3
2
1
=> [1, 2, 3, 4, 5]
```

#### `all?`、`any?`、`none?`、`one?`、`member?`、`include?`メソッド

* `all?`：全ての要素が真であれば`true`を返す

* `any?`：真である要素が1つでもあれば`true`を返す

* `none?`：全ての要素が偽であれば`true`を返す

* `one?`：1つの要素だけが真であれば`true`を返す

* `member?`、`include?`：指定された値と`==`メソッドが`true`となる要素がある場合に`true`を返す

```ruby
>> [1, nil, 3].all?
=> false
>> [1, nil, 3].any?
=> true
>> [].all?
=> true
>> [].any?
=> false

# include?メソッド
>> [1, 2, 3, 4, 5].include?(3)
=> true
```

#### `find`、`find_index`、`select`などのメソッド

* `find`、`detect`：ブロックを評価して最初に真となる要素を返す

* `find_index`：要素の代わりにインデックスを返す

* `find_all`、`select`：ブロックの評価が真となる全ての要素を返す

* `reject`：偽になった全ての要素を返す

* `grep`：指定したパターンとマッチする(`==`メソッドが`true`となる)要素を全て含んだ配列を返す

```ruby
>> [1, 2, 3, 4, 5].find {|i| i % 2 == 0}
=> 2
>> [1, 2, 3, 4, 5].find_index {|i| i % 2 == 0}
=> 1
>> [1, 2, 3, 4, 5].select {|i| i % 2 == 0}
=> [2, 4]
```

#### `sort`、`sort_by`メソッド

* `sort`：要素を`<=>`メソッドで比較して昇順にソートした配列を、新たに生成して返す。ブロックをとる場合は、ブロックの評価結果を元にソートする

* `sort_by`：ブロックの評価結果を`<=>`メソッドで比較して昇順にソートした配列を使って、元の配列をソートした新しい配列を生成して返す

```ruby
>> ["aaa", "b", "cc"].sort{|a, b| a.length <=> b.length}
=> ["b", "cc", "aaa"]
>> ["aaa", "b", "cc"].sort_by{|a| a.length}
=> ["b", "cc", "aaa"]
```

#### `max`、`min`メソッド

* それぞれ要素の最大値と最小値を返す

* `<=>`メソッドで比較するため、全ての要素がそれに対応する必要がある

* ブロックを渡すと、ブロックの評価結果を元に大小判定を行う

* `max_by`、`min_by`：ブロックの評価結果が最大であった要素を返す

```ruby
>> (1..10).map{|v| v % 5 + v}
=> [2, 4, 6, 8, 5, 7, 9, 11, 13, 10]
>> (1..10).max{|a, b| (a % 5 + a) <=> (b % 5 + b)}
=> 9
>> (1..10).max_by{|v| v % 5 + v}
=> 9
```

#### `count`メソッド

* 要素数を返す

```ruby
>> [1, 2, 3, 4, 5].count
=> 5
```

#### `cycle`メソッド

* 要素を先頭から順に取り出し、末尾まで到達したら再度先頭に戻り、それを繰り返す

```ruby
>> [:a, :b, :c].cycle{|v| p v}
:a
:b
:c
:a
# 省略
```

#### `group_by`メソッド

* ブロックの評価結果をキーとし、同じキーを持つ要素を配列としたハッシュを返す

```ruby
>> (1..10).group_by{|v| v % 2}
=> {1=>[1, 3, 5, 7, 9], 0=>[2, 4, 6, 8, 10]}
```

#### `zip`メソッド

* 自身と引数に指定した配列から、1つずつ要素を取り出して配列を作り、それを要素とする配列を返す

```ruby
>> [:a, :b, :c].zip([1, 2, 3], ["a", "b", "c"])
=> [[:a, 1, "a"], [:b, 2, "b"], [:c, 3, "c"]]
```

#### `first`、`take`メソッド

* `take`：先頭から指定した数の要素を配列として返す

* `first`：`take`メソッドと同じだが、数を指定しない場合に先頭の要素のみを返す

```ruby
>> [:a, :b, :c].take(2)
=> [:a, :b]
>> [:a, :b, :c].first
=> :a
```

#### `take_while`、`drop`メソッド

* `take_while`：先頭からブロックを評価し、最初に偽になった要素の直前までを返す

* `drop`：`take`メソッドとは逆に、先頭から指定した数の要素を取り除いた残りの要素を配列として返す

```ruby
# take_whileメソッド
>> [:a, :b, :c, :d, :e].take_while { |e| e != :d }
=> [:a, :b, :c]

# dropメソッド
>> [:a, :b, :c, :d, :e].drop(3)
=> [:d, :e]
```

#### `drop_while`メソッド

* 先頭からブロックを評価し、最初に偽になった要素の手前までを切り捨て、残りの要素を配列として返す

```ruby
>> [:a, :b, :c, :d, :e].drop_while { |e| e != :c}
=> [:c, :d, :e]
```

#### `select`、`reject`メソッド

* `select`：各要素に対してブロックの評価結果が真であった要素を含む配列を返す

* `reject`：ブロックの評価結果が偽であった要素を含む配列を返す

```ruby
>> [1, 2, 3, 4, 5].select { |e| e % 2 == 0 }
=> [2, 4]
>> [1, 2, 3, 4, 5].reject { |e| e % 2 == 0 }
=> [1, 3, 5]
```

#### `lazy`メソッド

* `map`、`select`メソッドなどのメソッドが、遅延評価を行うように再定義される

* 遅延評価になるとそれぞれのメソッドが配列でなく`Enumerator::Lazy`を返すようになるため、メソッドを評価するタイミングを文字通り遅らせることができる

```ruby
>> a = [1, 2, 3, 4, 5].lazy.select { |e| e % 2 == 0 }
=> #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>
>> b = a.map { |e| e * 2}
=> #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>:map>
>> c = a.take(3)
=> #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: [1, 2, 3, 4, 5]>:select>:take(3)>
>> c.to_a  # ここで評価される
=> [2, 4]
```

***

## 5-17.`Comparable`モジュール

* インクルードしたクラスで比較演算子である`<=>`メソッドを元にオブジェクト同士での比較ができるようになる

* インクルードしたクラスで利用できるインスタンスメソッドは、

  * `<`：負の整数で`true`

  * `<=`：負の整数か0で`true`

  * `==`：0で`true`

  * `>`：正の整数で`true`

  * `>=`：正の整数か0で`true`

  * `between?`：引数`min`と`max`の間にあれば`true`


#### Sampleクラス

* 通常の大小関係と逆の挙動をするクラス

```ruby
>> class Sample
>>   def initialize(value)
>>     @value = value
>>   end
>>
>>   def value
>>     @value
>>   end
>>
>>   def <=>(other)
>>     other.value <=> self.value
>>   end
>> end
=> :<=>
```

***
