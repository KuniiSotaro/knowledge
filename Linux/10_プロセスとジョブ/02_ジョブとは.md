02 ジョブとは
============

* 01で紹介した`プロセス`は、Linuxカーネルから見た処理の単位であった

  * これに対して、**シェルから見た処理の単位** を`ジョブ`と呼ぶ

  * シェルのコマンドラインに入力している1つの行が、1つの`ジョブ`に当たる

* コマンドが1つだけの場合には、`プロセス`と`ジョブ`は同じ単位となる

  * 一方、コマンドを`パイプ`で繋いだ場合には、プロセスはコマンドごとに生成されるのに対して、`ジョブ`はコマンドライン全体で1つとなる

  ![プロセスとジョブの単位](./images/プロセスとジョブの単位.png)

* `プロセス`は、システム全体で一意のプロセスIDを持つが、`ジョブ`はシェルごとにジョブ番号を持つ

  * そのため、複数のターミナルエミュレータを起動して2つ以上のシェルを同時に使っている場合、ジョブ番号は重複する

  ![ジョブはシェルごとの処理単位](./images/ジョブはシェルごとの処理単位.png)

* シェルの機能を使うと、`ジョブ`を一時停止させたり、バックグラウンドで実行させるといった、ジョブ制御が可能になる

  * このジョブ制御機能をうまく使いこなせば、様々な作業を並行して効率良く実行できる

* 以下、「bashのmanページを読みながら、エディタで`/.bashrc`ファイルを編集する」という作業とする



### コマンドを一時停止する

* `man`コマンドでbashのマニュアルを表示する

```bash
$ man bash
```

* ここで表示されているマニュアル閲覧中に、`~/.bashrc`を編集したくなったとする

  * この際に、`q`を入力して`man`を終了してしまうと、改めて`man bash`を打ち込んで、先ほどまで読み進めたページまで移動する必要がある

* `Ctrl + z`：「停止」と表示され、シェルにコマンドできる状態になる(プロンプト`$`が表示される)

  * ジョブが停止状態に移行している

  * 一時的に停止しているだけで、ジョブは残っているため、また後で再開することができる

  ```bash
  [1]+  Stopped                 man bash
  ```

* `man bash`のジョブを停止したまま、次にエディタを起動して`~/.bashrc`を編集する

  ```bash
  $ vim ~/.bashrc
  ```

* `~/.bashrc`は編集中なので、Vimは終了させずに、`Ctrl + z`を押して停止状態とする

  ```bash
  [2]+  Stopped                 vim ~/.bashrc
  ```

* `jobs`コマンド：ジョブの一覧を確認する

  * 以下の例では、`man bash`のジョブ番号は1、`vim ~/.bashrc`のジョブ番号は2で、どちらも停止状態


  ```bash
  $ jobs
  [1]-  Stopped                 man bash
  [2]+  Stopped                 vim ~/.bashrc
  ```

  * `-l`オプション：ジョブ番号だけでなく、プロセスIDも表示する

  ```bash
  $ jobs -l
  [1]- 15548 Suspended: 18           man bash
  [2]+ 15565 Suspended: 18           vim ~/.bashrc
  ```



### fgコマンド - ジョブをフォアグランドにする

* `フォアグラウンド`：ジョブを停止状態からユーザが対話的に操作できる元の状態に戻すこと

* `fg`コマンド：ジョブをフォアグランドにする

  * 今回は、`man bash`のジョブを実行する

  ```bash
  $ fg %1
  ```

  * 上のようにコマンドを打ち込むと、先ほど表示されていたbashのmanページが画面に表示され、キーボードで操作できるようになる

  * スクロール位置などは停止状態にする直前の状態が復元できている

  * 複数のコマンドを実行する際には、こうしてジョブを停止状態として切り替えていくことで、効率的に作業が行える


* `fg`コマンドでジョブ番号を省略すると、カレントジョブ(`jobs`コマンドで`+`が表示されているジョブ)がフォアグラウンドになる

  * 停止状態のジョブが1つだけの時は、それが必ずカレントジョブとなる



### bgコマンド - ジョブをバックグラウンドにする

* `Ctrl + z`でジョブを停止すると、そのジョブは動作を止めてしまう

  * 以下の例では、`cp`コマンドでファイルをコピー中に押すと、コピー処理は停止してしまい、いつまでたっても完了しない

  ```bash
  $ cp file1 file2
  ^p
  [1]+   Stopped                 cp file1 file2
  ```

* `バックグラウンド`：ユーザが対話的に操作できないジョブの状態

  * 処理を続行したままシェルへと戻ってくるようにコマンドを実行できる

* `bg`コマンド：ジョブをバックグラウンドにする

  * ジョブ番号を省略すると、カレントジョブが対象となる

  ```bash
  $ bg %1
  [1]+   Stopped                 cp file1 file2 &
  $
  ```

  * 上の例では、`cp`コマンドによるファイルコピーのジョブをバックグラウンドにした

    * プロンプトが戻ってきているので、自由に別のコマンドを入力して作業を行うことができる

    * その間にも **バックグラウンドジョブは動作を続行している** ため、ファイルはコピーされている

    * このように、長い時間かかるコマンドをバックグラウンド処理させることで、コマンドの終了時間までの待ち時間を無駄にしなくて済む

* バックグラウンドのジョブも、`jobs`コマンドで状態を確認することができる

  * `Running`は、ジョブが実行中で、コピー処理が行われていることを意味する

  * 「`&`」という記号は、ジョブがバックグラウンドの状態であることを意味する

  ```bash
  $ jobs
  [1]+  Running                 cp file1 file2 &
  ```

* バックグラウンドのジョブが終了すると、次のようなメッセージが表示される

  * これで、ジョブの処理が完了したことがわかる

  ```bash
  [1]+  finished                 cp file1 file2 &
  ```

* はじめからジョブをバックグラウンドで実行したい場合は、コマンドラインの末尾に`&`を追加する

  * このようにすることで、いちいち`Ctrl + z`で停止してから`bg`コマンドでバックグラウンドにする、という操作が不要になる

  ```bash
  $ cp file1 file2 &
  [1] 15717
  ```



### ジョブの状態遷移

| 状態             | 内容                                                 |
| ---------------- | ---------------------------------------------------- |
| フォアグラウンド | ユーザが対話的に操作しながら処理が実行されている状態 |
| バックグラウンド | ユーザが対話的に操作せずに処理が実行されている状態   |
| 停止             | 処理を一時的に中断している状態                       |

* これらのジョブの状態は、次のように`Ctrl + z`、`fg`コマンド、`bg`コマンドで遷移させることができる

![ジョブの停止とフォアグラウンド](./images/ジョブの停止とフォアグラウンド.png)

* なお、ジョブの操作とコマンドである`jobs`、`fg`、`bg`は全てのシェルの組み込みコマンド

  ```bash
  $ type jobs fg bg
  jobs is a shell builtin
  fg is a shell builtin
  bg is a shell builtin
  ```

  * プロセスはLinuxカーネルから見た処理単位であり、ジョブはシェルごとの処理単位である



| 版 |  年/月/日 |
|----|----------|
|初版|2019/03/03|
