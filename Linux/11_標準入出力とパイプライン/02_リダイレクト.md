02 リダイレクト
=============

* 標準入出力先を変更する機能のことを、`リダイレクト`と呼ぶ

* 入力・出力ともにリダイレクトすることが可能



## 標準入力のリダイレクト

* `cat`コマンドの引数にファイルを指定しないと、キーボードからの入力を待つようになる

  ```bash
  $ cat
  Hello
  Hello    # Ctrl + dを入力
  $        # プロンプトに戻る
  ```

  * これは、`cat`コマンドが「標準入力の内容を入力として読み込んで、それを標準出力にそのまま出力する」という働きをするコマンド

  * 標準出力は通常はキーボードであるため、今はキーボードの入力がそのまま表示された

* `入力リダイレクト`：キーボードの代わりにファイルを標準入力に繋ぐこと

  * 入力リダイレクトは`<`を使う

  * 次の例では、標準入力が繋がっている先を、キーボードから`/etc/crontab`ファイルに変更している

  * これにより、`/etc/crontab`ファイルの内容が、標準入力として`cat`コマンドに渡される

  * `cat`コマンドはこれを標準出力にそのまま出力する

  * 結果として、次のように`/etc/crontab`ファイルの内容が表示される

  ![crontabファイルを入力リダイレクトする](./images/crontabファイルを入力リダイレクトする.png)



### 入力リダイレクトとファイル指定

* `cat`コマンドは、コマンドライン引数にファイルを指定するとそのファイルの内容を表示するため、入力リダイレクトで書いてもファイル指定で書いても同じ動作となる

  ```bash
  # 入力リダイレクトでの書き方
  cat < /etc/crontab

  # ファイル指定での書き方
  cat /etc/crontab
  ```

* しかし、これらの2つは得られる結果は同じだが、コマンド内部での動きはかなり異なる

  * 入力リダイレクト`<`を用いた方は、「標準入力をそのまま標準出力に表示する」という`cat`コマンド本来の動きをしている

  * 一方、ファイルに指定した方は、`cat`コマンドが利便性のために用意している「ファイル名が指定された場合はその内容を対象とする」という動作を利用している

* 今後Linuxで何かしらのコマンドを作る際には、他のコマンドと同様に「ファイルを指定」するよりも「標準入力から受け取る」仕組みでプログラムを書く

  * その方が、より汎用性が高く、他のプログラムとの連携もしやすくなる



## 標準出力へのリダイレクト

* 標準出力も、リダイレクト機能により変更できる

* よく使われるケースとしては、コマンドの実行結果を画面に表示するのではなく、**ファイルに保存したいとき**

* 標準出力をリダイレクトするには、`>`という記号を用いる

  * 次の例では、`ls`コマンドの実行結果を`list.txt`というファイルに保存している

  * コマンドの結果は、通常は標準出力へ出力するようになっているが、ファイルへ出力するように向きを変えている

  ![lsコマンドの結果をファイルに保存](./images/lsコマンドの結果をファイルに保存.png)

  * なお、リダイレクト先のファイルは自動的に作成されるので、事前に`touch`コマンドなどでファイルを作っておく必要はない



## 標準エラー出力

* `標準エラー出力`は、**主にプログラムのエラーメッセージを出力するため** に使用される

  * 例)`ls`コマンドで存在しないファイルを指定した場合には、次のようなエラーメッセージが表示される

  * このエラーメッセージは標準エラー出力に出力されている

  ```bash
  $ ls /xxxxx
  ls: /xxxxx: No such file or directory
  ```

  * 通常、標準エラー出力は標準出力と同じく、端末ディスプレイに繋がっている

  * そのため、このままでは表示されているメッセージが`標準出力`のものか`標準エラー出力`のものかを区別することはできない

  ![同じ端末ディスプレイに向かっている](./images/同じ端末ディスプレイに向かっている.png)

* しかし、標準出力をファイルにリダイレクトして、画面に表示させないようにすると違いがわかる

  * 例)標準出力を`list.txt`というファイルにリダイレクトする

    * コマンドの結果は`list.txt`に保存される

    * 端末ディスプレイには何も表示されないように思われる

  ```bash
  $ ls /xxx > list.txt
  ls: /xxx: No such file or directory
  ```

* 実際には、エラーメッセージが表示された

  * `標準出力`と`標準エラー出力`は、別々のチャネルになっている

  ![標準エラー出力のみが表示される](./images/標準エラー出力のみが表示される.png)

* `標準出力`はファイルにリダイレクトしたが、`標準エラー出力`は変更していないので、エラーメッセージはそのまま画面に表示される

  * この仕組みのおかげで、標準出力をファイルにリダイレクトした場合でも、エラーメッセージは画面に表示されるため、見逃さずに済む

* なお、`標準エラー出力`もファイルにリダイレクトすることができる

  * 標準エラー出力のリダイレクトは、`2>`という記号を使う

  * 例)標準エラー出力の出力先を`error.txt`というファイルにリダイレクトしている

    * コマンド実行時には画面にも何も表示されず、エラーメッセージがファイル`error.txt`に出力されていることがわかる

  ```bash
  $ ls /xxx 2> error.txt
  $ cat error.txt
  ls: /xxx: No such file or directory
  ```

* リダイレクトを同時に指定することで、`標準出力`と`標準エラー出力`をそれぞれ別のファイルにリダイレクトすることもできる

  * この場合、画面には何も表示されない

  * `ls`コマンドの実行結果は`list.txt`に、エラーメッセージは`error.txt`に出力されている

  ```bash
  $ ls /xxxx list.txt 2> error.txt
  ```



## 標準出力と標準エラー出力をまとめる

* `標準出力`と`標準エラー出力`の両方を、1つのファイルにまとめてリダイレクトする場合

  * 標準出力をリダイレクトした後ろに、`2>&1`と書く

  ```bash
  $ ls /xxx > result.txt 2>&1
  $ cat result.txt
  ls: /xxx: No such file or directory
  ```

  * 意味としては、

    * まず、`>`を用いて`標準出力`を`result.txt`というファイルにリダイレクトする

    * 次に、`標準エラー出力`を、`&1`と同じものへリダイレクトしている

    * ここで、`&1`は標準出力を表している

| 入出力チャネル | 数値 |
| -------------- | ---- |
| 標準入力       | 0    |
| 標準出力       | 1    |
| 標準エラー出力 | 2    |

* 上の表のように、Linux内部では **標準入出力が数値として管理** されている

  * 先ほどの例では、`標準エラー出力(2)`を、`標準出力(1)`と同じファイルへ`2>&1`と書いてリダイレクトを指定した

* このように`標準出力`と`標準エラー出力`をまとめてリダイレクトする手法は、コマンドの結果とエラーメッセージを合わせて1つのログファイルとして置きたい場合によく使われる



## リダイレクトによる上書き

* `>`で標準出力をリダイレクトする際に、指定したファイル名と同一のファイルが存在する場合は、**上書きされて** 元のファイルが失われる

  ```bash
  $ echo 123 > number.txt
  $ cat number.txt
  123
  $ echo 456 > number.txt
  $ cat number.txt
  456
  ```

* これを防ぐには、`>`の代わりに`>>`と書くことで、上書きではなく **ファイル末尾に追記** する形となる

  ```bash
  $ echo 789 >> number.txt
  $ cat number.txt
  456
  789
  ```

  * 新規ファイルに対して`>>`を使っても問題ないので、上書きしてしまう心配がある場合は、常に`>>`を使う

* 別の方法として、シェルのオプションで`noclobber`という値を`set`コマンドで設定すると、リダイレクトで上書きしてしまうときにエラーとなるように設定できる

  ```bash
  $ set -o noclobber
  $ ls -l > list.txt
  -bash: list.txt: cannot overwrite existing file
  ```

* リダイレクトについて、ここまでに出てきた記号をまとめる

| 記号          | 内容                                           |
| ------------- | ---------------------------------------------- |
| `< FILE`      | 標準入力をFILEに変更する                       |
| `> FILE`      | 標準出力をFILEに変更する                       |
| `>> FILE`     | 標準出力の出力をFILEの末尾に追記する           |
| `2> FILE`     | 標準エラー出力をFILEに変更する                 |
| `2>> FILE`    | 標準エラー出力の出力をFILEの末尾に追記する     |
| `> FILE 2>&1` | 標準出力と標準エラー出力を、共にFILEに変更する |



## /dev/null

* Linuxでは、リダイレクト先として`/dev/null`というファイルがよく使われる

  * `ls`コマンドで確認する

  ```bash
  $ ls -l /dev/null
  crw-rw-rw-  1 root  wheel    3,   2  3 11 19:04 /dev/null
  ```

* `/dev/null`は、`スペシャルファイル`と呼ばれる特別なファイルで、次のような性質を持つ

  * 入力先として指定しても、何も内容を返さない

  * 出力先として指定しても、書き込んだデータはどこにも保存されずに消えて無くなる

* 例)標準入力を`/dev/null`にリダイレクトすると、入力が何もない状態になる

  * これは、コマンドのテストなど何かしらの理由で、入力を空っぽにしたいときに使われる

  ```bash
  $ cat < /dev/null
  $
  ```

* 標準出力を`/dev/null`にリダイレクトすると、何も表示されなくなる

  * この際には、標準エラー出力へのエラーメッセージだけが画面に表示される

  ```bash
  $ cat /etc/crontab > /dev/null
  $
  ```

  * これは次のように、コマンドの表示結果が大量にある場合などに、標準エラー出力に表示されるエラーメッセージだけを読みたいときに使われる

  ```bash
  $ ls / /xxx > /dev/null
  ls: /xxx: No such file or directory
  ```

  * もう一つの使い方として、標準エラー出力を`/dev/null`にリダイレクトすることもできる

  * こちらは、あらかじめわかっているエラーメッセージが表示されるときに、それらのエラーメッセージを非表示にして、コマンドの通常の出力結果を読むときに役立つ

  ```bash
  $ ls / /XXX 2> /dev/null
  /:
  etc
  # 省略
  ```

  * また、標準出力と標準エラー出力を両方とも`/dev/null`にリダイレクトすると、画面には何も表示されなくなる

  ```bash
  $ ls / /XXX > /dev/null 2>&1
  $
  ```

  * これは、あらかじめわかっている不要なメッセージを非表示にするときや、コマンドの実行時間を測る際などにメッセージ出力を防ぐために使われる



| 版 |  年/月/日 |
|----|----------|
|初版|2019/03/11|
