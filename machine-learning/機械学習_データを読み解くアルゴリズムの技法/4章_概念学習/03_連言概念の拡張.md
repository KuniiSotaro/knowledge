03 連言概念の拡張
===============

## 1.ホーン節を用いた学習

* `ホーン節`：論理包含 $`A \rightarrow B`$ で、$`A`$ がリテラルの連言であり、$`B`$ が1つのリテラルであるもの

  * ブール特徴量に関心を絞り、特徴量に対して以下のように定義する

    * $`F = true`$ ： $`F`$

    * $`F = false`$ ： $`\lnot{F}`$

    * $`Gills = yes`$ ： $`Gills`$

    * $`Beak = yes`$ ： $`Beak`$

    * $`Teeth = many`$ ： $`ManyTeeth`$

    * $`Length = 3`$ ： $`Short`$

  * 正例で真にならないホーン節がある場合には、そのホーン節を削除する

    * $`A \rightarrow B`$ が真にならない： $`A`$ は真であるが、$`B`$ では真ではない

  * 負例で正になってしまう場合には、ホーン節を追加する

    * $`ManyTeeth \land Gills \land Short \land \lnot{Beak}`$ ： $`ManyTeeth \land Gills \land Short \rightarrow Beak`$

    * $`ManyTeeth \land Gills \land \lnot{Short} \land \lnot{Beak}`$ ：

      * $`ManyTeeth \land Gills \rightarrow Short`$

      * $`ManyTeeth \land Gills \rightarrow Beak`$



### ホーン節のアルゴリズム

* 基本的な方針：負例を排除するための節を概念に付け加えていく

  * 負例のリスト $`S`$ がなるべくコンパクトである

  * 一般性の高い節があれば、より少ないリテラルで`true`になっているものだけを探して付け加えていく

* `所属オラクル`($`Mb`$)：任意に与えられた例(インスタンス)が学習している概念に当てはまるかどうかを答える

  * 新しい負例 $`x`$ と、リストにある負例 $`s \in S`$ の連言を $`z`$ とする

  * $`z`$ のリテラルで`true`が $`s`$ よりも少なければ、今度は概念に当てはまるかどうかを`所属オラクル`でチェックする

* `同値オラクル`($`Eq`$)：目的としている概念を正しく表す式 $`f`$ と、現在の概念 $`h`$ が同値かチェックし、もし同値でなければ`反例`を返す機能

  * `反例`：

    * $`h`$ で真で、$`f`$ で偽(真でない)になるような偽陽性

    * $`h`$ で偽で、$`f`$ で真になるような偽陰性

**$`Horn(Mb,Eq)`$ ： $`Mb`$ と $`Eq`$ からホーン節からなる連言を学習する**

```
Input: 所属オラクルMbと同値オラクルEq
Output: ホーン節からなる連言hで目的の式fと同値なもの
1: h ← true                                     # ホーン節の連言、初期値は空
2: S ← 空集合                                    # 負例のリスト、初期値は空
3: while Eq(h)が反例xを返す do
4:  if xがhの少なくとも1つの節で真でない then        # xが偽陰性
5:    xが真でない節を削除してhを特殊化
6:  else                                        # xが偽陽性
7:    負例 $s \in S$ で、(1)$z = s \cap x$ がより少ないtrueをもち、かつ(2)MB(z)が負であるというsを探す
8:    もしそのようなsが見つかれば、Sのその中のsをzで置き換える。見つからなければ、xをSの最後に付け加える
9:    h ← true
10:   for 全ての $s \in S$ do
11:     p ← s で真になるリテラルの連言
12:     Q ← s で偽になるリテラルの集合
13:     for 全ての $q \in Q$ do h ← h \land (p → q)     # 左向きの←は代入
14:   end
15: end
16:end
17:return h
```



### ホーン節を用いた学習

**目的としている概念 $`f`$ の論理表現**

$`(ManyTeeth \land Short \to Beak) \land (ManyTeeth \land Gills \to Short)`$

* 正例：12個

  * 8個：`ManyTeeth`が`false`

  * 2個：`ManyTeeth`が`true`、`Gills`と`Short`は`false`

  * 2個：`ManyTeeth`、`Short`、`Beak`が`true`

* 負例：4個

  * $`n1: ManyTeeth \land Gills \land Short \land \lnot{Beak}`$

  * $`n2: ManyTeeth \land Gills \land \lnot{Short} \land Beak`$

  * $`n3: ManyTeeth \land Gills \land \lnot{Short} \land \lnot{Beak}`$

  * $`n4: ManyTeeth \land \lnot{Gills} \land Short \land \lnot{Beak}`$

**アルゴリズムに従って学習を進める**

1. 初期値 $`S`$ ：空のリストに設定、$`h`$ ：空の連言概念に設定

2. `同値オラクル`を呼び出す：$`h`$ は空なので、偽陽性の反例が返される(`n1`が返される)

  * $`S`$ のリストにはまだ負例が1つもないので、その`n1`を追加する

3. ステップ9〜13：概念 $`h`$ を更新する

  * ステップ11： $`p`$ は、$`ManyTeeth \land Gills \land Short`$ になる

  * ステップ12： $`Q`$ は、$`Beak`$ になる

4. $`h`$ は、ホーン節 $`(ManyTeeth \land Gills \land Short \to Beak)`$ となる

  * $`h`$ は、目的としている概念 $`f`$ に論理的に包含されている

  > $`f`$ の2つ目の節より、`ManyTeeth`と`Gills`が`true`であれば、`Short`も`true`であるが、そのとき $`f`$ の1つ目の節より、`Beak`も`true`

5. 負例がまだ排除しきれていないので、`同値オラクル`から返される次の反例を`n2`とする

6. $`S`$ に追加されている`n1`との連言(共通して`true`となっているリテラル)を考える

  * `n3`が得られるので、$`S`$ における`n1`を`n3`で置き換える

  * この $`S`$ を使って $`h`$ を再構築する

7. $`p`$ ：$`ManyTeeth \land Gills`$ 、$`Q`$ ：$`\{ Short, Beak \}`$

  * $`h`$ ：$`(ManyTeeth \land Gills \to Short) \land (ManyTeeth \land Gills \to Beak)`$

8. 最後に`同値オラクル`から`n4`の偽陽性の反例として返ってくると、$`S`$ の中の`n3`との積は、正例になる

  * `n4`は、$`S`$ に付け加えられる

  * $`h`$ が $`S`$ によって再構築され、$`h`$ には前の2つのホーン節(`n3`から得られたもの)に対して以下のものが追加される

    > $`(ManyTeeth \land Short \to Gills) \land (ManyTeeth \land Short \to Beak)`$

9. この付け加わった2つのホーン節のうち、最初の節は偽陽性の例によって削除されるので、最終的には以下のものになる

$`(ManyTeeth \land Gills \to Short) \land (ManyTeeth \land Gills \to Beak) \land (ManyTeeth \land Short \to Beak)`$



### まとめ

* このアルゴリズムは`能動学習`であり、所属オラクルを用いて訓練データを自ら生成している

* また、概念の論理表現を効率的に構築するために、リストに追加する負例をうまく選別している(連言など)



## 2.一階述語論理

* `一階述語論理`：論理結合子に加えて、述語と名辞を用いてより複雑な論理表現を扱ったもの

  * 例) $`BodyPart(Dolphin42, PairOf(Gill))`$ ：

    * `Dolphin42`：42番目のイルカ(名辞)

    * `PairOf(Gill)`：`PairOf`という関数記号と、`Gill`という2つの語からなる名辞

    * `BodyPart`：2つの名辞から`true`または`false`を返す二値述語

    > 42番目のイルカに一対のエラがなければ、`false`が返される

**述語と名辞を使うメリット**

* 個々の対象を扱うことができる(例：`Dolphin42`)

* さまざまな論理的な構造を明示的に記述しやすい

* 論理表現の中で変数を用いることができる

  * `Dolphin42`を変数`x`に置き換えた上で、$`\forall{x}:BodyPart(x, PairOf(Gill))`$ と考えると、「一対のエラをもつ全ての対象からなる集合」

  * $`\forall{x}:BodyPart(x, PairOf(Gill)) \to Fish(x)`$ ：一対のエラをもつ全ての対象は魚

    > `Fish(x)`：`x`が魚であれば`true`を返すとする

**一階述語論理における汎化**

* $`BodyPart(Dolphin42, PairOf(Gill))`$ の2つのリテラルの汎化を考えると、$`BodyPart(x, PairOf(y))`$ になる

  * `true`である場合：変数 $`y`$ で指定される一対の何かを体の一部としてもつ対象 $`x`$

  * `反単一化`：最小汎化を求める帰納的な操作のこと

    > 演繹的な場合、`単一化`と呼ぶ



### 単一化と反単一化

* 以下の２つの名辞を考える

  * $`BodyPart(x, PairOf(Gill))`$ ：一対のエラを体の一部としてもつ対象に対応

  * $`BodyPart(Dolphin42, PairOf(y))`$ ：42番目のイルカが体の一部として持っている一対の何かに対応

* `単一化`：$`BodyPart(Dolphin42, PairOf(Gill))`$、42番目のイルカが一対のエラを持つかどうか

* `反単一化`：$`BodyPart(x, PairOf(y))`$、変数`y`で指定される一対の何かを体の一部としてもつ対象`x`に対応



| 版   | 年/月/日   |
| ---- | ---------- |
| 初版 | 2019/06/15 |
