02 純粋オブジェクト指向言語としてのPython
====================================

* Pythonは、「オブジェクト指向」という概念を、シンプルで一貫性のあるルールで扱って、言語の仕様として取り入れている



## オブジェクトとアトリビュート

* Pythonのクラスでは、アトリビュートがとても重要な役割を果たす

* クラスを使ってプログラムを書く時は、クラスの定義をひな形として作られるインスタンスを作る

* アトリビュートは、インスタンスが持つ変数のようなもの

* インスタンスに持たせるデータは、アトリビュートに代入することで保存する

* インスタンスは個別に名前空間を持っていて、そこに自由にアトリビュートを登録して行くことができる

* クラスの機能を振り返ってモジュールについて考えてみると、Pythonのクラスの作りはモジュールとよく似ている

* アトリビュートはモジュール内に定義した変数に相当する

  * アトリビュートは「`ins.attr`」のようにドット`.`を使って参照する

  * モジュールの変数も同じくドット`.`を使って「`module.value`」のようにアクセスする

|   モジュール  |          クラス         |
|:------------|:-----------------------|
|モジュールの関数|メソッド                 |
|モジュールの変数|クラスのアトリビュート     |
|関数内で使う変数|インスタンスのアトリビュート|

* モジュールとクラスはそれぞれ異なった概念だが、モジュールに定義された関数とインスタンスのメソッドのように、似たような要素はモジュールでもクラスでも同じように扱える

* Pythonでは、異なった概念から性質の似た要素をうまく取り出して、似た要素は同じように利用できるようにしてある

  => Pythonが言語としてとてもシンプルなのは、このように一貫性のあるルールに乗っ取って言語をデザインしているため



## 魔法の関数「`dir()`」

* `dir()`：組み込み関数

  * Pythonのオブジェクトに登録されているアトリビュート名の一覧を取り出す

* Pythonでは、スコープ(名前空間)の実体は`ディクショナリ`

* 名前の`キー`に、リファレンスされたオブジェクトが`値`として登録されている

* 組み込み関数の`dir()`を使うと、スコープ(名前空間)に定義された名前(ディクショナリのキー)の一覧を得ることができる

* 例)`dir()`関数を使う

```python
>>> class Aklass:
...   def __init__(self):
...     self.spam = 1
...

>>> i = Aklass()
>>> dir(i)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__',
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
'spam'] # spamが含まれる

>>> i.egg = 1
>>> dir(i)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__',
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
'egg', 'spam'] # eggが追加された
```

* このように、`dir()`関数を使うと、アトリビュートのリストを得ることができる

* インスタンスに対してアトリビュートを追加し、再度`dir()`を呼び出した結果をみると、リストの項目が増えていることがわかる

* クラスに定義した初期化メソッドと同じ名前(`__init__`)が見える

  => メソッドもアトリビュート



## アトリビュートとしてのメソッド

* Pythonでは、「`spam.egg`」のように、インスタンスからドット`.`で区切って記述できるものは、全てアトリビュートとして扱われる

* インスタンスにくっついているのは、全てアトリビュートなので、メソッドも例外ではない

* 代入を行うことで、インスタンスに新しいアトリビュートを増やすことができる

  => 同様にして、メソッドを増やしたり入れ替えたりすることができる

  => アトリビュートを代入するのと同じように、インスタンスにメソッドを代入する

* Pythonでは、メソッドの名前に丸括弧`()`をつけるとメソッドが呼び出される

  * 丸括弧`()`をつけないと、変数のようにして扱える

  * 丸括弧`()`をつけないでメソッド名だけコードに書くと、`メソッドの代入`を行うことができる

* 例)メソッドをアトリビュートに代入する

```python
>>> class Atomklass:
...   def foo(self):
...     print("this is foo method!")
...

>>> i1 = Atomklass()
>>> i2 = Atomklass()

>>> i1.bar = i1.foo
>>> i1.bar()
this is foo method!

>>> i2.bar()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Atomklass' object has no attribute 'bar'
```

* 2つのインスタンスを作り、片方だけにアトリビュートの代入を行い、メソッドをコピーして追加

* 追加したインスタンスに新しいメソッドが増え、呼び出すことができるようになる

* インスタンスに存在しないメソッドを呼び出すと、「AttributeError」が発生する

  => メソッドもアトリビュートなので、このようなエラーが返ってくる



## 全てがオブジェクト

* オブジェクトは、「データと手続きをまとめて定義したもの」、「クラスという設計図を元に作られるもの」

* Pythonのオブジェクトの定義

  1. 型があり、アトリビュートを持つのがPythonのオブジェクト

  1. Pythonでは全てがオブジェクト

* 数値やリストは組み込み型のオブジェクト

  * クラスから作られるインスタンスも、オブジェクト

  * 関数、メソッド、モジュール、クラスもオブジェクト

* Python3からは、組み込み型がクラスとして実装されている

  => `int("20")`では、文字列の20を引数で与えて、int型のクラスのクラスインスタンスを作っている



## オブジェクトと型

* 「型」：数値型やリスト型のように、組み込み型オブジェクトの種類を表すために使われる

  => クラスも「型」になり得る

* 型には、相互に`親子関係`を構築するという特徴がある

  * `親子関係`：クラス継承と同義

  * 親の型：スーパークラス

  * 子の型：サブクラス

  * Pythonでは、全ての型は、`object`型を祖先とした親子関係を築いている

* `type()`：あるオブジェクトがどのような「型」に属しているのかを調べる

  * 組み込み型などには、決まった名前が付いている

```python
>>> type(1)
<class 'int'>        # 数値

>>> type("あいうえお")
<class 'str'>        # 文字列

>>> type(b"abcde")
<class 'bytes'>      # バイト型

>>> import sys
>>> type(sys)
<class 'module'>     # モジュール
```

* `isinstance()`：あるオブジェクトが指定した型と一致するかどうかを調べる

  * オブジェクトと型を引数として呼び出す

  * オブジェクトの型が引数の型と一致するか、または親の関係がある時にTrueを返す

```python
>>> isinstance(1, type(1))
True
>>> isinstance(1, str)
False
>>> isinstance("あいう", object)
True
```

* Pythonでは、全ての型が`object`型を継承している

  * `isinstance()`関数に`object`を与える型の情報として渡すと、常にTrueが返ってくる

* `issubclass()`という組み込み関数に2つの型を与えると、

  * ある型が、他の型のスーパークラスに該当するかどうかを調べる



## オブジェクトとアトリビュート

* 組み込み型やインスタンスなど、Pythonの全てのオブジェクトはアトリビュートを持っている

* 組み込み関数`dir()`を使うと、オブジェクトが持っているアトリビュート名のリストを得ることができる

![アトリビュートとオブジェクト](./images/アトリビュートとオブジェクト.png)

* アトリビュートにはオブジェクトが紐づいている

  * 「紐づき」：変数とオブジェクトを繋ぐ`リファレンス`

  * 組み込み型のアトリビュートには、主にメソッドが紐づいている

  * メソッドもオブジェクト：`method`型のオブジェクト

* 例)文字列型のアトリビュート

```python
>>> dir("abc")
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',
'__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__',
'__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format',
'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower',
'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',
'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
```

* アンダースコア`_`が2つ付いたアトリビュート名と、`find`や`join`といったメソッドが見える

* `特殊メソッド`：アンダースコア`_`が2つ付いたアトリビュート

  * 演算子を使った操作や、スライスなどを実行すると呼ばれるメソッド

  * プロトコルと呼ばれるオブジェクトの共通の振る舞いを定義するために利用する

* `呼び出し可能オブジェクト`：メソッドや関数のようなオブジェクト

  * 丸括弧`()`を添えて記述することで呼び出しを行う

  * `__call__`というアトリビュートを持つことも特徴

  * メソッドも呼び出し可能オブジェクトの一種

    * 呼び出し時に、アトリビュートの持ち主となるオブジェクトが第1引数に代入される

  * オブジェクトの持っているアトリビュートを取り出すには、オブジェクトからドット`.`を挟んでアトリビュート名を記述する

  * メソッドの呼び出しは、オブジェクトのアトリビュートを指定して、丸括弧`()`を添えることでメソッドを呼び出す

  * 組み込み関数`getattr()`を使うことでもアトリビュートを取得できる

* `getattr()`：アトリビュートを取得する

```python
getattr(オブジェクト, アトリビュート名)
```

* 例)

```python
>>> s = "abcde"
>>> getattr(s, "find")
<built-in method find of str object at 0x101c7bd50>
>>> s.find("cd")
2
>>> getattr(s, "find")("cd")
2
```

* 書き換えられるアトリビュートは、代入を行う他に、組み込み関数`setattr()`を使って書き換えることができる

* 組み込み型のアトリビュートは追加したり書き換えたりできない



## クラス、モジュールとアトリビュート

* Pythonでは、クラスやモジュールもオブジェクトとして扱うことができる

* オブジェクトなので、どちらも「型」があり、どちらもアトリビュートを持つ

  => クラスとアトリビュートはとてもよく似た作りなので、アトリビュートの使われ方もよく似ている

* クラスのアトリビュートには、クラスやスーパークラスに定義したメソッドが紐づいている

  => 定数のような使い方をするために、変数をクラスのアトリビュートとして定義することがある

* モジュールの場合は、トップレベルのブロックに定義された関数や変数がアトリビュートとして定義される

  => 例)mathモジュールをimportしたりすると、「mathオブジェクトのsinというようなアトリビュートにモジュールに定義された関数が紐づく」

* オブジェクトは、Pythonのプログラムで利用する部品の基本形

  => 関数、クラス、モジュールをオブジェクトとして定義し、共通のルールを設けている

* アトリビュートを使ってオブジェクトの階層構造を表現している

  => 組み込み型、モジュール、クラスなどオブジェクトの種類を問わず、階層の区切りを表現するためにドット`.`を使う



## オブジェクトと変数

* 変数にはオブジェクトを代入できる

  * 組み込み型のオブjけうとやクラスのインスタンス

  * モジュールや関数

  なども変数に代入できる

* 変数は、オブジェクトに付ける`名前付きタグ`のようなもの

* 例)変数に関数を代入する

  * 関数は呼び出し可能オブジェクトなので、代入した変数に対して丸括弧`()`を使い、代入する元の関数と同じ引数を与えて呼び出す

```python
>>> import math
>>> m = math         # モジュールを変数に代入
>>> s = m.sin        # sin()関数を変数に代入
>>> s(0.5)           # 代入した変数を呼び出す
0.479425538604203
```

* アトリビュートには、オブジェクトという`持ち主`がいる

  => 変数の持ち主は、モジュール

* Pythonでは、スクリプトファイルとモジュールは同じように扱われるので、実行中のファイルが変数の持ち主とも言える

  * モジュールから見ると、変数や関数、インポートしたモジュールは、名前(name)にオブジェクトが紐づいたものとして扱われる

  => インスタンスに、オブジェクトやメソッドがアトリビュートとして紐づくのと同じ

  * 名前(name)に組み込み型のオブジェクトや関数のような呼び出し可能なオブジェクト(モジュールオブジェクト)が紐づいている

* 未定義の変数や関数、インポートしていないモジュールを参照しようとすると「NameError」というエラーが発生する

  => 名前(name)を参照しようとしたが、存在しない



## オブジェクトと名前空間

* アトリビュートや変数など、「名前を付けられるものに全て親がいる」というのがPythonのオブジェクトの基本構造

  => 親となるオブジェクトでは、ディクショナリのような仕組みを使って名前を管理している

  => 名前空間の実体

* 変数名やアトリビュート名がディクショナリのキーとなり、キーに対応する値としてオブジェクトを登録していく

  * ディクショナリの値としては、様々なオブジェクトが登録される

* 名前空間は、ディクショナリをベースに作られているので、同じ名前を持つ変数と関数を定義すると衝突が起こる

  => ディクショナリのキーに対応する値が上書きされる

* 例)変数と関数の名前を同じにする

```python
>>> spam = 1
>>> def spam():
...   print("Spam!")
...
>>> print(spam)
<function spam at 0x101c78ae8>
```

* 最初に変数spamを定義した時点で、モジュールの持つ名前空間のディクショナリに「spam」というキーが登録される

  => この時点では、キーに対応する値として「1」という数値オブジェクトが登録される

* 次に、spamという同名の関数を定義することで、同じキーに関数が登録される

  => この状態で`print()`によってspamというキーに割り当てられたオブジェクトを表示しようとすると、関数そのものが表示される


* Pythonではクラスもオブジェクトなので、モジュールが名前空間のディクショナリを持っているように、クラスもディクショナリを持っている

  * クラスにメソッドを定義することは、このディクショナリにメソッド名に相当するキーを追加することと同義

* メソッドと同じブロックで変数の代入を行うと、クラスの持つアトリビュートを登録できる

  * クラスの持つ名前空間のディクショナリに木９ーを登録している

  * インスタンスも、独自の名前空間用ディクショナリを持っている

* インスタンスとクラスオブジェクトは親子関係にあるので、インスタンスからクラスオブジェクトを透過的に見ることができる

  * クラスオブジェクトの名前空間に登録されたメソッドをインスタンスから呼び出すことができる

  * クラスオブジェクトに登録されたアトリビュートを、インスタンスから参照することもできる


### ~まとめ~

1. 名前空間の実体はディクショナリ

1. 親子関係にあるオブジェクトでは、子供のオブジェクトから親の名前空間が透過的に見える



| 版 |  年月日   |
|---|----------|
|初版|2019/02/03|
