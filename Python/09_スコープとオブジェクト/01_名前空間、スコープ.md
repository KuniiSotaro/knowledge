01 名前空間、スコープ
==================

* プログラム言語では、「名前空間」、「スコープ」と呼ばれるルールを使って、変数やオブジェクトがどのように見えるかを管理している

* Pythonでは、名前空間やスコープについてシンプルで一貫性のあるルールを採用している



### 名前空間

* `名前空間`：オブジェクトが所属する「場所」のこと

  * Pythonの場合は、コードの中のどのような位置でオブジェクトが **最初に定義されたか** によって、所属する名前空間が決まる

* Pythonの関数内で定義された変数は、関数を抜けると見えなくなってしまう

  => 関数で定義された変数が、関数の中でだけ有効な名前空間に属しているため

* 名前空間の「名前」とは、変数名やアトリビュート名のような「名前」のことを指す

  => Pythonでは、オブジェクトに付ける名前を管理するための「空間」が何種類か用意されている

* 例)ある名前空間で「foo」という名前の変数に代入が行われた場合、

  * その名前空間に「foo」と呼ばれる名前がない：新たに変数を作り、オブジェクトを代入する

  * その名前空間に「foo」と呼ばれる名前がある：すでに登録されているオブジェクトを上書きする

  => 名前の参照も同様、現在の名前空間で見つからない場合は、例外が発生する



### スコープ

* `スコープ`：コード上でオブジェクトが有効になる範囲

  * どのような名前がどの範囲で有効と判断されるかは、その名前が所属している名前空間によって決まる

  * 例)関数内のスコープでは、上位の名前空間で定義された変数を参照することができる

    => 関数の外から、関数内で定義された変数を参照することはできない

* `スコープ`は、「名前空間と名前が参照されるルールを含めたより広い範囲の意味を示す言葉」



## スコープのルール

* Pythonのスコープは、大きく分けて3つの種類がある

  => 中でも注意すべきなのは、`モジュール(グローバル)スコープ`と`ローカルスコープ`

  * スコープは、オブジェクトを入れておく変数(名前)が置かれる世界

* モジュールのスコープ用の世界は、いつでも使えるように用意されている

  * 関数のブロックに入るたびに、ローカルスコープのための世界が用意され、関数から抜け出すと世界がなくなる、というのが基本的なルール

![ブロックによってスコープが変わる](./images/ブロックによってスコープが変わる.png)

* Pythonのスコープには、順位がある

  * より高い順位のスコープに所属している「名前」は参照できる

  * 高い順位のスコープから低い順位のスコープにある変数を参照できない



### ビルトインスコープ

* 組み込み関数や組み込みの変数など、特に宣言やインポートしなくても利用できる関数や変数などの名前が定義されているスコープ

* Pythonのプログラムで常に存在している空気のようなスコープのこと

* プログラムを作っている時には、このスコープを意識することはあまりない

* このスコープの上に変数や関数のような名前を持ったオブジェクトを新しく作ることはできない



### モジュール(グローバル)スコープ

* モジュールのトップレベルのブロックで定義されている、変数や関数のような名前が定義されるスコープ

* Pythonでは、スクリプトファイルとモジュールはほぼ同じものとして扱われる

* スクリプトファイルやモジュールが、プログラムで自由に名前を定義できる一番上位のスコープのこと

* Pythonでは、一般的な意味での`グローバルスコープ`は存在しない

* `グローバルスコープ`が存在しないので、`グローバル変数`も存在しない

  => 多くのプログラム言語のような、プログラム全体から参照できる位置に変数を定義して、様々な場所で使い倒すことはできない



### ローカルスコープ

* 関数が定義されると作られるスコープ

* 関数内で代入して定義した変数は、ローカルスコープに属する

* 関数の中でdef文を作って、`入れ子の関数`を作ると、さらに`ローカルスコープ`が作られる

  => このようにして作られるスコープは、`ネストされたスコープ`と呼ぶ

* global文を使うと、ローカル変数に定義した変数を、モジュールスコープに移すことができる

![3つのスコープ](./images/3つのスコープ.png)

### 例)`scopetest1.py`

```python
a = 1
b = 2
def foo():
  b = 10
  print(a, b)

foo()
print(a, b)
```

* 実行結果

```python
1 10
1 2
```

* 一番目の結果は、プログラムの最初で変数aに「1」を、`foo()`という関数の中で変数bに「10」を代入

  * プログラムの制御が関数の中に移ると、新しいスコープが作られる

  * 関数内では変数へ数値を代入する(Pythonでは、新しい変数を定義する)

  * 新しく作ったスコープでは、変数bが存在しないので、新しい名前を登録し、その変数に10という値を代入する

* 2番目の結果は、「10」を代入したはずの変数bが元の「2」に戻っている

  * モジュールスコープからは関数(ローカル)スコープ上の変数bは見えないので、プログラムで代入した「2」という数値が表示される



### 例)`scopetest2.py`

```python
import scopetest1

print(a, b)
```

* 実行結果

```python
1 10
1 2
Traceback (most recent call last):
  File "scopetest2.py", line 3, in <module>
    print(a, b)
NameError: name 'a' is not defined
```

* aとbという変数は、このモジュール内で定義されていないので、名前が見つからないというエラーが発生する

* Pythonのスコープルールでは、モジュールの外に名前が影響することはない



### 例)`scopetest3.py`

* 変数を定義することなく、エラーが出ないようにする

* このコードでやりたいことは、`scopetest1`モジュールで定義されているa, bという変数を、別のモジュール上で表示する

1. `print()`関数に添えている変数の参照方法を変える

  * 変数a, bの前に`scopetest1`というモジュール名を補って、変数とモジュールの間にドット`.`を置く

    => モジュールのスコープにある名前(変数)を参照できる

```python
import scopetest1

print(scopetest1.a, scopetest1.b)
```

1. モジュールのインポートを行なっている行を`from scopetest1 import a, b`のように記述することで、`print()`の部分を元のように書き換えることができる



## クラス、インスタンスのスコープ

* クラスやクラスを設計図として作るインスタンスも、独自のスコープを持っている

* Pythonのクラスの作りは、モジュールとよく似ている

  => クラスのスコープは、モジュールスコープと同じように機能する

* インスタンスのスコープは、`ローカルスコープ`に該当する

  * クラスのスコープより低い位置にある

  * インスタンスからクラスに定義されているアトリビュートを参照できる

  * インスタンスに対して、クラスの持つアトリビュートと同じ名前のアトリビュートを代入する際には注意が必要

    => アトリビュートへ代入を行うと、新しいアトリビュートが作られるので、クラスアトリビュートが隠れてしまい、見えなくなる

    => 関数内にモジュールスコープと同名の変数を定義する時に注意する必要があるのと同じ理屈

* 例)クラスとインスタンスのアトリビュート

```python
class Klass:
  a = 100

i1 = Klass()
i2 = Klass()
i1.a = 10         # 片方のアトリビュートに代入

# 実行結果
i1.a              # クラスアトリビュートが隠される
10

# 実行結果
i2.a              # i2からはクラスアトリビュートが見える
100

Klass.a = 1000    # クラスアトリビュートに直接代入

# 実行結果
i2.a
1000
```

![インスタンスとクラスのスコープ](./images/インスタンスとクラスのスコープ.png)

* クラス名を使うと、アトリビュートを直接指定することができる

* クラスのアトリビュートに対する変更が、アトリビュートを上書きしていないインスタンスから透過的に見えている



| 版 |  年月日   |
|---|----------|
|初版|2019/02/03|
