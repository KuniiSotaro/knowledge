01 クラスを継承する
================

* `クラスの継承`：あるクラスを雛形にして、別のクラスを作ること

  * 雛形となるクラスを、`親クラス`と呼ぶ

  * スーパークラスを元に作られたクラスを、`サブクラス`と呼ぶ

* 継承という機能を使うと、すでにある設計図を元にして、

  * 一部の機能だけを書き換え

  * 機能を強化した別の設計図(クラス)

  を作ることができる

* クラスの継承を行う際、基本的な機能は元の設計図(スーパークラス)に定義されているものをそのまま流用する

* サブクラスでは、必要な部分だけを書き換えたり、新たに追加する機能だけを設計図に書き換えることになる

  => 同じ処理をするコードを重複して書く必要がなくなるため、プログラムを効率的に開発することができる

* Pythonは、クラスの`多重継承`(複数のクラスを組み合わせて、新しいクラスを定義する)に対応している

  * 数値や文字列といった組み込み型を継承して、新しいクラスを作ることもできる

    => 組み込み型の持つ豊富な機能をそのまま引き継いで、新たな機能を持つ独自のクラスを作ることができる



## スーパークラスを指定する

* Pythonでクラスの継承を行うためには、class文でスーパークラスを指定する

* クラスの後に丸括弧`()`を付け、その中に継承したいクラス(スーパークラス)の名前を記述する

* 複数のクラスを継承(多重継承)するときは、カンマ`,`でクラス名を列記する

```python
class クラス名(スーパークラス名1[, スーパークラス名2, ...]):
```

* 例)Prismクラス(角柱を表現するクラス)を定義する

```python
class Cube(Prism):
```



## メソッドのオーバーライド

* クラスを継承する場合、スーパークラスのメソッドはサブクラスにそのまま受け継がれる

* 機能を変更したいメソッドだけ、サブクラスで改めて定義する

  => `メソッドのオーバーライド`

  * 同名のメソッドを定義すると、上書きになる

  * 未定義のメソッドは、引き継がれる

```python
>>> class Cube(Prism):
...   def __init__(self, length):
...     self.width = self.height = self.depth = length
...
>>> c = Cube(20)
>>> c.content()
8000
```

* `content()`メソッドはそのまま利用することができる

  => インスタンスが持つ3つのアトリビュートと同じアトリビュートを持っているので、そのまま利用できる



## 初期化メソッドのオーバーライド

* Pythonのメソッドをオーバーライドすると、完全な上書きが行われれる

  => しかし、場合によっては厄介なこともある

* 例)インスタンスに、3辺の長さだけでなく、センチメートル(cm)ミリメートル(mm)といった単位も保存できるようにする

  => 単位付きの体積を文字列として返す`unit_content()`というメソッドを追加する

```python
>>> class Prism:
...   def __init__(self, width, height, depth, unit='cm'):
...     self.width = width
...     self.height = height
...     self.depth = depth
...     self.unit = unit
...   def content(self):
...     return self.width*self.height*self.depth
...   def unit_content(self):
...     return str(self.content()) + self.unit
...
```

* このPrismクラスを継承して、先ほどと同じCubeクラスを定義する

  * Pythonでは、メソッドのオーバーライドは上書きになる

    => 継承元のスーパークラスに定義された同じメソッドは呼び出されない

  * 新しく追加されたPrismクラスのアトリビュートは、Cubeクラスのインスタンスでは定義されなくなる

```python
>>> c = Cube(20)
>>> c.unit_content()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 10, in unit_content
AttributeError: 'Cube' object has no attribute 'unit'
```

* 対処法

  1. Prismクラスの変更に合わせて、継承をしているCubeクラスも変更する

  1. サブクラスの初期化メソッドで、スーパークラスの初期化メソッドを呼び出す



## `super()`を使ったスーパークラスの取得

* スーパークラスのメソッドを呼び出すには、`super()`という組み込み関数を使う

  * 引数を与えずに呼び出すと、自動的にスーパークラスを呼び出せる

  * 引数を渡す場合は、

    * 1つ目は、スーパークラスを調べたいサブクラスのクラス名

    * 2つ目は、インスタンス(`self`)

    を渡すようにする

* 例)Cubeクラスのメソッドを呼び出す

```python
>>> class Cube(Prism):
...   def __init__(self, length):
...     super().__init__(length, length, length)
...
>>> c = Cube(20)
>>> c.unit_content()
'8000cm'
```



## スロット

* Pythonでは、代入を行うことでインスタンスにアトリビュートを自由に追加できる

* `スロット`：アトリビュートの追加を制限する

  => メモリの使用効率をよくするためなどに利用される機能

* クラスに`__slots__`というアトリビュートを持たせることで、アトリビュートに制限することができる

  * インスタンスに追加するアトリビュート名(文字列)をシーケンスで代入する

```python
__slots__ = [追加を許可するアトリビュート名]

# 例
__slots__ = ['foo', 'bar']
```

* 例)

```python
>>> class Klass:
...   __slots__ = ['a', 'b']
...   def __init__(self):
...     self.a = 1
...
>>> i = Klass()
>>> i.a
1
>>> i.b = 2
>>> i.b
2
>>> i.c = 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Klass' object has no attribute 'c'
```



## プロパティ

* Pythonのアトリビュートは、インスタンスを通して参照したり、書き換えることができる

* しかし、アトリビュートのように、インスタンスの持つデータを直接操作するのはよくない

  * 不意に予期せぬ種類のデータに書き換えられてしまう

* インスタンスのデータ(アトリビュート)を変更したり参照する専用のメソッドを作る

  * `セッター`：データを設定するメソッド

  * `ゲッター`：データを取り出すメソッド

* `プロパティ`は、この`セッター`と`ゲッター`を手軽に定義するための機能

  => アトリビュートに対して代入や参照を行うと、セッター、ゲッターに処理を自動的に振り分けるようになる

* `property()`：プロパティを設定する

  * プロパティとして振る舞うアトリビュート名に、`property()`の戻り値を代入する

  * `property()`の引数には、`セッター`と`ゲッター`のメソッド名を渡す

```python
property([ゲッター[, セッター]])
```

* 例)

```python
>>> class Prop:
...   def __init__(self):
...     self.__x = 0
...   def getx(self):
...     return self.__x
...   def setx(self, x):
...     self.__x = x
...   x = property(getx, setx)
...
>>> i = Prop()
>>> i.x
0
>>> i.x = 10
>>> i.x
10
>>> i._Prop__x
10
```

* `i._Prop__x`という記法で、アトリビュートを無理やり参照している

  => プロパティに指定した「x」の値を変更することで、セッターによって自動的にアトリビュート「`__x`」に10という数値が代入されている

* セッター、ゲッター内で扱うアトリビュート名と、プロパティに設定するアトリビュート名を同名にしてはいけない

  => 無限ループが発生する



| 版 |  年月日   |
|---|----------|
|初版|2019/01/30|
