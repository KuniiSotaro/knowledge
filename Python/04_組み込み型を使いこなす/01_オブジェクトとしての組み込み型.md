01 オブジェクトとしての組み込み型
============================

## メソッドとは

* 単純な仕事を行うプログラムでは、組み込み型の基本的な機能だけを使って作ることができる

* 少し複雑な機能を持つプログラムを作る場合は、基本的な機能だけで作ると、コードがスッキリかけず、読みにくくなる

* 例)要素のインデックスを調べる

```python
# 組み込み型を使わない
>>> def find_index(the_list, target):
...   idx = 0
...   for item in the_list:
...     if target == item:
...       return idx
...     idx = idx + 1
...
>>> mcz = ["れに", "しおり", "あやか", "ももか"]
>>> find_index(mcz, "しおり")
1

# 組み込み型を使う
>>> mcz.index("しおり")
1
```

* 1つ目のコードでは、find_index()には2つの引数を渡している

* 2つ目のコードでは、引数が1つ(探そうとする文字列)しかない

* このように、データに紐づいて、データに対する処理や操作をする関数のことを、「`メソッド`」と呼ぶ

  => メソッドとは、方法、やり方という意味

  => 特定のデータに紐づいて、データを操作する方法を提供するもの

* Pythonの組み込み型の例として、

  * リスト型：

    |  メソッド  |                解説                |
    |:----------|:----------------------------------|
    |`count()`  |ある要素がリストにいくつ含まれるかを数える|
    |`reverse()`|リスト要素の順番を逆にする             |
    |`sort()`   |リスト要素を並べ替える                 |



## オブジェクトとしての組み込み型

* これまで見てきた手法を使ってプログラムを作る手法のことを、`命令型プログラミング`と呼ぶ

  * データはデータ、命令は命令、と言うように別々に扱う

  * シンプルで明瞭なプログラムを作ることができる

  * 色々な種類の関数を用意する必要があり、プログラムが無駄に長くなる

* 複雑で規模の大きいプログラムを、より手軽に作る手法として、`オブジェクト指向`がある

  * データを命令を一緒にする

  * `オブジェクト`：データと命令(メソッド)が一緒になっているもののこと

  * どのような処理を必要としているかは、オブジェクトが知っている

  * Pythonでは、メソッドを呼び出す時に、変数などの後ろにドット`.`を書いて、さらにメソッド名を続ける

    => その後、必要に応じて引数を渡す

  ```python
  データ.メソッド名(引数1, 引数2, ...)
  ```

* メソッドを使った記法も、関数を使った記法も、表面上は処理の対象が書かれている場所が違うだけで、やっていることには差がない

  => オブジェクト指向も、命令型プログラミングも、同じ事柄を視点を変えて見ているだけ(find_index()とindex()

* Pythonは、命令型プログラミングと、オブジェクト指向のいいとこ取りをしたプログラミング言語

  * 基本的な処理は、命令型プログラミングの手法で作ることができる

  * 少し複雑で高度なプログラムを作るときは、オブジェクト指向の手法が使えるようになっている

* 組み込み型は、Pythonの目指すオブジェクト指向のエッセンスを凝縮したような作りとなっている



## 組み込みのデータ型一覧

### 数値型

* 数値を扱うためのデータ型

* 演算子を使った計算、比較ができる

* 整数だけを扱える`int`型(整数型)と、小数点を含む数を扱える`float`型(浮動小数点型)がある

* 複素数を扱える`complex`型(複素数型)も存在するが、本書では詳しく扱わない



### 文字列型

* 文字列を扱うためのデータ型

* `str`型と呼ばれることがある

* 演算子を使った計算や比較ができる

* メソッドを使って、文字列に対する操作ができる

* Pythonの文字列型は、リストなどと同じく、複数の要素(文字)を集めたデータ

  => インデックスを使って要素を取り出すことができる

* ただし、リストのように、要素の入れ替えをすることはできない



### リスト型

* 複数の要素を並べて管理するためのデータ型

* インデックスを使って要素を取り出したり、入れ替えたりすることができる

* メソッドや文により、要素の追加や削除、並べ替えを行える他、要素の検索や特定の要素数を取得することも可能



### タプル型

* リストと似た機能を持ったデータ型

* リストと同じような操作ができるが、要素の変更ができない

* 主に、異質な複数の要素を管理するために使われる

* メソッドを使って、タプルに対する処理を実行できる



### ディクショナリ型

* キーと値をペアにして、複数の要素を管理するためのデータ型

* リストと同じく、複数の要素を集めたデータだが、順番という概念がない

* キーや文、メソッドを使用してディクショナリ内の要素を操作することができる



### set型

* 集合型

* 重複しない複数の要素を管理するために使うデータ型

* リストと同じく、複数の要素を集めたデータだが、順番という概念がなく、インデックスで要素にアクセスすることができない

* メソッドを使って中の要素を操作できる他、演算子により、複数のsetを使った集合演算が可能

* set型は要素の変更ができ、要素を追加したり取り除いたりできる

* setと同じ機能を持っていて、変更ができない`frozenset`型というデータ型も存在するが、本書では取り扱わない



### bytes型

* 文字列型の一種

* 文字列型(str型)と同じく、複数の文字を集めたデータ

* インデックスを使って文字を取り出すことができるが、変更ができない(文字列型と一緒)

* 文字列型はエンコードされた文字列型を扱うが、bytes型はエンコードされていない生の文字列データ

* このため、ファイルやインターネットから取り込んだ文字列は、bytes型として取り込まれる



### bool型

* if文に添える比較式が返すデータ型

* TrueかFalseの2種類の値しか取らない、特別なデータ型



## データ型の分類

* データの形態でなく性質に注目すると、違った視点で組み込み型を見ることができる

  => 同じような性質を持つ組み込み型を、仲間としてまとめて見る

* リストも文字列も、複数の要素を持つデータ型

  * インデックスを使って要素にアクセスする

  * スライスを使って複数の要素を一度に取り出す

  * for文に添えてループを組むことができる

* Pythonの組み込み型は、データの種類が違っても、同じ性質を持つ仲間ならば、同じように扱うことができる

  => 組み込み型が持つメソッドも同様

* 同じ性質を持つ組み込み型には、同じ名前のメソッドが割り当てられており、同じように使うことができる

  => オブジェクト(データ)の性質に注目して、操作が同じなら同じように扱える

* オブジェクト指向では、データと命令(メソッド)を一緒にしてオブジェクトとして捉える

  => プログラムを作るときは、オブジェクトを部品として組み合わせて使うが、複雑なプログラムでは、多くの種類のオブジェクトを扱うことになる

* たくさんの種類のオブジェクトに対して、性質の似た仲間をグループ分けして、うまく整理しておく



## シーケンス

* リスト型のように、複数の要素を順番に並べたデータ型を`シーケンス`と分類することがある

* リスト、タプルがシーケンスの仲間(文字列型もシーケンスの仲間)

* シーケンスには、以下のような特徴がある

  * インデックスで要素にアクセスできる

  * スライスで複数の要素にアクセスできる

  * for文に添えてループを組める

  * len()関数で要素数(長さ)を計れる

  * +演算子で連結できる

  * in演算子で要素の検索ができる

  * index()メソッドで要素のインデックスを、count()メソッドで要素の個数を調べられる

* 数値はもちろんシーケンス型ではない

* ディクショナリ型とset型は、複数の要素を持つことができるが、順番という概念がないので、シーケンス型には分類されない



## 変更可能と変更不可能

* Pythonでは、オブジェクト自体を変更できるか・できないか、で分類することができる

* リスト型のように、要素を入れ替えたり削除したりできるデータ型を`変更可能`と呼ぶ

  => `mutable`(ミュータブル)

* タプルや文字列のように、要素の変更ができないデータ型を`変更不可能`と呼ぶ

  => `immutable`(イミュータブル)

* リスト型、ディクショナリ型は変更可能な組み込み型の仲間

  * 要素を追加したり、インデックスやキーを使って、要素の置き換え、削除することができる

  * どの操作も、オブジェクト自体を変更することができる

* set型も変更可能なオブジェクトの仲間

  * 演算子を使って集合演算を行えるが、演算の結果はコピーとして返ってくる

  * set型のメソッドを使うと、オブジェクト自体を書き換えることができる

* リストやディクショナリのメソッドでも、結果として自分自身を書き換えることがある

  => オブジェクト自体を書き換える操作を、`破壊的操作`と呼ぶ

* 数値型や文字列型(str型、bytes型)、タプル型は変更可能な組み込み型の仲間

  * 文字列型はシーケンスの仲間でもあるので、インデックスを使って要素にアクセスできるが、要素を削除したり、入れ替えたりできない

  * リスト型とタプル型はよく似たデータ型だが、変更可能かどうかで異なる

  * 変更不可能なタプルには、要素のソートを行う`sort()`や、並び順を入れ替える`reverse()`のようなメソッドがない

  * 変更不可能なタプルには、リストにある破壊的操作を行うメソッドがごっそりなくなっている



## set型とディクショナリ型

* set型、ディクショナリ型はともに、複数の要素を順番なしに保存することができる

* 変更不可能なデータ型を要素として持つ

  => `変更不可能なデータのコレクション型`

* set型は、集合型とも呼ばれる

  * 重複がないようにしながら、複数の要素を保存できる

  * 要素が重複しないという要件を満たすために、変更不可能なデータ型だけしか登録できない制限がある

* ディクショナリのキーについても、インデックスの代わりにキーを要素の見出しとして使われているため、重複しないように保たれている

* 数値型、文字列型、タプル型は変更不可能なので、set型の要素にしたり、ディクショナリのキーにすることができる

* リスト型は変更可能なので、set型の要素にしたり、ディクショナリのキーにすることはできない



| 版 |  年月日   |
|---|----------|
|初版|2019/01/14|
