04 ジェネレータを使う
==================

* `ジェネレータ`：イテレータを簡単に定義するための仕組み

  * return文の代わりに、`yield文`を使って戻り値を返す関数を定義することで、イテレータを定義できる

  * Pythonのイテレータのような仕組みを、`外部イテレータ`と呼ぶ

  * ジェネレータのような仕組みを、`内部イテレータ`と呼ぶ

  => まとめると、ジェネレータは関数を使って`内部イテレータ`を定義するための仕組み

* `ジェネレータ関数`；ジェネレータとして動作する関数

  * ジェネレータ関数を呼ぶと、イテレータオブジェクトが返ってくる

  * 実際には、ジェネレータ関数をfor文などに添えて利用する



## ジェネレータ関数を定義する

* 例)素数を作るジェネレータ関数

```python
>>> def get_primes(x=2):
...   while True:
...     for i in range(2, x):
...       if x%1 == 0:
...         break
...     else:
...         yield x
...     x += 1
...
>>> i = get_primes()
>>> for c in range(10):
...     print(next(i))
...
2
# 以下、10個まで素数を表示
```

* ジェネレータ関数は、関数の呼び出しのように見える部分では、関数のブロックのコードは実行されず、イテレータが返ってくる

  => forブロックの中で`next()`を使ってイテレータオブジェクトから次の値を取り出しているが、この時に初めてジェネレータ関数のブロックが実行される

* 関数ブロックの中で`yield`の行に行き当たると、プログラムの制御がジェネレータ関数から抜け出す

  => `yield`文で関数の外に抜けた後も、関数内部のローカル変数はそのまま保存されている

  => 次に`next()`で関数内部にプログラムの実行が移った時、前の状態を引き継いで処理が続く

* ジェネレータ関数内のwhileループにTrueが添えられているので、無限に素数を見つけるイテレータを作ることができるが、遅延評価によって制御できる



## ジェネレータ式

* `ジェネレータ式`：

  * リスト内包表記のような記法を使って、手軽にジェネレータ式を定義することができる

  * 丸括弧`()`を使って、ジェネレータ式を定義する

```python
( 式 for 繰り返し変数 in シーケンス (if 条件式) )
```

* 例)リスト内包表記：リストを返す

```python
>>> [x**2 for x in range(1, 10)]
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

* 例)ジェネレータ式：イテレータを返す

  * ジェネレータ式を実行した直後には、全ての要素が確定しない

  * イテレータに対して次の要素を要求する処理(イテレーション)が行われて初めて、要素が確定する

    => 遅延評価が行われる

```python
>>> i = (x**2 for x in range(1, 10))
>>> print(next(i))
1
>>> print(next(i))
4
>>> print(next(i))
9
```

* ジェネレータ式を使うと、ジェネレータ関数より手軽にイテレータを定義できる

  => わざわざ関数を定義するまでもないシンプルな処理を実行したい時にジェネレータ式を活用すると便利



| 版 |  年月日   |
|---|----------|
|初版|2019/01/30|
