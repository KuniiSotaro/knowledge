11 オブジェクトの永続化とシリアライズ「shelve」「pickle」
=================================================

* プログラムでは、設定などをファイルに書き出して、次回プログラムを起動したときに設定を復元して利用するといったことがよく行われる

  * そのような処理をしたいとき、プログラムで利用している数値や文字列のようなオブジェクトをファイルに書き出し、読み込んで復元できると便利

* `オブジェクトの永続化`：メモリ上にあるオブジェクトの内容をファイルなどに書き込み、プログラムを終了してからも利用できるようにすうrhそり

  * 「オブジェクトを永続的に利用できるようにする処理」というような意味

  * 文字列であれば、内容をそのままファイルに書き出すだけで簡単に永続化ができる

  * しかし、リストやディクショナリのように複雑な構造を持ったオブジェクトを書き出そうとすると、オブジェクトの構造や型の情報を含めて書き出し、復元を行う必要がある

* ファイルなどにオブジェクトを書き出すには、構造や型などの情報を、順番に並んだ文字列のような形式に変換する

  * `シリアライズ`：オブジェクトを文字列のような一次元の形式に変換する処理のこと

![シリアライズ](./images/シリアライズ.png)

* `シリアライズ`は、永続化の前段階で実行される処理

  => シリアライズできるオブジェクトは永続化できる

* ほとんどのオブジェクトは永続化できるという事になるが、ファイルオブジェクトやスレッドのように、状況が変わると元の状態を復元できないようなオブジェクトはシリアライズができない

  => そのため、ファイルオブジェクトなどは永続化できない

* Pythonには、永続化やシリアライズを手軽に行うモジュールが内蔵されている



## ディクショナリを永続化する「`shelve`」

* `shelve`モジュール：ディクショナリの内容をファイルに記録し、復元できる

  * `shelveオブジェクト`と呼ばれるディクショナリと同じように利用できるオブジェクトを利用する

  * このオブジェクトは、ファイルのようにして開いて作る

  * `shelveオブジェクト`をディクショナリのようにして扱うと、ディクショナリの内容がファイルに書き出され、次回shelveオブジェクトを作ったときには内容が復元される

  * `shelveオブジェクト`は、次の`open()`関数で生成する

* `open()`：shelveオブジェクトを返す

  * ファイル名を指定して、`shelveオブジェクト`を返す

  * `shelveオブジェクト`に対しては、ディクショナリで利用できる全ての操作を行える

  * キーを指定した代入やメソッド呼び出しを含む操作を、ディクショナリと同じように行うことができる

  * キーに対応する値としては、数値や文字列だけでなく、シリアライズできるオブジェクトを何でも保存することができる

  * `shelveオブジェクト`に対して行なった変更は、即座にはファイルに反映されない

  * 大抵はそれでも問題は起きないが、どうしても変更を即座に反映させたい場合は、オプションの引数`writeback`にTrueを指定する

  * `shelveオブジェクト`の`close()`メソッドを呼び出すと、ファイルを閉じ`shelveオブジェクト`に登録された内容を書き出す

    => 実際に作られるファイルは、`open()`関数に与えられたファイルに拡張子をつけたものとなる(Windows:`.dir`、Mac:`.db`)

  * `protocol`には必要であればプロトコルのバージョンを渡すが、通常はあえて指定する必要がない

  ```python
  shelve.open(ファイル名[, protocol[, writeback]])
  ```

  * 例)shelveオブジェクトを使う

  ```python
  >>> import shelve
  >>> d = shelve.open("shelvetest")
  >>> d.update({"one":1, "two":2})
  >>> list(d.items())
  d.close()
  [('one', 1), ('two', 2)]
  >>> d.close()
  ```



## オブジェクトの永続化とシリアライズを行う「`pickle`」

* `pickle`：Pythonのオブジェクト化やシリアライズを行うためのモジュール

  * 数値や文字列はもとより、リストやディクショナリ、クラスのインスタンスのような複雑なオブジェクトも永続化できる

  * ファイルやスレッドのような一部のオブジェクトは永続化できない

    => 永続化できないオブジェクトを扱うと、「PickleError」という例外が発生する

  * `pickle`は、`shelve`に比べてより多くの種類のオブジェクトを扱えるが、永続化ファイルの書き出しやシリアライズの処理は、必要なときに明示的に実行する必要がある

* `pickle`を使うと、オブジェクトをシリアライズしてファイルに書き出したり、シリアライズしたオブジェクトを文字列として取り出したりすることができる

* `pickle化`：`pickle`を使ってシリアライズを行うこと

* `unpickle化`：`pickle`を使ってシリアライズをしたオブジェクトを復元すること

* `pickle`で書き出したファイルや、シリアライズして得られた文字列を使うと、元のオブジェクトを復元できる

![pickle、unpickle](./images/pickle、unpickle.png)

* `pickle化`したオブジェクトは、複数のプラットフォーム間で互換性がある

  * 例)`pickle`を使ってWindowsで書き出したファイルを、LinuxのPythonで読み込み、オブジェクトを復元することができる

  * 例)`pickle`化した文字列をネットワーク経由でやりとりし、Pythonのオブジェクトを複数プラットフォーム間で送受信する

* ただし、クラスインスタンスなどを`unpickle`化する過程で、コードが実行されることがある(第三者の作ったデータは`unpickle`化しない)

* `pickle`がオブジェクトをシリアライズ(pickle化)する方法には5つの種類があり、必要に応じて使い分ける

  * 書き出し、読み込みには同じバージョンを使う必要がある

  * バージョンは、永続化やシリアライズを行う関数に引数を渡すことで指定する

  * 引数を指定しない場合は「バージョン3」を利用する



### バージョン0

* オブジェクトをASCII文字列のみを使ってシリアライズする

* 古いPythonと後方互換性がある



### バージョン1

* オブジェクトをバイナリ形式(8ビット文字列)を使ってシリアライズする

* 古いPythonと後方互換性がある



### バージョン2

* Python2.3で導入された形式

* 2.3より古いバージョンと後方互換性がない



### バージョン3

* Python3で導入されたバージョン

* プロトコルの指定がない場合はこのバージョンが使われる

* Python2のpickleモジュールではunpickle化できず、互換性がない

* 特に理由がない限りは、このバージョンを使うことが推奨されている



### バージョン4

* Python3.4で追加されたバージョン

* このバージョンでは、大きなサイズのオブジェクトのサポートをし、より多くの種類のオブジェクトをpickle化できる



* `dump()`：永続化するオブジェクトをファイルに書き出す

  * 永続化するオブジェクトとファイルをオブジェクトを引数に渡して利用する

  * オブジェクトをpickle化したデータをファイルで書き出し、オブジェクトを永続化できる

  * 引数ファイルには、書き込みができるようなモードを指定したファイルオブジェクトなどを渡す

  * ファイルには、StringIOを使って作ったバーチャルなファイルを渡すことができる

  * オプションの引数`protocol`には、シリアライズするときに利用するプロトコルのバージョンを整数で指定する

    => 省略した場合は、バージョン3が用いられる

  ```python
  pickle.dump(永続化するオブジェクト, ファイル[, protocol])
  ```

* `load()`：pickle化したオブジェクトをファイルから読み込む

  * pickle化して書き出したファイルを指定し、永続化したオブジェクトを復元する

  * 復元化したオブジェクトは、関数の戻り値として返す

  * 引数には復元に利用するプロトコルを指定する必要がない

  * プロトコルはpickle化する際に書き込まれる

  * 復元する際には、書き込まれたプロトコルを利用する

  ```python
  pickle.load(ファイル)
  ```

  * 例)オブジェクトをpickle化する

  ```python
  >>> import pickle
  >>> o = [1,2,3,{"one":1},{"two":2}]
  >>> pickle.dump(o, open("pickle.dump","wb"))
  ```

  * 例)pickle化したオブジェクトを復元する
  ```python
  >>> o2 = pickle.load(open("pickle.dump", "rb"))
  >>> o2
  [1, 2, 3, {'one': 1}, {'two': 2}]
  ```

* `dumps()`：オブジェクトをpickle化して文字列として返す

  * 永続化するオブジェクトを引数に渡して利用する

  * オブジェクトをpickle化し、バイト型の文字列を戻り値として返す

  * `dump()`関数の文字列版

  ```python
  dumps(永続化するオブジェクト[, protocol])
  ```

* `loads()`：pickle化した文字列を読み込む

  * `dumps()`関数などで作ったpickle化バイト文字列を引数に渡すと、オブジェクトを復元する

  * 復元したオブジェクトは、戻り値として返す

  * `load()`関数の文字列版

  ```python
  loads(バイト型文字列)
  ```



| 版 |  年月日   |
|---|----------|
|初版|2019/02/09|
