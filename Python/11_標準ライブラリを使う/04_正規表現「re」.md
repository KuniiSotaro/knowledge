04 正規表現「re」
==============

* `正規表現`：文字列のパターンを表現するために利用される表現手法

  * 通常の文字列と`メタ文字`と呼ばれる特殊な文字を組み合わせてパターンを作り、パターンに指定された法則で並ぶ文字列を探す

  * 例)URLやメールアドレスのように、一定のルールに沿って作られている文字列を探し出す

  * 使いこなすと複雑な処理を驚くほど短く表記できるようになる

  * 反面、複雑な処理を行うための正規表現ほどブラックボックスになりやすくなる

    => 可読性やメンテナンス性が低くなる



## `re`モジュール

* Pythonで正規表現を利用するためには、`re`モジュールを使う

* RubyやPerlなどの言語では正規表現の機能が言語に組み込まれているが、Pythonでは独立したモジュールとして利用する

* Pythonの正規表現では、オブジェクトやメソッド呼び出しを組み合わせて置換や検索の処理を実行する

* Pythonの正規表現で利用するメタ文字やシンタックスはPerlに由来している

* ASCII文字列だけでなく、ユニコード文字列に対して正規表現を利用することもできる

* 正規表現のパターンには、バックスラッシュ`\`が含まれている

  * 正規表現のパターン用の文字列を定義するときには、クオーテーションの前に「`r`」をつけた`raw文字列`を利用する



## Pythonの正規表現

* Pythonで正規表現を使うには、大まかに分けて2種類の方法がある



### 正規表現オブジェクトを作って操作を行う

* 検索を行う前に、`正規表現オブジェクト`を作る方法

* 正規表現オブジェクトを作るときに、メタ文字などを含んだパターンを引数に渡して、`compile()`関数を使って事前にコンパイルをしておく

* 正規表現オブジェクトに対するメソッド呼び出しを行い、処理を行う

* 同じパターンを複数回利用する時など、コンパイルが一度しか行われないので、次の「パターンを引数に渡す」方法より、こちらの方が速度的に有利

![正規表現・コンパイル](./images/正規表現・コンパイル.png)



### パターンを引数に渡して処理を行う

* `re`モジュールに定義された関数を使って正規表現の処理を行う

  * メタ文字などを含んだ正規表現パターンを引数に渡し、処理を行う

* 検索などの結果は`マッチオブジェクト`というオブジェクトとして返ってくる

  * `マッチオブジェクト`は、正規表現にマッチした文字列のインデックスや、マッチした文字列などの情報を持っている

  * 必要な情報をマッチオブジェクトから取り出し、利用する



## 正規表現のパターン文字列

* 正規表現では、通常の文字列とメタ文字と呼ばれる特殊な文字列を組み合わせてパターン文字列を作る

* メタ文字は特殊な意味を持っている

  * 数値や英字のようなよく使われる文字を扱うために`特殊シーケンス`と呼ばれる文字も定義されている

* 表1. 単一の文字や特定の位置にマッチするもの

|   文字   |                                                                                                     説明                                                                                                     |
|:--------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   `.`   |改行を除いたどんな文字にもマッチするメタ文字。例えば「`abc.e`」というパターンは、「`abcde`」にも「`abcZe`」にもマッチする。フラグを付け加えると、改行にもマッチする                                                                  |
|   `^`   |文字列の先頭にマッチするメタ文字。「`^abc`」というパターンは「`abc`」とう文字列にはマッチするが、「`1abc`」という文字列にはマッチしない。通常は改行の直後を文字列の先頭と見なさない。フラグを与えると、改行の直後を先頭とみなすようになる。       |
|   `$`   |文字列の末尾にマッチするメタ文字。「`abc$`」というパターンは「`1abc`」という文字列にマッチするが、「`1abcd`」という文字列にはマッチしない。通常は改行の直前を文字列の末尾として見なさない。フラグを与えると改行の直前を末尾として見なすようになる。|
|`\d`、`\D`|`\d`は数字とマッチする。`\D`は数字以外とマッチする                                                                                                                                                                  |
|`\s`、`\S`|`\s`は空白や水平タブなどの空白文字列とマッチする。`\S`は空白文字列以外とマッチする。                                                                                                                                     |
|`\w`、`\W`|`\w`は大文字小文字を含む英数字とマッチする。`\W`は英数字以外とマッチする                                                                                                                                               |

* 表2. 他のパターンに添えて繰り返しを表現するもの

| 文字             | 説明                                                                                                                                                                                  |
|:---------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `*`              | メタ文字などに添えて使い、直前にあるパターンの0回かそれ以上、できるだけ多く繰り返したパターンにマッチするようにする。「`ab*`」は「`a`」、「`ab`」、「`abbb`」ともマッチする           |
| `+`              | メタ文字などに添えて使い、直前にあるパターンの1回以上、できるだけ多く繰り返したパターンにマッチするようにする。「`ab+`」は「`a`」にマッチしないが、「`ab`」、「`abbb`」にはマッチする |
| `?`              | メタ文字などに添えて使い、直前にあるパターンの0回か1回繰り返したパターンにマッチするようにする。「`ab?`」は「`a`」、「`ab`」にマッチする                                                                      |
| `*?`、`+?`、`??` |  `*`や`+`、`?`の直後にクエスチョンマークをつ付けると、できるだけ少ない文字列とマッチするようになる。「`<.*>`」というパターンは「`<h1>title</h1>`」という文字列の全体にマッチする。「`<.*?`」というパターンを使うと、最初に「`>`」が現れた時点で検索をやめて「`<h1>`」にだけマッチする。                                                                                                                                                                                     |

* 表3. その他のパターンにマッチするもの

| 文字                | 説明                                                                                                                                                          |
| :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `{m}`               | 直前のパターンをm回繰り返したパターンにマッチする                                                                                                             |
| `{m, n}`、`{m, n}?` | 直前のパターンをm回からn回繰り返したパターンのうち、一番長い文字列にマッチする。`?`を付けると、m回からn回繰り返したパターンのうち、一番短い文字列にマッチする |
| `[]`                | 文字の集合を指定するために使うメタ文字。英小文字をパターンに指定したい場合は「`[a-z]`」のように使う                                                           |
| `|`                 | 2種類のパターンの間に挟んで「`A|B`」のようにして使い、どちらかのパターンにマッチするパターンを作る                                                            |
| `()`                | 括弧の中にパターンを記述し、グループ化するために使う。                                                                                                        |



## 正規表現オブジェクトを使う

* Pythonの`re`モジュールを使って正規表現の処理を行うには2通りの方法がある

  => ここでは、正規表現オブジェクトを使う方法

* 正規表現オブジェクトは、検索したい文字やメタ文字などを組み合わせて作った正規表現のパターンを引数にして作る

  * そのようにして作った正規表現オブジェクトに対してメソッドを呼び出し、検索や置換などの処理を実行する

  * 正規表現オブジェクトを作るには、`compile()`関数を呼ぶ

* `compile()`：正規表現オブジェクトを返す

  * 引数として正規表現パターンを渡し、正規表現オブジェクトを作る

  * オプションの引数フラグに`re.I`のようにフラグを渡すと、正規表現を使った検索の方法を細かく指定できる

  * 複数のオプションを指定したい場合は、ビット演算子の「`|`」を使い、`re.I | re.M`のようにする

  * フラグは`re`モジュールに変数として定義されている

  * `import re`というようにモジュールを読み込んだら、モジュール名とドットに続けて`re.S`のように指定する

  ```python
  re.compile(正規表現のパターン[, フラグ])
  ```

  * 全て大文字で、短い表記と長い表記の2種類がある

  * 表. コンパイル時に利用するフラグ

| フラグ            | 説明                                                                                                                        |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `I`、`IGNORECASE` | 正規表現のマッチを行う時、英字の大文字、小文字を区別しない                                                                  |
| `M`、`MULTILINE`  | 改行を考慮し、行の頭と行の後ろを扱う。`^`(先頭のみにマッチ)と`$`(行末にのみマッチ)という2文字のメタ文字の挙動に影響を与える |
| `S`、`DOTALL`     | メタ文字`.`を、改行を含む全ての文字にマッチするようにする                                                                   |
| `A`、`ASCII`      | `\w`、`\W`、`\b`、`\B`、`\d`、`\D`、`\s`と`\S`を、ASCII文字特性データベースに従わせる                                       |
| `L`、`LOCALE`     | ロケールにしたがって`\w`、`\W`のような特殊シーケンスを処理する                                                              |



### 正規表現オブジェクトで使えるメソッド

* 「`regexp`」は、正規表現のオブジェクトのことを指す

* `findall()`：マッチした全ての文字列をリストで返す

  * 処理対象とする文字列の中を全て調べ、正規表現オブジェクトに設定されたパターンにマッチする文字列を探し出す

  * 結果として返ってくるのは文字列のリスト

  * マッチする部分が見つからない場合は、空のリストが返ってくる

  * オプションの引数`ops`では、検索を開始する位置をインデックスで指定する

    * 省略すると「0」が設定されたものと見なし、処理対象とする文字列の先頭から検索する

  * `endpos`は、検索を終了する位置をインデックスで指定する

    * 省略すると、文字列の最後まで検索する

  ```python
  regexp.findall(処理対象とする文字列[, pos[, endpos]])
  ```

* `split()`：マッチするたびに文字列を分割する

  * 処理対象となる文字列の中を全て調べ、正規表現オブジェクトに設定されたパターンにマッチする場所が見つかるたびに文字列を分割する

  * 結果として返ってくるのは文字列のリスト

  * 第2引数を整数で指定すると、指定した数で分割を終了する

    * 省略すると文字列を最後まで分割する

  ```python
  regexp.split(処理対象とする文字列[, 最大分割数])
  ```

* `sub()`：マッチした文字列を置換する

  * 置換を行う文字列の中を全て調べ、正規表現オブジェクトに設定されたパターンにマッチする場所が見つかるたびに置換用の文字列に置き換える

  * 第3引数を整数で指定すると、指定した数だけ置換したら終了する

    * 省略すると見つかった全ての文字列を置換する

  ```python
  regex.sub(置換用の文字列, 置換を行う文字列[, 置換数])
  ```

* `search()`：マッチした箇所をマッチオブジェクトで返す

  * 正規表現オブジェクトに設定されたパターンを使い、処理対象とする文字列からマッチを検索する

  * 戻り値はマッチオブジェクト

  * マッチオブジェクトには、マッチに関する情報が格納されている

  * オプションの引数を使って、検索の範囲を指定できる

  * マッチが見つからなければ「None」を返す

  * 引数pos、endposについては`findall()`メソッドと同じ

  ```python
  regexp.search(処理対象とする文字列[, pos[, endpos]])
  ```

* `match()`：マッチした箇所をマッチオブジェクトで返す

  * `search()`メソッドと同じような機能を持っているが、文字列の先頭だけをマッチの対象とする

  * 引数pos、endposについては`findall()`メソッドと同じ

  ```python
  regexp.match(処理対象とする文字列[, pos[, endpos]])
  ```

* `finditer()`：マッチオブジェクトのイテレータを返す

  * 正規表現オブジェクトに設定されたパターンを使い、処理対象とする文字列を検索して、マッチする文字列を先頭から順番に返す

  * メソッドが返すのはマッチオブジェクトを返すイテレータ

  * for文に添えて使うと繰り返し変数にマッチオブジェクトを代入しながら処理を行える

  ```python
  regexp.finditer(処理対象とする文字列[, pos[, endpos]])
  ```



## パターンを引数に渡して正規表現の処理をする

* `re`モジュールには、正規表現オブジェクトを使わずにパターンを直接渡して処理をする関数が定義されている

* 正規表現オブジェクトに対して行える処理がほとんど実行できる

* `findall()`：マッチした全ての文字列をリストで返す

  * 正規表現オブジェクトの`findall()`と同じで、マッチする文字列をリストにして返す

  * 検索開始位置と終了位置の指定はできない

  ```python
  re.findall(正規表現パターン, 処理対象とする文字列)
  ```

* `split()`：マッチするたびに文字列を分割する

  * 正規表現オブジェクトの`split()`メソッドと同じで、文字列内のマッチを元に分割を行う

  ```python
  re.split(正規表現パターン, 処理対象とする文字列[, 最大分割数])
  ```

* `sub()`：マッチした文字列を置換する

  * 文字列内のマッチを対象に置換を行う

  * 正規表現オブジェクトの`sub()`メソッドと同じ

  ```python
  re.sub(正規表現パターン, 置換用の文字列, 置換を行う文字列[, 置換数])
  ```

* `search()`：マッチした箇所をマッチオブジェクトで返す

  * マッチが見つかるとマッチオブジェクトを返す

  * 正規表現オブジェクトの`search()`メソッドと同じ

  ```python
  re.search(正規表現パターン, 処理対象とする文字列)
  ```

* `match()`：マッチした箇所をマッチオブジェクトで返す

  * 文字列の先頭だけを対象にマッチを探し、マッチオブジェクトを返す

  * 正規表現オブジェクトの`match()`メソッドと同じ

  ```python
  re.match(正規表現パターン, 処理対象とする文字列)
  ```

* `finditer()`：マッチオブジェクトのイテレータを返す

  * 文字列でマッチが見つかったらマッチオブジェクトを返すイテレータを返す

  * for文のループに添えて使う

  * 正規表現オブジェクトの`finditer()`メソッドと同じ

  ```python
  re.finditer(正規表現パターン, 処置対象とする文字列)
  ```



## マッチオブジェクトを使う

* `search()`や`match()`関数で正規表現の検索を行うと、結果として`マッチオブジェクト`と呼ばれるオブジェクトが返ってくる

  * `マッチオブジェクト`を使うと、検索に使った正規表現にマッチする文字列についての詳しい情報、(例：検索した文字列、開始位置)などを得ることができる

* 「`M`」はマッチオブジェクトを表す

* `group()`：マッチした文字列を返す

  * 検索結果の文字列を返す

  * 引数に1以上の整数を与えると、パターン文字列の「(`?`)」で囲んだグループの位置を指定できる

  ```python
  M.group([グループのインデックス, ...])
  ```

* `groups()`：グループを全て返す

  * マッチオブジェクトに含まれるグループを全て返す

  * 戻り値は文字列のタプルになる

  ```python
  M.groups()
  ```

* `start()`・`end()`：開始位置と終了位置のインデックスを返す

  * 検索結果の開始位置と終了位置を、検索対象として与えた文字列のインデックスで返す

  * 引数に1以上の整数を与えると、グループについての開始位置と終了位置を得ることができる

  ```python
  # start()メソッド
  M.start([グループのインデックス])

  # end()メソッド
  M.end([グループのインデックス])
  ```



### `re`アトリビュート

* 検索に利用した正規表現オブジェクトに繋がるアトリビュート



### `string`アトリビュート

* 検索対象となる文字列を保存しているアトリビュート



## 正規表現のサンプル

* 例)正規表現を使ったURLのマッチング

```python
>>> import re
>>> from urllib import request
>>> url = "https://www.python.org/news/"
>>> src = request.urlopen(url).read()
src = src.decode("utf-8")
>>> src = src.decode("utf-8")

>>> pat = re.compile(r'href="(/download/releases/.+?)"')

>>> for match in pat.finditer(src):
...   print(match.group(1))
...
```



| 版 |  年月日   |
|---|----------|
|初版|2019/02/06|
