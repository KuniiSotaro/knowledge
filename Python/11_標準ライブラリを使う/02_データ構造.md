02 データ構造
============

* Pythonは便利なデータ型を組み込み型として用意している

  * `リスト`や`ディクショナリ`といった組み込みのデータ型は、基本的には十分な機能を持っている

  * 少し凝ったプログラムを作ろうと思うと、より高機能なデータ型や特定の機能を持ったデータ型が欲しくなる

* 標準ライブラリでは、組み込み型を拡張した、痒いところに手が届くようなデータ構造を提供するモジュールが多く用意されている



## 追加時の順番を保持する「`collections.OrderedDict`」

* Pythonのディクショナリには順番という概念がないため、キーの一覧を取得すると、追加順に関係ない並びでキーが返ってくる

* しかし、ディクショナリの内容をファイルに保存するときなど、ディクショナリが返すキーや要素の順番が一定の法則に沿っている方が便利な場面がある

  => `collections`モジュールの`OrderedDict`を使う

* `OrderedDict`：キーや要素の一覧を取得するとき、追加順に要素を返すディクショナリ風のデータ構造

  * ディクショナリの内容を出力するとき、要素の並びを一定に保つことができる

  * 組み込み型のディクショナリと同じ使い方

  * `OrderedDict`のインスタンスを作り、ディクショナリのように要素を登録したり、変更したりできる

```python
# OrderedDictを用いる
>>> from collections import OrderedDict
>>> od = OrderedDict()
>>> od['a'] = 'A'
>>> od['c'] = 'C'
>>> od['b'] = 'B'
>>> od
OrderedDict([('a', 'A'), ('c', 'C'), ('b', 'B')])

# ディクショナリを用いる
>>> d = {}
>>> d['a'] = 'A'
>>> d['c'] = 'C'
>>> d['b'] = 'B'
>>> d
{'a': 'A', 'c': 'C', 'b': 'B'}
```

* Python3.6からは、組み込み型のディクショナリが`OrderedDict`と同じように要素の並び順を保持するようになる

* `OrderedDict`では新しく追加された要素が末尾にくるように並び順を保持する

  * 既存のキーに値を代入しても並び順は変わらない

  * del文などで要素を削除し、同じキーで代入を行うと要素は最後に追加される

* `OrderedDict`同士の比較では、要素の並び順を含めて一致したときに等しいと判断される

  * `OrderedDict`とディクショナリの比較では、並び順を考慮しないで要素を比較し、一致すれば等しいと判断する

* `OrderedDict`はディクショナリのサブクラスなので、ディクショナリの持つ全てのメソッドの他に、以下のメソッドを利用できる

* `popitem()`：要素を取り出して削除する

  * `OD`：`OrderedDict`のインスタンス

  * `OD`の要素を、キーと値のタプルで取り出す

  * 取り出された要素は元の`OD`から削除される

  * 引数にTrueを指定するか、または省略すると末尾から要素が取り出されるが、Falseを指定すると先頭から取り出される

```python
OD.popitem([末尾から取り出すかどうか])
```



## デフォルト値をもつディクショナリ「`collections.defaultdict`」

* `collections`モジュールの`defaultdict`も、ディクショナリのサブクラス

  * `defaultdict`では、キーに対応する値のデフォルト値を登録することができる

* `defaultdict`オブジェクトの生成

```python
defaultdict([関数名])
```

* オプションの引数に関数名を指定すると、存在しないキーが参照されたときにその関数が呼ばれて、戻り値をデフォルト値として設定できる

* 例)タプルからディクショナリを作る

```python
>>> animals = [('猫', '三毛'),   ('犬', 'コーギー'),
...            ('猫', 'シャム'), ('犬', 'ダックス'),
...            ('犬', '黒ラブ')]
>>> for k, v in animals:
...   if k not in d:
...     d[k] = v
...   else:
...     d[k].append(v)
...
Traceback (most recent call last):
 File "<stdin>", line 5, in <module>
AttributeError: 'str' object has no attribute 'append'
>>> d
{'猫': '三毛', '犬': 'コーギー'}
```

* 例)ディクショナリの`setdefault()`メソッドを使うと簡潔になる

```python
>>> d = {}
>>> for k, v in animals:
...   d.setdefault(k, []).append(v)
...
>>> d
{'猫': ['三毛', 'シャム'], '犬': ['コーギー', 'ダックス', '黒ラブ']}
```

* 例)`defaultdict`を使うと、より簡潔でわかりやすいコードが書ける

```python
>>> from collections import defaultdict
>>> dd = defaultdict(list)
>>> for k, v in animals:
...   dd[k].append(v)
...
>>> dd
defaultdict(<class 'list'>, {'猫': ['三毛', 'シャム'], '犬': ['コーギー', 'ダックス', '黒ラブ']})
```

* `defaultdict()`の引数に`list()`というリストを作る組み込み関数が指定されているので、「`dd`」はデフォルト値として「空のリスト」を返すディクショナリ

* for文の中では、ディクショナリの値に対してリストの`append()`メソッドを呼び出している

  * キーが存在しない場合は空のリストに対して`append()`で要素を追加し、存在する場合には既存のリストに対して値を追加している



## リストのソートを助ける「`bisect`」

* Pythonのリスト型には`sort()`メソッドがあり、要素をソートすることができる

* `bisect`モジュールは、リストの要素を常にソートした状態に保つために便利な関数を提供している

* リスト型の`sort()`メソッドを使って要素を追加する都度ソートを行うより、`bisect`を使った手法の方が一般的に高速に処理できる

* `bisect`モジュールでは、`配列二分法アルゴリズム`という手法を使って、ソートした状態である要素を追加したときに、どの場所に追加すれば良いかを割り出す



### `bisect`モジュール

* `insort_left()`：ソートされた状態で要素を挿入する

  * ソートずみのリスト`a`に、要素`x`をソートされた状態で挿入する

  * `x`と等しい要素が既にある場合は、等しい要素の最初に新しい要素を追加する

  ```python
  insort_left(a, x)
  ```

* `insort()`・`insort_right()`：ソートされた状態で要素を挿入する

  * ソート済みのリスト`a`に要素`x`を挿入する

  * `x`と等しい要素が既にある場合は、等しい要素の一番後ろに新しい要素を追加する

  ```python
  # insort関数
  insort(a, x)

  # insort_right関数
  insort_right(a, x)
  ```

* `bisect_left`：挿入位置のインデックスを返す

  * ソート済みのリスト`a`に、ソートを保ったまま要素`x`を追加できるインデックスを返す

  * `x`と等しい要素が既にある場合は、等しい要素の最初に新しい要素が追加されるようなインデックスを返す

  ```python
  bisect_left(a, x)
  ```

* `bisect()`・`bisect_right`：挿入位置のインデックスを返す

  * ソート済みのリスト`a`に、ソートを保ったまま要素`x`を追加できるインデックスを探す

  * `x`と等しい要素が既にある場合には、等しい要素の一番後ろに追加されるようなインデックスを返す

  ```python
  # bisect関数
  bisect(a, x)

  # bisect_right関数
  bisect_right(a, x)
  ```



| 版 |  年月日   |
|---|----------|
|初版|2019/02/06|
