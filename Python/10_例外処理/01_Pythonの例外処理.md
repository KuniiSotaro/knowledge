01 Pythonの例外処理
=================

* Pythonのプログラムで起こるエラーには、大きく分けて2つの種類がある

1. プログラムを実行する前にわかるエラー

  * 括弧`()`やクオーテーションの対応が取れていないエラー(`SyntaxError`：文法エラー)

  * インデントが適切でないエラー(`IndentationError`)

  * どちらかのエラーがあると、Pythonはプログラムを実行できない

1. プログラムを実行してみてわかるエラー

  * リストにインデックスを与えて要素を取り出すとき、リストが持つ要素の数より大きいインデックスを指定するとエラー(`IndexError`：インデックスエラー)



## 例外の発生

* Pythonでは、プログラムを処理中にエラーが起こると例外が発生する

* Pythonでは、例外もオブジェクト

  * 例外が発生すると、`例外オブジェクト`と呼ばれるオブジェクトを作る

  * `例外オブジェクト`には、エラーの種類やエラーの内容を記載した短い英文が記録される

  * `例外オブジェクト`を使うと、エラーの内容を知ることができる

* 色々な理由で発生するエラーを分類するため、Pythonには何種類もの例外が組み込まれている

  * `Exception`クラスを親として、種類によって分類されている



## 例外を捕まえる

* 例外が発生すると、大抵プログラムの実行が中断する

  * しかし、処理の内容によっては、例外が発生しても処理の実行を続けたい場合がある

  * プログラムの途中で例外が発生した場合は、ファイルを閉じたりネットワークを切断したりと言った`終了処理`を行いたい場合もある

* 存在しないファイルを開こうとした場合、Pythonは`FileNotFoundError`という例外を発生する

* `try~except`：エラーが発生した時に例外を捕まえる

  * ブロックの範囲を示すため、コードを必ずインデントする

![try~except文](./images/try~except文.png)

* 例)ファイル名を引数として、ファイルのサイズを調べる

```python
#!/usr/bin/env python

import sys                                         # sysモジュールをインポート

for fn in sys.argv[1:]:                            # スクリプトの引数を取り出す
  try:
    f = open(fn)
  except:
    print("{}というファイルは存在しません".format(fn))
  else:
    try:
      print(fn, len(f.read()))                     # ファイル名とサイズを表示
    finally:
      f.close()                                    # ファイルをcloseする
```

* 上記の例では、引数として渡されたファイルを開こうとする

  => ファイルが開けなかった場合は、例外が発生する

  => このスクリプトは、シェルから`python filelen.py test1.txt`のようにして実行する

* `test1.txt`が存在する場合

```python
test1.txt 69
```

* `test1.txt`が存在しない場合

```python
test1.txtというファイルは存在しません
```

* `try~except`で囲まれたブロックで例外が発生すると、プログラムの実行がスキップされ、`except`以下のブロックにプログラムの制御が移る

  * `except`以下は、ファイルが開けなかった(`FileNotFoundError`という例外が発生した)時だけ実行される

  * 実行中に発生した例外を捕まえ、エラー処理などを実行できる

  * エラーが起こった時でも、必要があればプログラムの実行ができる

* try文に続く`except`には、特定の例外オブジェクトを捕まえるための例外のクラスを記述する

  * except文を複数続けて、発生した例外によって異なった処理を実行するようなコードを記述できる

  * 何も記述しないと、全ての例外を捕まえるようになる

![tryブロックのそれ以降のプログラム](./images/tryブロックのそれ以降のプログラム.png)

* 例外処理の書式

|           書式            |                                                          説明                                                           |
|:--------------------------|:-----------------------------------------------------------------------------------------------------------------------|
|`except:`                  |全ての例外を受け取り、例外発生時の処理を行う                                                                                   |
|`except 例外クラス名:`       |クラスを指定して、特定の例外だけを受け取る。例外クラスは丸括弧`()`で囲み、カンマ`,`で区切ることによって複数列記できる。                    |
|`except 例外クラス as 変数名:`|例外クラスと、例外オブジェクトを受け取る変数名を指定する。例外オブジェクトが代入された変数を使って、例外に関するより細かな情報を得ることができる|
|`else:`                    |例外が発生しなかった場合の処理を記述したい時に利用する                                                                           |
|`finally:`                 |例外が発生しなくても、実行するブロックを記述する時に利用する                                                                      |

* `except`文、`else`文にはそれぞれインデントしたブロックが続く

* 例外を受けるクラスとして、複数の例外のスーパークラスとなるクラスを指定した場合、サブクラスを含めて例外を補足することができる



## with文

* 例外とよく似た機能として、`with文`という文法がある

  * 例外を使って書かれるような処理をクラスに定義するための機能

  * コンテキストマネージャという仕組みを使って、ブロックの実行を効率的に行えるようにするために追加された機能

* 例)ファイルが存在していれば処理を行う

```python
with open(fn) as f:
  for line in f:
    print(line)
```

* 上のコードでは、ファイルが存在している場合は開いて処理し、ファイルが存在していなければ`with`ブロックに入る前に例外が発生する

  => 例外時にはwithブロックの中の処理は実行されない

* with文には、コンテキストマネージャに対応したオブジェクトを添えて記述する

  * Pythonの組み込み型では、ファイル型がコンテキストマネージャに対応している

  * ファイル型のオブジェクトを開くことに成功した場合、`as`の次にくる変数にファイルオブジェクトが代入される

  * その後、ブロックに処理が移る(forの繰り返し変数と似ている)

* ファイルオブジェクトを開くことに失敗した場合は、ブロックを実行しない

* ブロックから抜ける時にコンテキストマネージャが再度動いて、ファイルを閉じてブロックの終了時処理を実行する

* with文では、例外処理を使うのに比べ、ブロックの処理が簡潔に記述できる



## 例外とトレースバック

* 例外を使うことの最大の利点は、「エラーの発生位置とエラー処理を分離することができる」

  * 同じエラーでも、プログラムを停止すべきか実行を続けるべきかは、処理の内容によって変わってくる

  * 処理を行う側で色々なケースに対応するのでは、プログラムが煩雑になってしまう

  * エラーを例外として外部に伝え、エラーに対する処理を外部に委ねることで、プログラムをとてもシンプルに保つことができる

* Pythonのようなオブジェクト指向の言語では、1つの処理を実行するために、様々なオブジェクトを入れ子のようにして利用する

  * 例)Webやネットワーク上の処理；ソケットの処理

  * ソケットの処理は、ネットワーク上のデータを扱うためにストリームという処理を利用している

    => 高レイヤーの処理を実現するために、より低いレイヤーの処理を実行するオブジェクトを利用している

    * 低いレイヤーで発生する例外は、必要があれば高いレイヤーで補足され、処理を継続する

    * 例外が補足されなかった場合は、Pythonは`トレースバック`と呼ばれるエラーメッセージを表示する

* 例)ある処理を実行しようとして、入れ子にして呼び出されている関数やメソッドなどの履歴を順番い表示したもの

```python
>>> from urllib import request
>>> request.urlopen("spam://spam.spam/")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "xxx", line 223, in urlopen
    return opener.open(url, data, timeout)
  File "xxx", line 526, in open
    response = self._open(req, data)
  File "xxx", line 549, in _open
    'unknown_open', req)
  File "xxx", line 504, in _call_chain
    result = func(*args)
  File "xxx", line 1388, in unknown_open
    raise URLError('unknown url type: %s' % type)
urllib.error.URLError: <urlopen error unknown url type: spam>
```

* トレースバックの1番下を見ると、エラーの原因を手早く確認できる



## 例外を発生(raise)する

* 自分が作ったクラスなどで、エラーが発生したことを外部に伝えたい場合は、故意に例外を発生させることができる

* 例外を発生させるためには、`raise`文を使う

  * 例外を発生させるためには、`例外クラス`を使う

  * raise文に、例外クラスから作った例外オブジェクトを添えて例外を発生する

  * 引数には、例外の発生した原因を文字列で渡す

```python
raise ValueError("Some message")
```

* 例外クラスを継承して独自のクラスを作り、独自の例外を定義することもできる

  * 比較的大きなプログラムを作っている時、エラーや例外の内容を細かく定義する目的で、独自の例外クラスを定義することがある

* 例外が使われれる用途として、

  * イテレータで要素を取得中に、要素がなくなったことを知らせるため

  * Pythonのプログラムを終了する仕組み

  => エラー発生を含め、プログラムの流れを変えるような **状態の変化** が起こったことを知らせるために、例外が使用される



## トレースバックを表示する

* Pythonの標準モジュールにある`traceback`を使うと、例外が発生した時に出力されるトレースバックを表示したり、文字列に格納できる

* 例外は、不具合の原因を知るための重要な手がかりとなる

  => 発生した例外をファイルに保存しておくなどすると、エラーを見つけやすくなる

* Pythonは、例外が発生した場所を記憶している

  * `traceback`モジュールを使うと、その情報を取り出して表示したり、文字列として取り出したりできる

* 例)例外を受けるexcept文で以下のように記述すると、発生した例外を標準出力に表示できる

```python
import traceback

try:

except:
  traceback.print_exc()
```

* 例)例外を文字列に保存する

```python
try:

except:
  ex = traceback.format_exc()
```



| 版 |  年月日   |
|---|----------|
|初版|2019/02/03|
